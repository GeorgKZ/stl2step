/**
 * \file
 * \brief Файл с описанием \ref express::GENERIC_ENTITY "объектного типа данных GENERIC_ENTITY" языка EXPRESS
 * (ГОСТ Р ИСО 10303-11-2009, \ref p11_s8_3_1 "п.8.3.1")
 */

namespace express {

  /**
   * \brief Атрибут объектного типа (ГОСТ Р ИСО 10303-11-2009, 9.2.1)
   *
   * \ref express::STEP_ATTRIBUTE "9.2.1 Атрибуты"
   *
   * Атрибуты типа данных <B>ENTITY</B> представляют особенности, качества или свойства присущие объекту.
   * Объявление атрибутов устанавливает взаимосвязь между типом данных <B>ENTITY</B> и типом данных,
   * представляемым атрибутом.
   *
   * Имя атрибута представляет роль, исполняемую ассоциированным с ним значением в контексте объекта,
   * в котором оно используется.
   *
   * Существуют три вида атрибутов:
   *
   * - явный атрибут, то есть атрибут, значение которого должно быть определено реализацией
   * при создании экземпляра объекта;
   * - вычисляемый атрибут, то есть атрибут, значение которого вычисляется некоторым способом;
   * - инверсный атрибут, то есть атрибут, значение которого состоит из экземпляров объекта,
   * использующих данный объект в определённой роли.
   *
   * Каждый атрибут устанавливает взаимосвязь между экземпляром объявляющего объектного типа
   * данных и некоторым другим экземпляром или экземплярами. Атрибут, представленный не агрегированным
   * типом данных, устанавливает простую взаимосвязь с этим типом данных. Атрибут, представленный агрегированным
   * типом данных, устанавливает как групповые взаимосвязи со значениями агрегированной структуры,
   * так и дистрибутивные взаимосвязи с элементами данных значений агрегированной структуры. Кроме
   * того, каждый атрибут устанавливает неявную инверсную взаимосвязь между основным типом данных и
   * объявляющим объектным типом данных.
   *
   * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
   * Дальнейшее обсуждение данных взаимосвязей приведено в приложении G.</SMALL>
   */
  class STEP_ATTRIBUTE {

  private:

    /** \brief Имя атрибута */
    std::string name;

    /** \brief Указатель на атрибут (тип или объект) */
    const GENERIC* attribute;

    /** \brief Атрибут имеет тип OPTIONAL */
    bool optional;

    /** \brief Атрибут имеет тип DERIVED --- переопределён в дочернем классе как вычисляемый */
    bool derived;

  public:

    /** \brief Конструктор атрибута */
    STEP_ATTRIBUTE(const std::string& Name, const GENERIC* Attribute, bool Optional = false) :
      name(Name),
      attribute(Attribute),
      optional(Optional),
      derived(false) {
    }

    /** \brief Указать, что атрибут вычисляемый */
    void set_derived() {
      derived = true;
    }

    /**
     * \brief Проверить, является ли атрибут вычисляемым
     * \return true, если атрибут вычисляемый и false, если нет.
     */
    bool is_derived() const {
      return derived;
    }

    /** \brief Получить имя атрибута */
    std::string get_name() const {
      return name;
    }

    /**
     * \brief Отладочный вывод информации об атрибуте
     * \param [in] offset отступ при выводе строки.
     */
    void debug_print(int offset) const {
      for (int i = 0; i < offset * 2 + 2; ++i) printf(" ");
      if (attribute == nullptr) {
        printf(" %s : %sUNKNOWN;%s\n", name.c_str(), optional ? "OPTIONAL " : "", derived ? " /* derived */" : "");
      }
      else {
        printf("  %s : %s%s;%s\n", name.c_str(), optional ? "OPTIONAL " : "", attribute->get_type_name().c_str(), derived ? " /* derived */" : "");
      }
    }

    /**
     * \brief Получить строку отображения атрибута (типа или объекта).
     * \return строка отображения атрибута
     */
    const std::string get_attribute_string() const {
      if (derived) {
        /* Атрибут был переназначен, как вычисляемый. Вернуть "*" */
        return "*";
      }

      /**
       * <B>ГОСТ Р ИСО 10303-21, 10.2.2 Отображение необязательных (OPTIONAL) явных атрибутов</B><BR>
       * Явный атрибут, объявленный как OPTIONAL, не обязан иметь значение в заданном экземпляре
       * объекта. Если необязательное значение поставляется в экземпляре объекта, оно должно быть
       * закодировано в соответствии с типом данных атрибута, как определено в 10.1. Когда необязательное
       * значение атрибута отсутствует в экземпляре объекта, оно должно быть закодировано в структуре
       * обмена как знак доллара “$”.<BR>
       */

       /* Атрибут не установлен, нартмер, потому что OPTIONAL. Вернуть "$". */
      if (attribute == nullptr) {
        if (optional) return "$";
        throw exception{__MYFUNCNAME__, "const std::string STEP_ATTRIBUTE::get_attribute_string(): attribute '%s' shall not be nullptr", name.c_str()};
      }

      if (!attribute->determinated) {
        if (optional) return "$";
        throw exception{__MYFUNCNAME__, "const std::string STEP_ATTRIBUTE::get_attribute_string(): attribute '%s' shall not be indeterminated", name.c_str()};
      }

      if (attribute->objtype() == GENERIC::OBJTYPE::OBJ_SELECT) {

        /**
         * Атрибут принадлежит к выбираемому типу данных:
         */
        std::stringstream s;

        if (attribute->get_value_objtype() && GENERIC::OBJTYPE::OBJ_DEFINED) {
          /**
           * * если значение является экземпляром простого определяемого типа в списке-выбора, оно
           * должно быть отображено в структуру обмена как KEYWORD “(” PARAMETER “)”, в котором
           * KEYWORD должно обозначать простой определяемый тип, как определено ниже, a PARAMETER
           * должен быть кодированием значения простого определяемого типа, как определено в 10.1.6;
           */
          {
            std::string attrname(attribute->get_value_type_name());
            for (auto& c : attrname) c = static_cast<char>(toupper(c));
            s << attrname;
          }
          s << "(" << attribute->print_value() << ")";
          return s.str();
        }
        else if (attribute->get_value_objtype() && GENERIC::OBJTYPE::OBJ_ENUMERATION) {
          /**
           * * если значение является экземпляром перечисляемого типа данных в списке-выбора, оно
           * должно быть отображено в структуру обмена как KEYWORD “(” PARAMETER “)”, в котором
           * KEYWORD должно обозначать перечисляемый тип данных, как определено ниже, a PARAMETER
           * должен быть кодированием значения перечисляемого типа данных, как определено в 10.1.7;
           */
          {
            std::string attrname(attribute->get_type_name());
            for (auto& c : attrname) c = static_cast<char>(toupper(c));
            s << attrname;
          }
          s << "(" << attribute->print_value() << ")";
          return s.str();

          /**
           * * если значение является экземпляром типа данных объекта в списке-выбора, оно должно быть
           * отображено в структуру обмена как имя экземпляра объекта (см. 6.3.4);
           */
        }
        else if ((attribute->get_value_objtype() && GENERIC::OBJTYPE::OBJ_ENTITY) ||
          (attribute->get_value_objtype() && GENERIC::OBJTYPE::OBJ_ENTITY_COMPLEX) ||
          /**
           * * если значение является экземпляром (вложенного) выбираемого типа данных, оно должно
           * быть отображено в структуру обмена в виде экземпляра выбираемого типа, как указано в данном
           * разделе.
           */
          (attribute->get_value_objtype() && GENERIC::OBJTYPE::OBJ_SELECT)) {
          return attribute->print_value();
        }
        else if (attribute->get_value_objtype() && GENERIC::OBJTYPE::OBJ_GENERIC) {
          throw exception{ __MYFUNCNAME__, "called by generic class '%s", attribute->get_type_name().c_str() };
        }
        else if (attribute->get_value_objtype() && GENERIC::OBJTYPE::OBJ_SIMPLE) {
          throw exception{ __MYFUNCNAME__, "called by SIMPLE class '%s'", attribute->get_type_name().c_str() };
        }
        else if (attribute->get_value_objtype() && GENERIC::OBJTYPE::OBJ_AGGREGATE) {
          throw exception{ __MYFUNCNAME__, "called by AGGREGATE class '%s'", attribute->get_type_name().c_str() };
        } else {
          throw exception{__MYFUNCNAME__, "called by unknown class '%s'", attribute->get_type_name().c_str()};
        }
      }
      else {
        return attribute->print_value();
      }
    }
  };

  /**
   * \brief Список атрибутов объектного типа
   */
  class STEP_ATTR_LIST {

  private:

    /** \brief Список атрибутов */
    std::vector<STEP_ATTRIBUTE> attrlist;

    /** \brief Имя класса */
    std::string classname;

  public:

    STEP_ATTR_LIST(const std::vector<STEP_ATTRIBUTE>& Arglist, const GENERIC* Ptr) :
      attrlist(Arglist), classname(Ptr->get_type_name()) {
    }

    /**
     * \brief Проверить (и установить при необходимости), установлен ли для атрибута с указанным именем признак DERIVED
     * для сложного объекта
     */
    bool set_derived(const std::string& name) {
      for (auto j = attrlist.begin(); j != attrlist.end(); ++j) {
        if ((*j).get_name().compare(name) == 0) {
          (*j).set_derived();
          return true;
        }
      }
      return false;
    }

    /**
     * \brief Дополнить STEP_ATTR_LIST атрибутами DERIVED из другого элемента сложного объекта
     */
    void append_derived(const STEP_ATTR_LIST& s) {
      if (s.classname.compare(classname) != 0) {
        throw exception{__MYFUNCNAME__, "INTERNAL_ERROR: STEP_ATTR_LIST::append_derived() with different class names '%s' and '%s'", classname.c_str(), s.classname.c_str()};
      }
      if (attrlist.size() != s.attrlist.size()) {
        throw exception{__MYFUNCNAME__, "STEP_ATTR_LIST::append_derived() with different attribute list size"};
      }
      std::vector<STEP_ATTRIBUTE>::const_iterator k = s.attrlist.cbegin();
      for (auto j = attrlist.begin(); j != attrlist.end(); ++j, ++k) {
        if ((*k).is_derived()) {
          (*j).set_derived();
        }
      }
    }


    /**
     * \brief Получить имя класса как в файле STEP
     */
    std::string get_classname() const {
      std::string name(classname);
      for (auto& c : name) c = static_cast<char>(toupper(c));
      return name;
    }

    /**
     * \brief Получить строку отображения списка атрибутов (и типов, и объектов).
     *
     * \return строка отображения списка атрибутов.
     */
    const std::string get_attributes_string() const {
      std::stringstream s;
      for (auto j = attrlist.cbegin(); j != attrlist.cend(); ++j) {
        s << (*j).get_attribute_string();
        if (j + 1 != attrlist.end()) s << STEP_SPACER;
      }
      return s.str();
    }


    /**
     * \brief Сравнить имена классов (для сортировки)
     */
    bool operator<(const STEP_ATTR_LIST& al) const {
      return classname < al.classname;
    }


    void debug_print(int offset) const {
      for (int i = 0; i < offset * 2; ++i) printf(" ");
      printf("'%s':\n", classname.c_str());
      for (std::vector<STEP_ATTRIBUTE>::const_iterator i = attrlist.begin(); i != attrlist.end(); ++i) {
        (*i).debug_print(offset);
      }
    }
  };

  /**
   * \brief Объектный тип данных (ГОСТ Р ИСО 10303-11-2009, 8.3.1, 9.2, 9.5.3.3)
   *
   * \ref express::GENERIC_ENTITY "8.3.1 Объектный тип данных"
   *
   * Объектные типы данных устанавливаются объявлениями посредством ключевого слова ENTITY
   * (см. \ref p11_s9_2 "9.2"). Объектный тип данных задаётся назначаемым пользователем идентификатором объекта.
   * Обращение к объектному типу данных осуществляется посредством данного идентификатора.
   \verbatim
     Синтаксис:
      152 entity_ref = entity_id .
   \endverbatim
   * Правило: элемент <B>entity_ref</B> должен быть ссылкой на объект, видимый в текущей области видимости
   * (см. раздел 10).
   *
   * <B><I>Пример --- В данном примере объектный тип данных</I> point <I>использован для представления
   * атрибута.</I>
   <PRE>
       ENTITY point;
         х, у, z : REAL;
       END_ENTITY;
       ENTITY line;
         p0, p1 : point;
       END_ENTITY;
   </PRE>
   * <I>Объект</I> line <I>имеет два атрибута с именами</I> р0 <I>и</I> p1<I>. Типом данных каждого из этих атрибутов
   * является</I> point</B>.
   */
  class GENERIC_ENTITY : public GENERIC {

  private:

    /** \brief Уникальный номер экземпляра объекта (имя) */
    mutable unsigned uid;

    /** \brief Список объектов, дополнительно входящих в сложный тип */
    std::vector<const GENERIC_ENTITY*> complex;

    /** \brief Информация об атрибутах всех дочерних классов */
    std::vector<STEP_ATTR_LIST> attr_info;

    /**
     * \brief Отображение атрибутов объектного типа данных объекта
     * \return Строка с текстом отображения.
   *
   * ISO 10303-21, 10.2 Отображение типов данных объекта из языка EXPRESS
   *
   * Экземпляр типа данных объекта из EXPRESS должен быть отображен в структуру обмена как
   * ENTITYINSTANCE.<BR>
   * Как определено в ГОСТ Р ИСО 10303-11-2009, “экземпляр простого объекта” (“simple entity
   * instance”) является экземпляром объекта, не являющегося экземпляром подтипа какого-либо типа
   * данных объекта. Все прочие экземпляры объекта называются “экземплярами сложного объекта”
   * (“complex entity instances”). Экземпляр простого объекта должен быть отображен согласно 10.2.1, а
   * экземпляр сложного объекта --- согласно \ref p21_s10_2_5 10.2.5.
   *
   * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
   * Экземпляр простого объекта является экземпляром объекта, который полностью
   * описывается единственным объявлением объекта в EXPRESS. Экземпляр сложного объекта является экземпляром,
   * описание которого включает в себя несколько объявлений объекта, даже если только одно из них содержит
   * явные атрибуты. Экземпляр простого объекта может быть экземпляром супертипа, пока последний не является
   * экземпляром какого-либо подтипа, но экземпляр подтипа всегда является «сложным».</SMALL><BR>
   * Только явные атрибуты объекта в EXPRESS отображаются в структуру обмена. Специальные
   * средства, однако, применяются к необязательным (OPTIONAL) явным атрибутом (см. 10.2.2), явным
   * атрибутам, значениями которых являются экземпляры объекта (см. 10.2.4), и всем переобъявлениям
   * явных атрибутов (см. 10.2.6---10.2.8).
   *
   * <B>ISO 10303-21, 10.2.1 Отображение экземпляра простого объекта</B><BR>
   * Экземпляр простого объекта должен быть отображен в структуру обмена как
   * SIMPLE ENTITY INSTANSE. Имя типа данных объекта должно быть отображено в KEYWORD для
   * SIMPLE RECORD, как определено в 10.2.11.<BR>
   * Каждый явный атрибут должен быть отображен непосредственно в PARAMETER для SIMPLE RECORD
   * в структуре обмена. Порядок параметров (PARAMETER) в структуре обмена должен
   * быть тем же, что и порядок соответствующих атрибутов в объявлении объекта в EXPRESS. Первый
   * PARAMETER должен быть значением первого явного атрибута, второй PARAMETER --- значением
   * второго явного атрибута и т.д. Если тип данных объекта в EXPRESS не имеет явных атрибутов,
   * список параметров (PARAMETER LIST) должен быть пустым.<BR>
   * Форма каждого PARAMETER должна зависеть от типа данных соответствующего атрибута, как
   * определено в 10.1.<BR>
   * <B>ISO 10303-21, 10.2.2 Отображение необязательных (OPTIONAL) явных атрибутов</B><BR>
   * Явный атрибут, объявленный как OPTIONAL, не обязан иметь значение в заданном экземпляре
   * объекта. Если необязательное значение поставляется в экземпляре объекта, оно должно быть
   * закодировано в соответствии с типом данных атрибута, как определено в 10.1. Когда необязательное
   * значение атрибута отсутствует в экземпляре объекта, оно должно быть закодировано в структуре
   * обмена как знак доллара “$”.<BR>
   * <B>ISO 10303-21, 10.2.3 Отображение вычисляемых (DERIVE) атрибутов</B><BR>
   * Вычисляемые атрибуты объекта не должны отображаться в структуру обмена. Когда вычисляемый
   * атрибут в подтипе переобъявляется как атрибут в супертипе, отображение должно происходить,
   * как описано в 10.2.6.

  10.2.4 Отображение атрибутов, значения которых являются экземплярами объектов
  Если экземпляр объекта определён как атрибут другого (ссылающегося на него) экземпляра
  объекта, первый (на который ссылаются) экземпляр объекта должен быть отображен в структуру
  обмена как имя экземпляра объекта (см. 6.3.4). Ссылка на этот экземпляр объекта может быть внутри
  секций данных, то есть где-то в пределах секций данных экземпляр объекта, на который ссылаются,
  должен быть указан слева от <I>знака равенства</I> "=" Это определение может предшествовать приме­
  нению экземпляра объекта в качестве атрибута или следовать за ним. Его описание не должно
  входить в эту секцию в качестве атрибута используемого экземпляра объекта.

  \anchor p21_s10_2_5
  10.2.5 Объекты, определённые как подтипы других объектов
  ГОСТ Р ИСО 10303-11-2009 определяет экземпляры объекта, имеющего раздел SUBTYPE (подтип),
  являющийся “экземплярами сложных объектов” , так, что они могут включать в себя атрибуты из
  нескольких объявлений типов объектов. В настоящем пункте определено, как экземпляры сложных
  объектов должны быть отображены в структуру обмена.
  Экземпляры сложного объекта должны быть отображены в структуру обмена на основе одного
  из двух правил: внутреннего отображения или внешнего отображения. К каждому экземпляру
  подтипа объекта должно быть применено одно правило отображения.
  П р и м е ч а н и я
  1 Выбор отображения зависит в большей мере от экземпляра объекта, чем от его типа. Для разных
  экземпляров одного и того же типа данных объекта возможно использование разных отображений в зависимости
  от того, являются ли они экземплярами подтипов и какие подтипы они представляют.
  2 Настоящий пункт применим только к экземплярам сложного объекта. Нет необходимости применять
  его к каждому экземпляру объекта супертипа. В частности, он не применяется к экземпляру супертипа, который
  не является экземпляром любого подтипа. Такие экземпляры могут существовать, если супертип не является
  абстрактным супертипом и подтипом какого-либо другого объекта. Такие экземпляры отображают согласно
  10.2.1.
  Правило отображения, которое следует использовать для каждого экземпляра объекта, выби­
  рают в зависимости от класса соответствия, выбранного для реализации. Для реализаций с классом
  соответствия 1 выбор отображения описан в 10.2.5.1. Для реализаций с классом соответствия 2 для
  всех экземпляров сложных объектов должно быть использовано внешнее отображение, описанное
  в 10.2.5.3.

  10.2.5.1 Выбор отображения по умолчанию
  Набор определений типа данных объекта, которые связаны выражениями подтипа и явного
  или неявного супертипа, определяет набор структур экземпляров сложного объекта, на который
  ссылаются как на определяемое множество в приложении В ГОСТ Р ИСО 10303-11-2009. Каждый член
  определяемого множества устанавливает список имен типов данных объектов.
  Каждый конкретный экземпляр типа данных объекта соответствует одному элементу опреде­
  ляемого множества. Отображение, применяемое к конкретному экземпляру, зависит от члена опре­
  деляемого множества, которому соответствует экземпляр.
  Для того чтобы установить, какое из правил отображения надо применить к данному экзем­
  пляру объекта:
  a) определяют список имен типов данных объекта, который становится элементом определя­
  емого множества, соответствующим экземпляру объекта;
  b) отбирают из списка все типы объектов, не имеющие подтипы, и все типы объектов, которые
  могут иметь подтипы, но для которых не определены подтипы в списке (члене определяемого
  множества) для данного экземпляра;
  c) в случае определения только одного типа данных объекта его следует считать “конечным
  типом данных объекта” (“leaf entity data type”), и должно быть применено внутреннее отображение.
  В противном случае должно быть использовано внешнее отображение.
  П р и м е ч а н и е ---При реализации положения Ь) должен быть отобран по меньшей мере один тип
  объекта.

  10.2.5.2 Внутреннее отображение
  Если используется внутреннее отображение, экземпляр объекта должен быть отображен в
  SIMPLE ENTITY INSTANCE (см. таблицу 3). Ключевое слово (KEYWORD) должно быть именем
  конечного типа данных объекта, как указано в 10.2.11. Список параметров (PARAMETER LIST)
  должен содержать значения унаследованных явных атрибутов всех объектов супертипа и явных
  атрибутов конечного типа данных объекта. Порядок, в котором унаследованные и явные атрибуты
  будут появляться в структуре обмена, должен быть определён следующим образом:
  - все унаследованные атрибуты должны появляться последовательно перед явными атрибутами
  любого объекта;
  - атрибуты объекта супертипа должны наследоваться в порядке их появления в самом объекте
  супертипа;
  - если объект супертипа сам является подтипом другого объекта, атрибуты более высокого
  супертипа должны наследоваться первыми;
  - когда указано несколько объектов супертипа, атрибуты объектов супертипа должны быть
  обработаны в порядке, определённом в выражении SUBTYPE OF.
  В результате этой процедуры н а объект супертипа может быть несколько ссылок. В этом случае
  все ссылки, кроме первой, должны быть игнорированы.

  10.2.5.3 Внешнее отображение
  Если используется внешнее отображение, экземпляр объекта должен быть отображен в
  СОМPLEX_ENTITY_INSTANCE (см. таблицу 3).
  ГОСТ Р ИСО 10303-11-2009 определяет “частное значение сложного объекта” (“partial complex entity
  value”) как множество значений атрибутов, описанных единственным EXPRESS-объявлением объ­
  екта. Каждое имя типа данных объекта в элементе определяемого множества обозначает частное
  значение сложного объекта для данного экземпляра объекта. Таким образом, элемент определяемого
  множества обозначает множество частных значений сложного объекта, что, вместе с именем экзем ­
  пляра объекта, полностью описывает заданный экземпляр объекта.
  Каждое частное значение сложного объекта, обозначаемое именем типа данны х объекта в
  элементе определяемого множества, должно быть отображено в SIMPLE RECORD (единичная
  запись) внутри SUBSUPERRECORD. Порядок SIMPLE RECORD внутри SUBSUPERRECORD
  должен быть возрастающей последовательностью имен типов данны х объекта с использованием
  схемы упорядочения, приведенной в 5.2.
  Каждая SIMPLE RECORD должна кодировать одно частное значение сложного объекта.
  KEYWORD в каждой SIMPLE RECORD должно кодировать соответствующее имя типа данных
  объекта, как определено в 10.2.11, a PARAMETER LIST должен кодировать значения явных
  атрибутов, если таковые появляю тся в соответствующем объявлении объекта. Порядок PARAMETER в
  структуре обмена должен быть тем же, что и порядок соответствующих атрибутов в EXPRESS-объявлении
  объекта. Если EXPRESS-объявление объекта не содержит явных атрибутов,
  PARAMETER_LIST должен быть пустым. Форма каждого PARAMETER должна зависеть от типа данных
  соответствующего атрибута согласно требованиям 10.1.

  10.2.6 Явные атрибуты, переобъявленные как DERIVE
  Если объект подтипа переобъявляет атрибут своего супертипа с помощью оператора DERIVE,
  а исходный атрибут является явным, то значение исходного атрибута в супертипе должно кодиро­
  ваться звездочкой “*”.

  10.2.7 Атрибуты, переобъявленные как INVERSE
  Если объект подтипа переобъявляет атрибут своего супертипа с помощью оператора INVERSE,
  это не влияет на кодирование. Переобъявленный атрибут в любом случае не кодируют.
  10.2.8 Атрибуты, переобъявленные как явные атрибуты
  Если объект подтипа переобъявляет атрибут одного из своих супертипов как явный атрибут,
  т.е. не с помощью оператора INVERSE или DERIVE, это не влияет на кодирование.
  Значение атрибута должно быть закодировано как атрибут супертипа (см. 10.2.5) с применением
  отображения, определённого в разделе 10 для типа данных атрибута в супертипе. Переобъявленный
  атрибут должен игнорироваться, т.е. он не должен применяться в качестве атрибута подтипа для
  целей кодирования.
   */
    std::string print_simple_entity() const {
      std::stringstream s;
      bool first = true;
      std::string ename(get_type_name());
      for (auto& c : ename) c = static_cast<char>(toupper(c));
      s << ename;
      s << "(";
      /* Перебор информации о классах в иерархии от старшего к младшему */
      for (auto i = attr_info.cbegin(); i != attr_info.cend(); ++i) {
        std::string t = (*i).get_attributes_string();
        if (!t.empty()) {
          if (!first) s << STEP_SPACER; else first = false;
          s << t;
        }
      }
      s << ");";
      return s.str();
    }

  public:

    /**
     * \brief Добавить информацию об атрибутах очередного дочернего класса в иерархии наследования
     */
    void add_attr_info(const STEP_ATTR_LIST& m) {
      attr_info.push_back(m);
    }

#if 0
    // Найти индекс объекта иерархии с указанным именем или -1
    size_t find_name(const std::string& name) const {
      size_t k = 0;
      for (auto i = attr_info.cbegin(); i != attr_info.cend(); ++i, ++k) {
        if (name.compare((*i).get_classname()) == 0) return k;
      }
      return -1;
    }
#endif

    /** \brief Констркутор, включающий возможность создания неопределённого типа */
    GENERIC_ENTITY(bool Determinated = true) : GENERIC(Determinated), uid(0) {
    }

    /** \brief Деструктор по умолчанию */
    virtual ~GENERIC_ENTITY() = default;

    /**
     * \brief Получить тип данных
     * \return тип данных в виде элемента перечисления OBJTYPE
     */
    virtual OBJTYPE objtype() const override {
      return !complex.empty() ? OBJTYPE::OBJ_ENTITY_COMPLEX : OBJTYPE::OBJ_ENTITY;
    }

    /**
     * \brief Добавить объект-дополнение для создания комплексного типа
     */
    void add_complex(const GENERIC_ENTITY* obj) {
      complex.push_back(obj);
    }

    /**
     * \brief Установить указанному атрибуту одного из классов иерархии наследования статус DERIVED
     */
    void set_attr_derived(const std::string& name) {
      if (attr_info.empty()) {
        throw exception{__MYFUNCNAME__, "ENTITY shall not contain empty attr_info"};
      }
      if (name.empty()) {
        throw exception{__MYFUNCNAME__, "ENTITY shall not have empty name"};
      }
      bool set = false;
      // Перебрать классы
      for (auto i = attr_info.begin(); i != attr_info.end(); ++i) {
        set = (*i).set_derived(name);
        if (set) break;
      }
      if (!set) {
        throw exception{__MYFUNCNAME__, "ENTITY shall have 's' attribute", name.c_str()};
      }
    }

#if 0
    // Отладочный вывод информации об аргументах
    void debug_attr() const {
      int offset = 0;
      for (auto i = attr_info.cbegin(); i != attr_info.cend(); ++i) {
        (*i).debug_attr(offset++);
      }
    }
#endif

    /**
     * \brief Вывести в виде строки значение типа (как атрибут объектного типа)
     * 
     * \return строковое представление значения типа.
     * 
     * Для объектных типов строковое представление экземпляра --- это имя-индекс.
     */
    virtual std::string print_value() const override {
      std::stringstream s;
      s << "#" << uid;
      return s.str();
    }

    /**
     * \brief Отображение экземпляра типа данных объекта (ГОСТ Р ИСО 10303-21, 10.2).
     * \return Строка с текстом отображения.
     *
     * <B>10.2 Отображение типов данных объекта из языка EXPRESS</B><BR>
     * Экземпляр типа данных объекта из EXPRESS должен быть отображен в структуру обмена как
     * ENTITY_INSTANCE.
     */
    std::string print() const {

      std::stringstream s;
      if (uid > 0) {
        s << "#" << uid;
        s << " = ";
        if (complex.empty()) {
          /**
           * Как определено в ГОСТ Р ИСО 10303-11-2009, “экземпляр простого объекта” (“simple entity
           * instance”) является экземпляром объекта, не являющегося экземпляром подтипа какого-либо типа
           * данных объекта. Все прочие экземпляры объекта называются “экземплярами сложного объекта”
           * (“complex entity instances”). Экземпляр простого объекта должен быть отображен согласно 10.2.1,
           */
          s << print_simple_entity();
        }
        else {
          /**
           * а экземпляр сложного объекта --- согласно 10.2.5.
           *
           * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
           * Экземпляр простого объекта является экземпляром объекта, который полностью
           * описывается единственным объявлением объекта в EXPRESS. Экземпляр сложного объекта является экземпляром,
           * описание которого включает в себя несколько объявлений объекта, даже если только одно из них содержит
           * явные атрибуты. Экземпляр простого объекта может быть экземпляром супертипа, пока последний не является
           * экземпляром какого-либо подтипа, но экземпляр подтипа всегда является «сложным».</SMALL>
           *
           * Только явные атрибуты объекта в EXPRESS отображаются в структуру обмена. Специальные
           * средства, однако, применяются к необязательным (OPTIONAL) явным атрибутом (см. 10.2.2), явным
           * атрибутам, значениями которых являются экземпляры объекта (см. 10.2.4), и всем переобъявлениям
           * явных атрибутов (см. 10.2.6---10.2.8).
           */

           // Свести информацию об объектах, составляющих комплексный объект, в один список
           // Взять информацию о типах из первого объекта
          std::vector<STEP_ATTR_LIST> attr_list(attr_info);
          // Перебрать дополнительные объекты
          for (auto i = complex.cbegin(); i != complex.cend(); ++i) {
            const std::vector<STEP_ATTR_LIST>& attr_list_i = (*i)->attr_info;
            // Перебрать иерархию типов объекта
            for (auto j = attr_list_i.cbegin(); j != attr_list_i.cend(); ++j) {
              const STEP_ATTR_LIST& attr_list_j = *j;
              const std::string& classname = attr_list_j.get_classname();
              // Есть такое имя в attr_list?
              bool found(false);
              for (auto k = attr_list.begin(); k != attr_list.end(); ++k) {
                STEP_ATTR_LIST& a_list = *k;
                if (a_list.get_classname().compare(classname) == 0) {
                  found = true;
                  // Сопоставить атрибуты, и перенести DERIVED при необходимости
                  a_list.append_derived(attr_list_j);
                  break;
                }
              }
              if (!found) {
                // Добавить в список
                attr_list.push_back(attr_list_j);
              }
            }
          }
          std::sort(attr_list.begin(), attr_list.end());
          s << "(";
          for (auto i = attr_list.cbegin(); i != attr_list.cend(); ++i) {
            const STEP_ATTR_LIST& alist = *i;
            s << alist.get_classname();
            s << "(";
            s << alist.get_attributes_string();
            s << ")";
            if (i + 1 != attr_list.cend()) s << " ";
          }
          s << ");";
        }
        return s.str();
      }
      else {
        throw exception{__MYFUNCNAME__, "zero or negative uid value"};
        return "";
      }
    }

    /**
     * \brief Установить уникальное имя объекта.
     *
     * \param [in] Uid уникальное имя объекта в виде числа
     */
    void set_id(unsigned Uid) const {
      if (Uid == 0) {
        throw exception{__MYFUNCNAME__, "zero uid value"};
      }
      uid = Uid;
    }

    /**
     * \brief Получить уникальное имя объекта в виде числа.
     *
     * \return уникальное имя объекта в виде числа
     */
    unsigned get_id() const {
      return uid;
    }
#if 0
    /**
     * \brief Получить указанный элемент дополнения комплексного объекта
     */
    const GENERIC_ENTITY* get_complex(size_t index) const {
      if (index < complex.size()) return complex[index];
      return nullptr;
    }
#endif
  };
}

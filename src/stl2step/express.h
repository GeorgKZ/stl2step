/**
 * \file
 *
 * \brief Заголовочный файл с описанием примитивов языка EXPRESS
 */

#ifndef _EXPRESS_H
#define _EXPRESS_H

#include "err.h"

#if defined(__GNUC__) || defined(__DOXYGEN__)

/**
 * \brief Для GCC выполнить Demangle
 * \param [in] mangled Строка со "сжатым" представлением имени класса.
 * \return строку с "человеко-читаемым" именем класса.
 *
 * Для GCC необходимо выполнить преобразование имения класса из "машинного" представления - без пробелов
 * и специальных символов, с кодированием неторых типов, - в читаемое представление, как
 * было в исходном тексте программы. Например, строка "N7express10class_nameE" преобразуется
 * в "class express::class_name".
 */ 
inline static const char *demangle(const char *mangled) {
  static char demangled[100];
  const size_t len = strlen(mangled);
  if (mangled[0] == 'N') {
    char sn[50];
    size_t inpos = 1;
    size_t outpos = 0;

    for (;;) {

      size_t k = 0;
      for (; inpos < len; ++inpos) {
        if (mangled[inpos] >= '0' && mangled[inpos] <= '9') {
          sn[k++] = mangled[inpos];
        } else {
          sn[k] = '\0';
          break;
        }
      }
 

      if (k == 0) {
        if (inpos == len - 1 && mangled[inpos] == 'E') {
          demangled[outpos] = '\0';
          return demangled;
        }
        demangled[outpos] = '\0';
        std::cout << "INTERNAL_ERROR: wrong demangle(\"" << mangled << "\") -> '" << demangled << "' usage by unsupported name" << std::endl;
        exit(static_cast<int>(err_enum_t::ERROR_INTERNAL));
      }

      if (outpos != 0) {
        demangled[outpos++] = ':';
        demangled[outpos++] = ':';
      } else {
        strcpy(demangled, "class ");
        outpos = 6;
      }

      size_t n = atoi(sn);
      for (k = 0; inpos < len && k < n; ++inpos, ++k) {
        demangled[outpos++] = mangled[inpos];
      }

      if (inpos >= len) {
        demangled[outpos] = '\0';
        return demangled;
      }
   }

  } else {
    std::cout << "INTERNAL_ERROR: wrong demangle(\"" << mangled << "\") usage by unsupported name" << std::endl;
    exit(static_cast<int>(err_enum_t::ERROR_INTERNAL));
  }
}

#endif


namespace express {

  /** \brief Разделитель при выводе атрибутов объекта */
  constexpr auto STEP_SPACER = ",";

  /**
   * \enum STEP_OBJTYPE
   * \brief Разновидности типов данных

   * <B>8.3.2 Определённый тип данных</B><BR>
   * Определённые типы данных устанавливаются объявлениями посредством ключевого слова <B>TYPE</B>
   * (см. 9.1). Определённый тип данных задается назначаемым пользователем идентификатором типа.
   * Обращение к определённому типу данных осуществляется посредством данного идентификатора.
   *
   * <B>ГОСТ Р ИСО 10303-21, 10.1.6 Простые определённые типы</B>
   * Простой определённый тип является типом, определяемым объявлением EXPRESS-типа, в
   * котором опорным типом не является перечисляемый тип (ENUMERATION) или выбираемый тип
   * (SELECT). Простой определённый тип должен быть отображен в структуру обмена как тот тип
   * данных, который использовался в его определении.
   */
  enum
#if !defined(__DOXYGEN__)
  class
#endif 
  STEP_OBJTYPE {
    /** Данные не определены (это самый базовый класс) */
    NONE,
    /** Простой тип данных SIMPLE (ГОСТ Р ИСО 10303-11, 8.1) */
    SIMPLE,
    /** Простой определённый тип данных (ГОСТ Р ИСО 10303-11, 8.3.2) */
    TYPE_DEFINED,
    /** Перечисляемый тип данных ENUMERATION (ГОСТ Р ИСО 10303-11, 8.4.1) */
    ENUMERATION,
    /** Выбираемый тип данных SELECT (ГОСТ Р ИСО 10303-11, 8.4.2) */
    SELECT,
    /** Объектный тип данных ENTITY, простой объект (ГОСТ Р ИСО 10303-11, 8.3.1) */
    ENTITY,
    /** Объектный тип данных ENTITY, сложный объект (ГОСТ Р ИСО 10303-11, 8.3.1) */
    ENTITY_COMPLEX
  };

  /**
   * \brief Преобразовать тип данных в строку
   * \param [in] t Тип данных в виде элемента перечисления STEP_OBJTYPE.
   * \return строку, содержащую текстовое представление названия типа данных.
   */
  inline static std::string objtype_to_string(STEP_OBJTYPE t) {
    switch (t) {
    case STEP_OBJTYPE::NONE:             return "NONE";
    case STEP_OBJTYPE::SIMPLE:           return "SIMPLE";
    case STEP_OBJTYPE::TYPE_DEFINED:     return "TYPE_DEFINED";
    case STEP_OBJTYPE::ENUMERATION:      return "ENUMERATION";
    case STEP_OBJTYPE::ENTITY:           return "ENTITY";
    case STEP_OBJTYPE::ENTITY_COMPLEX:   return "ENTITY_COMPLEX";
    case STEP_OBJTYPE::SELECT:           return "SELECT";
    }
    return "";
  }

  /**
   * \brief Самый базовый класс иерархии EXPRESS.
   *
   */
  class STEP {

  private:

    /**
     * \brief Является ли объект действительным
     *
     * Недействительный объект (если он допустим) должен выводиться как '?' или '$'
     */
    bool valid;

  public:

    STEP() : valid(true) {
    }

    /** \brief Деструктор */
    virtual ~STEP() {
    }

    /**
     * \brief Проверить, является ли объект действительным (имеет ли значение).
     * \return true, если объект имеет значение и false, если нет.
     */
    bool is_valid() {
      return valid;
    }

    void set_valid() {
      valid = true;
    }

    void set_invalid() {
      valid = false;
    }

    /**
     * \brief Получить тип данных
     * \return тип данных в виде элемента перечисления STEP_OBJTYPE
     */
    virtual STEP_OBJTYPE objtype() const {
      return STEP_OBJTYPE::NONE;
    }

    /** \brief Получить имя типа данных */
    std::string get_type_name(void) const {
      /** Получить тия типа */
      std::string classname(typeid(*this).name());

      /** Для GCC выполнить преобразование имени класса Demangle */
#if defined(_MSC_VER)
#elif defined(__GNUC__) || defined(__DOXYGEN__)
      classname = demangle(classname.c_str());
#else
#error Unknown C++ compiler
#endif
      /** Оставить от строки только имя класса */
      return classname.substr(15);
    }

    bool is_type_name(const char *Typename) const {
      return get_type_name().compare(Typename) == 0;
    }

    /** \brief Получить имя типа данных для вывода в файл STEP */
    std::string get_step_name(void) const {
      std::string classname(get_type_name());
      // Привести к заглавному виду
      std::transform(classname.begin(), classname.end(), classname.begin(), ::toupper);
      return classname;
    }

    /** \brief Получить тип данных вложенного типа (для SELECT, LIST) */
    virtual STEP_OBJTYPE get_value_objtype() const {
      std::cout << "INTERNAL_ERROR: wrong STEP::get_value_objtype() usage by derived class" << std::endl;
      exit(static_cast<int>(err_enum_t::ERROR_INTERNAL));
    }

    /** \brief Получить имя типа данных вложенного типа (для SELECT, LIST) */
    virtual const std::string get_value_step_name(void) const {
      std::cout << "INTERNAL_ERROR: wrong STEP::get_value_step_name() usage by derived class" << std::endl;
      exit(static_cast<int>(err_enum_t::ERROR_INTERNAL));
    }

    /** \brief Вывести в виде строки как атрибут - индекс (только для объектов) или значение (только для типов) */
    virtual std::string print_attr() const {
      std::cout << "INTERNAL_ERROR: wrong STEP::print_attr() usage by derived class" << std::endl;
      exit(static_cast<int>(err_enum_t::ERROR_INTERNAL));
    };

  protected:

    /** \brief Вывести в виде строки значение вложенного типа (только для типов) */
    virtual std::string print_value() const {
      std::cout << "INTERNAL_ERROR: wrong STEP::print_value() usage by derived class" << std::endl;
      exit(static_cast<int>(err_enum_t::ERROR_INTERNAL));
    };
  };

  /**
   * \brief Атрибут объектного типа
   *
   * <BLOCKQUOTE>
   * <B>ГОСТ Р ИСО 10303-11, 9.2.1 Атрибуты</B><BR>
   * Атрибуты типа данных <B>ENTITY</B> представляют особенности, качества или свойства присущие объекту.
   * Объявление атрибутов устанавливает взаимосвязь между типом данных <B>ENTITY</B> и типом данных,
   * представляемым атрибутом.<BR>
   * Имя атрибута представляет роль, исполняемую ассоциированным с ним значением в контексте объекта,
   * в котором оно используется.<BR>
   * Существуют три вида атрибутов:<BR><OL>
   * <LI>явный атрибут, то есть атрибут, значение которого должно быть определено реализацией
   * при создании экземпляра объекта;</LI>
   * <LI>вычисляемый атрибут, то есть атрибут, значение которого вычисляется некоторым способом;</LI>
   * <LI>инверсный атрибут, то есть атрибут, значение которого состоит из экземпляров объекта,
   * использующих данный объект в определенной роли.</LI></OL>
   * Каждый атрибут устанавливает взаимосвязь между экземпляром объявляющего объектного типа
   * данных и некоторым другим экземпляром или экземплярами. Атрибут, представленный не агрегированным
   * типом данных, устанавливает простую взаимосвязь с этим типом данных. Атрибут, представленный агрегированным
   * типом данных, устанавливает как групповые взаимосвязи со значениями агрегированной структуры,
   * так и дистрибутивные взаимосвязи с элементами данных значений агрегированной структуры. Кроме
   * того, каждый атрибут устанавливает неявную инверсную взаимосвязь между основным типом данных и
   * объявляющим объектным типом данных.<BR>
   * <B>ГОСТ Р ИСО 10303-11, 9.2.1.1 Явный атрибут</B><BR>
   * Явный атрибут представляет свойство, значение которого должно быть обеспечено реализацией
   * при создании экземпляра. Каждый явный атрибут определяет отдельное свойство. Объявление явного
   * атрибута создает один или несколько явных атрибутов, имеющих указанную область определения,
   * и назначает каждому из них идентификатор.<BR>
   * Правила и ограничения:
   * a) Если явный атрибут не объявлен как <B>OPTIONAL</B>, то каждый экземпляр объектного типа данных
   * должен иметь значение для данного атрибута.<BR>
   * <SMALL>Примечание — Если типом данных явного атрибута является наращиваемый перечисляемый тип
   * данных, для которого не заданы элементы перечисления, то такой объект не может быть реализован, если
   * только какое-нибудь расширение перечисляемого типа, содержащее, по крайней мере, один элемент
   * перечисления, не будет объявлено. Если типом данных явного атрибута является наращиваемый выбираемый тип
   * данных, для которого не заданы элементы списка выбора, то такой объект не может быть реализован, если
   * только какое-нибудь расширение выбираемого типа, содержащее, по крайней мере, один именованный тип,
   * не будет объявлено.</SMALL><BR>
   * b) Ключевое слово <B>OPTIONAL</B> указывает на то, что в конкретном экземпляре объекта данный атрибут
   * не обязательно должен иметь значение. Если атрибут не имеет значения, то считается, что он имеет нео-
   * пределённое (<B>?</B>) значение.<BR>
   * c) Явный атрибут не должен объявляться ни явно, ни косвенно как имеющий тип данных <B>GENERIC</B>.<BR>
   * </BLOCKQUOTE>
   */
  class STEP_ATTRIBUTE {

  private:

    // #define SAVE_VARIBLE_NAME(varible) VARIBLE_NAME = string(#varible);

    std::string name;      // Имя атрибута
    const STEP* attribute; // Указатель на атрибут (тип или объект)
    bool        optional;  // Атрибут имеет тип OPTIONAL
    bool        derived;   // Атрибут имеет тип DERIVED - переопределён в дочернем классе как вычисляемый

  public:

    STEP_ATTRIBUTE(const std::string& Name, const STEP* Attribute, bool Optional = false) :
      name(Name),
      attribute(Attribute),
      optional(Optional),
      derived(false) {
    }

    void set_derived() {
      derived = true;
    }

    bool is_derived() const {
      return derived;
    }

    std::string get_name() const {
      return name;
    }

    void debug_print(int offset) const {
      for (int i = 0; i < offset * 2 + 2; ++i) std::cout << " ";
      if (attribute == nullptr) {
        std::cout << " " << name << " : " << (optional ? "OPTIONAL " : "") << "UNKNOWN;" << (derived ? " /* derived */" : "") << std::endl;
      }
      else {
        std::cout << "  " << name << " : " << (optional ? "OPTIONAL " : "") << attribute->get_type_name() << ";" << (derived ? " /* derived */" : "") << std::endl;
      }
    }

    /**
     * \brief Получить строку отображения атрибута (типа или объекта).
     * \return строка отображения атрибута
     */
    const std::string get_attribute_string() const {
      if (derived) {
        /** Атрибут был переназначен, как вычисляемый. Вернуть "*" */
        return "*";
      }

      /**
       * <B>ГОСТ Р ИСО 10303-21, 10.2.2 Отображение необязательных (OPTIONAL) явных атрибутов</B><BR>
       * Явный атрибут, объявленный как OPTIONAL, не обязан иметь значение в заданном экземпляре
       * объекта. Если необязательное значение поставляется в экземпляре объекта, оно должно быть
       * закодировано в соответствии с типом данных атрибута, как определено в 10.1. Когда необязательное
       * значение атрибута отсутствует в экземпляре объекта, оно должно быть закодировано в структуре
       * обмена как знак доллара “$”.<BR>
       */

       /** Атрибут не установлен, нартмер, потому что OPTIONAL. Вернуть "$". */
      if (attribute == nullptr) {
        if (optional) return "$";
        std::cout << "INTERNAL_ERROR: attribute '" << name << "' has no value" << std::endl;
        exit(static_cast<int>(err_enum_t::ERROR_INTERNAL));
      }

      if (attribute->objtype() == STEP_OBJTYPE::SELECT) {

        /**
        * Атрибут принадлежит к выбираемому типу данных.
        */

        std::stringstream s;

        switch (attribute->get_value_objtype()) {
        case STEP_OBJTYPE::TYPE_DEFINED:
          /**
           * * если значение является экземпляром простого определяемого типа в списке-выбора, оно
           * должно быть отображено в структуру обмена как KEYWORD “(” PARAMETER “)”, в котором
           * KEYWORD должно обозначать простой определяемый тип, как определено ниже, a PARAMETER
           * должен быть кодированием значения простого определяемого типа, как определено в 10.1.6;
           */
          s << attribute->get_value_step_name();
          s << "(" << attribute->print_attr() << ")";
          return s.str();
        case STEP_OBJTYPE::ENUMERATION:
          /**
           * * если значение является экземпляром перечисляемого типа данных в списке-выбора, оно
           * должно быть отображено в структуру обмена как KEYWORD “(” PARAMETER “)”, в котором
           * KEYWORD должно обозначать перечисляемый тип данных, как определено ниже, a PARAMETER
           * должен быть кодированием значения перечисляемого типа данных, как определено в 10.1.7;
           */
          s << attribute->get_step_name();
          s << "(" << attribute->print_attr() << ")";
          return s.str();
        case STEP_OBJTYPE::ENTITY:
        case STEP_OBJTYPE::ENTITY_COMPLEX:
          /**
           * * если значение является экземпляром типа данных объекта в списке-выбора, оно должно быть
           * отображено в структуру обмена как имя экземпляра объекта (см. 6.3.4);
           */
          return attribute->print_attr();
        case STEP_OBJTYPE::NONE:
          std::cout << "INTERNAL_ERROR: wrong STEP_ATTRIBUTE::get_attribute_string() by unknown class" << std::endl;
          exit(static_cast<int>(err_enum_t::ERROR_INTERNAL));
        case STEP_OBJTYPE::SIMPLE:
          std::cout << "INTERNAL_ERROR: wrong STEP_ATTRIBUTE::get_attribute_string() by SIMPLE class" << std::endl;
          exit(static_cast<int>(err_enum_t::ERROR_INTERNAL));
        case STEP_OBJTYPE::SELECT:
          /**
           * * если значение является экземпляром (вложенного) выбираемого типа данных, оно должно
           * быть отображено в структуру обмена в виде экземпляра выбираемого типа, как указано в данном
           * разделе.
           */
          return attribute->print_attr();
        default:
          return "";
        }
      }
      else {
        return attribute->print_attr();
      }
    }
  };

  /**
   * \brief Класс для формальной обработки атрибутов объектного типа
   */
  class STEP_ATTR_LIST {

  private:

    /** \brief Список атрибутов */
    std::vector<STEP_ATTRIBUTE> attrlist;
    /** \brief Имя класса */
    std::string classname;

  public:

    STEP_ATTR_LIST(const std::vector<STEP_ATTRIBUTE>& Arglist, const STEP* Ptr) :
      attrlist(Arglist), classname(Ptr->get_type_name()) {
    }

    /**
     * \brief Проверить, установлен ли атрибуту с указанным именем признак DERIVED
     */
    bool set_derived(const std::string& name) {
      for (auto j = attrlist.begin(); j != attrlist.end(); ++j) {
        if ((*j).get_name().compare(name) == 0) {
          (*j).set_derived();
          return true;
        }
      }
      return false;
    }

    /**
     * \brief Дополнить STEP_ATTR_LIST атрибутами DERIVED из другого экземпляра
     */
    void append_derived(const STEP_ATTR_LIST& s) {
      if (s.classname.compare(classname) != 0) {
        std::cout << "INTERNAL_ERROR: STEP_ATTR_LIST::append_derived() with different class names '" << classname << "' and '" << s.classname << std::endl;
        exit(static_cast<int>(err_enum_t::ERROR_INTERNAL));
      }
      if (attrlist.size() != s.attrlist.size()) {
        std::cout << "INTERNAL_ERROR: STEP_ATTR_LIST::append_derived() with different attribute list size" << std::endl;
        exit(static_cast<int>(err_enum_t::ERROR_INTERNAL));
      }
      std::vector<STEP_ATTRIBUTE>::const_iterator k = s.attrlist.cbegin();
      for (auto j = attrlist.begin(); j != attrlist.end(); ++j, ++k) {
        if ((*k).is_derived()) {
          (*j).set_derived();
        }
      }
    }


    /**
     * \brief Получить имя класса как в файле STEP
     */
    std::string get_classname() const {
      std::string name(classname);
      std::transform(name.begin(), name.end(), name.begin(), ::toupper);
      return name;
    }

    /**
     * Получить строку отображения списка атрибутов (и типов, и объектов).
     *
     * \return строка отображения списка атрибутов.
     */
    const std::string get_attributes_string() const {
      std::stringstream s;
      for (auto j = attrlist.cbegin(); j != attrlist.cend(); ++j) {
        s << (*j).get_attribute_string();
        if (j + 1 != attrlist.end()) s << STEP_SPACER;
      }
      return s.str();
    }


    /**
     * \brief Сравнить имена классов (для сортировки)
     */
    bool operator<(const STEP_ATTR_LIST& al) const {
      return classname < al.classname;
    }


    void debug_print(int offset) const {
      for (int i = 0; i < offset * 2; ++i) std::cout << " ";
      std::cout << "'" << classname << "':" << std::endl;
      for (std::vector<STEP_ATTRIBUTE>::const_iterator i = attrlist.begin(); i != attrlist.end(); ++i) {
        (*i).debug_print(offset);
      }
    }
  };

  /**
   * \brief Простой тип данных EXPRESS (ГОСТ Р ИСО 10303-11, 8.1)
   *
   * <B>8.1 Простые типы данных</B><BR>
   * Простые типы данных определяют области определения элементарных единиц данных в языке
   * EXPRESS. To есть они не могут быть разделены на элементы, распознаваемые в языке EXPRESS.
   * Простыми типами данных являются NUMBER (числовой), REAL (действительный), INTEGER (целочисленный),
   * STRING (строковый), BOOLEAN (булев), LOGICAL (логический) и BINARY (двоичный).
   */
  class SIMPLE : public STEP {

  public:

    SIMPLE() {
    }

    /** \brief Деструктор */
    virtual ~SIMPLE() {
    }

    /**
     * \brief Получить тип данных
     * \return тип данных в виде элемента перечисления STEP_OBJTYPE
     */
    virtual STEP_OBJTYPE objtype() const {
      return STEP_OBJTYPE::SIMPLE;
    }

    /** \brief Вывести в виде строки как значение */
    virtual std::string print_attr() const {
      return print_value();
    }
  };

  /**
   * \brief Перечисляемый тип данных EXPRESS (ГОСТ Р ИСО 10303-11, 8.4.1)
   *
   * <B>8.4 Конструкционные типы данных</B><BR>
   * Существуют два вида конструкционных типов данных в языке EXPRESS: перечисляемый
   * (<B>\ref ENUMERATION</B>) и выбираемый (<B>\ref SELECT</B>). Эти типы данных имеют сходную синтаксическую структуру
   * и могут использоваться только для задания базисных представлений определенных типов данных (см. 9.1).
   *
   * <B>8.4.1 Перечисляемый тип данных</B><BR>
   * Областью определения перечисляемого типа данных является множество имен.
   * Размер данного множества имен определяется в зависимости от типа
   * перечисляемого типа данных. Различают следующие перечисляемые типы данных:
   * * наращиваемый перечисляемый тип данных;
   * * перечисляемый тип данных, расширяющий наращиваемый перечисляемый тип
   * данных, другими словами, основанный на наращиваемом перечисляемом типе
   * данных;
   * * перечисляемый тип данных, который не является ни наращиваемым, ни
   * расширяющим.
   *
   * Имена, объявляемые посредством ключевого слова <B>\ref ENUMERATION</B>, могут быть
   * только допустимыми значениями перечисляемого типа данных. Каждое имя из
   * данной области определения называется элементом перечисления и обозначается
   * <B>enumeration_id</B>.
   *
   * Областью определения перечисляемого типа данных, который не является ни
   * наращиваемым, ни расширяющим, задаваемой при его объявлении, является
   * упорядоченное множество элементов перечисления, указанных при его
   * объявлении.
   *
   * Областью определения наращиваемого перечисляемого типа данных является
   * множество элементов перечисления, указанных при его объявлении, плюс
   * объединение множеств элементов перечислений, заключающее в себе области
   * определения всех расширяющих перечисляемых типов данных. Наращиваемый
   * перечисляемый тип данных является обобщением основанных на нём
   * перечисляемых типов данных. Наращиваемый перечисляемый тип данных задаётся
   * посредством ключевого слова <B>EXTENSIBLE</B>.
   */
  class ENUMERATION : public STEP {

  public:

    ENUMERATION() {
    }

    /** \brief Деструктор */
    virtual ~ENUMERATION() {
    }

    /**
     * \brief Получить тип данных
     * \return тип данных в виде элемента перечисления STEP_OBJTYPE
     */
    virtual STEP_OBJTYPE objtype() const {
      return STEP_OBJTYPE::ENUMERATION;
    }

    /**
     * \brief Вывести в виде строки как значение
     *
     * <B>ISO 10303-21, 6.3.5 Перечисляемые значения</B>
     * Перечисляемое значение должно быть закодировано как последовательность <I>прописных букв</I>
     * или <I>цифр</I>, начинающаяся с <I>прописной буквы</I>, ограниченная <I>точками</I>. Смысл
     * заданного перечисляемого значения задается EXPRESS-схемой и соответствующими определениями
     * из объявлений перечисляемого типа.
     * 
     * <B>ISO 10303-21, 10.1.7 Тип данных enumeration (перечисление)</B>
     * Значения данных в языке EXPRESS типа ENUMERATION должны быть отображены в структуру
     * обмена как перечисляемый тип данных. В 6.3.5 описано содержание перечисляемого типа
     * данных.<BR>
     * Если документ, определяющий конкретную схему, экземплярами которой является предмет
     * этой секции данных, задающий набор сокращенных наименований для перечисляемых значений в
     * этой схеме, тогда фактическим значением конкретного экземпляра перечисления (ENUMERATION)
     * может быть сокращенное наименование, соответствующее одному из перечисляемых значений в
     * данной EXPRESS-схеме. В противном случае фактическим значением должно быть одно из
     * перечисляемых значений в EXPRESS-схеме. В любом случае строчные буквы должны быть преобразованы
     * в прописные буквы, а значение ограничено отделенными точками “.”, как это определено в выводе
     * ENUMERATION в Таблице 2:<BR>
     * <TT>ENUMERATION = “.” UPPER { UPPER | DIGIT } “.” .</TT>
     */
    virtual std::string print_attr() const {
      return print_value();
    }
  };

  /**
   * \brief Объектный тип данных (ГОСТ Р ИСО 10303-11, 8.3.1, 9.2)
   *
   * <B>8.3.1 Объектный тип данных</B><BR>
   * Объектные типы данных устанавливаются объявлениями посредством ключевого слова ENTITY
   * (см. 9.2). Объектный тип данных задается назначаемым пользователем идентификатором объекта.
   * Обращение к объектному типу данных осуществляется посредством данного идентификатора.
   *
   * <B>9.2 Объявление объекта</B><BR>
   * Объявление объекта <B>ENTITY</B> создает объектный тип данных и задаёт идентификатор для ссылок
   * на него.<BR>
   * Каждый атрибут представляет свойство объекта и может быть ассоциирован со значением в каждом
   * экземпляре объекта. Тип данных атрибута устанавливает область определения его возможных значений.
   */
  class STEP_ENTITY : public STEP {

  private:

    /** \brief Уникальный номер экземпляра объекта */
    mutable unsigned uid;

    /** \brief Список объектов, дополнительно входящих в сложный тип */
    std::vector<const STEP_ENTITY*> complex;

    /** \brief Информация об атрибутах всех дочерних классов */
    std::vector<STEP_ATTR_LIST> attr_info;

    /**
     * \brief Отображение атрибутов объектного типа данных объекта
     *
     * \return Строка с текстом отображения.
     *
   * <B>ISO 10303-21, 10.2 Отображение типов данных объекта из языка EXPRESS</B><BR>
   * Экземпляр типа данных объекта из EXPRESS должен быть отображен в структуру обмена как
   * ENTITYINSTANCE.<BR>
   * Как определено в ГОСТ Р ИСО 10303-11, “экземпляр простого объекта” (“simple entity
   * instance”) является экземпляром объекта, не являющегося экземпляром подтипа какого-либо типа
   * данных объекта. Все прочие экземпляры объекта называются “экземплярами сложного объекта”
   * (“complex entity instances”). Экземпляр простого объекта должен быть отображен согласно 10.2.1, а
   * экземпляр сложного объекта — согласно 10.2.5.<BR>
   * <SMALL>Примечание - Экземпляр простого объекта является экземпляром объекта, который полностью
   * описывается единственным объявлением объекта в EXPRESS. Экземпляр сложного объекта является экземпляром,
   * описание которого включает в себя несколько объявлений объекта, даже если только одно из них содержит
   * явные атрибуты. Экземпляр простого объекта может быть экземпляром супертипа, пока последний не является
   * экземпляром какого-либо подтипа, но экземпляр подтипа всегда является «сложным».</SMALL><BR>
   * Только явные атрибуты объекта в EXPRESS отображаются в структуру обмена. Специальные
   * средства, однако, применяются к необязательным (OPTIONAL) явным атрибутом (см. 10.2.2), явным
   * атрибутам, значениями которых являются экземпляры объекта (см. 10.2.4), и всем переобъявлениям
   * явных атрибутов (см. 10.2.6—10.2.8).
   *
   * <B>ISO 10303-21, 10.2.1 Отображение экземпляра простого объекта</B><BR>
   * Экземпляр простого объекта должен быть отображен в структуру обмена как
   * SIMPLE ENTITY INSTANSE. Имя типа данных объекта должно быть отображено в KEYWORD для
   * SIMPLE RECORD, как определено в 10.2.11.<BR>
   * Каждый явный атрибут должен быть отображен непосредственно в PARAMETER для SIMPLE RECORD
   * в структуре обмена. Порядок параметров (PARAMETER) в структуре обмена должен
   * быть тем же, что и порядок соответствующих атрибутов в объявлении объекта в EXPRESS. Первый
   * PARAMETER должен быть значением первого явного атрибута, второй PARAMETER — значением
   * второго явного атрибута и т.д. Если тип данных объекта в EXPRESS не имеет явных атрибутов,
   * список параметров (PARAMETER LIST) должен быть пустым.<BR>
   * Форма каждого PARAMETER должна зависеть от типа данных соответствующего атрибута, как
   * определено в 10.1.<BR>
   * <B>ISO 10303-21, 10.2.2 Отображение необязательных (OPTIONAL) явных атрибутов</B><BR>
   * Явный атрибут, объявленный как OPTIONAL, не обязан иметь значение в заданном экземпляре
   * объекта. Если необязательное значение поставляется в экземпляре объекта, оно должно быть
   * закодировано в соответствии с типом данных атрибута, как определено в 10.1. Когда необязательное
   * значение атрибута отсутствует в экземпляре объекта, оно должно быть закодировано в структуре
   * обмена как знак доллара “$”.<BR>
   * <B>ISO 10303-21, 10.2.3 Отображение вычисляемых (DERIVE) атрибутов</B><BR>
   * Вычисляемые атрибуты объекта не должны отображаться в структуру обмена. Когда вычисляемый
   * атрибут в подтипе переобъявляется как атрибут в супертипе, отображение должно происходить,
   * как описано в 10.2.6.

  10.2.4 Отображение атрибутов, значения которых являются экземплярами объектов
  Если экземпляр объекта определен как атрибут другого (ссылающегося на него) экземпляра
  объекта, первый (на который ссылаются) экземпляр объекта должен быть отображен в структуру
  обмена как имя экземпляра объекта (см. 6.3.4). Ссылка на этот экземпляр объекта может быть внутри
  секций данных, то есть где-то в пределах секций данных экземпляр объекта, на который ссылаются,
  должен быть указан слева от <I>знака равенства</I> "=" Это определение может предшествовать приме­
  нению экземпляра объекта в качестве атрибута или следовать за ним. Его описание не должно
  входить в эту секцию в качестве атрибута используемого экземпляра объекта.

  10.2.5 Объекты, определенные как подтипы других объектов
  ГОСТ Р ИСО 10303-11 определяет экземпляры объекта, имеющего раздел SUBTYPE (подтип),
  являющийся “экземплярами сложных объектов” , так, что они могут включать в себя атрибуты из
  нескольких объявлений типов объектов. В настоящем пункте определено, как экземпляры сложных
  объектов должны быть отображены в структуру обмена.
  Экземпляры сложного объекта должны быть отображены в структуру обмена на основе одного
  из двух правил: внутреннего отображения или внешнего отображения. К каждому экземпляру
  подтипа объекта должно быть применено одно правило отображения.
  П р и м е ч а н и я
  1 Выбор отображения зависит в большей мере от экземпляра объекта, чем от его типа. Для разных
  экземпляров одного и того же типа данных объекта возможно использование разных отображений в зависимости
  от того, являются ли они экземплярами подтипов и какие подтипы они представляют.
  2 Настоящий пункт применим только к экземплярам сложного объекта. Нет необходимости применять
  его к каждому экземпляру объекта супертипа. В частности, он не применяется к экземпляру супертипа, который
  не является экземпляром любого подтипа. Такие экземпляры могут существовать, если супертип не является
  абстрактным супертипом и подтипом какого-либо другого объекта. Такие экземпляры отображают согласно
  10.2.1.
  Правило отображения, которое следует использовать для каждого экземпляра объекта, выби­
  рают в зависимости от класса соответствия, выбранного для реализации. Для реализаций с классом
  соответствия 1 выбор отображения описан в 10.2.5.1. Для реализаций с классом соответствия 2 для
  всех экземпляров сложных объектов должно быть использовано внешнее отображение, описанное
  в 10.2.5.3.

  10.2.5.1 Выбор отображения по умолчанию
  Набор определений типа данных объекта, которые связаны выражениями подтипа и явного
  или неявного супертипа, определяет набор структур экземпляров сложного объекта, на который
  ссылаются как на определяемое множество в приложении В ГОСТ Р ИСО 10303-11. Каждый член
  определяемого множества устанавливает список имен типов данных объектов.
  Каждый конкретный экземпляр типа данных объекта соответствует одному элементу опреде­
  ляемого множества. Отображение, применяемое к конкретному экземпляру, зависит от члена опре­
  деляемого множества, которому соответствует экземпляр.
  Для того чтобы установить, какое из правил отображения надо применить к данному экзем­
  пляру объекта:
  a) определяют список имен типов данных объекта, который становится элементом определя­
  емого множества, соответствующим экземпляру объекта;
  b) отбирают из списка все типы объектов, не имеющие подтипы, и все типы объектов, которые
  могут иметь подтипы, но для которых не определены подтипы в списке (члене определяемого
  множества) для данного экземпляра;
  c) в случае определения только одного типа данных объекта его следует считать “конечным
  типом данных объекта” (“leaf entity data type”), и должно быть применено внутреннее отображение.
  В противном случае должно быть использовано внешнее отображение.
  П р и м е ч а н и е —При реализации положения Ь) должен быть отобран по меньшей мере один тип
  объекта.

  10.2.5.2 Внутреннее отображение
  Если используется внутреннее отображение, экземпляр объекта должен быть отображен в
  SIM PLE ENTITY INSTANCE (см. таблицу 3). Ключевое слово (KEYWORD) должно быть именем
  конечного типа данных объекта, как указано в 10.2.11. Список параметров (PARAMETER LIST)
  должен содержать значения унаследованных явных атрибутов всех объектов супертипа и явных
  атрибутов конечного типа данных объекта. Порядок, в котором унаследованные и явные атрибуты
  будут появляться в структуре обмена, должен быть определен следующим образом:
  - все унаследованные атрибуты должны появляться последовательно перед явными атрибутами
  любого объекта;
  - атрибуты объекта супертипа должны наследоваться в порядке их появления в самом объекте
  супертипа;
  - если объект супертипа сам является подтипом другого объекта, атрибуты более высокого
  супертипа должны наследоваться первыми;
  - когда указано несколько объектов супертипа, атрибуты объектов супертипа должны быть
  обработаны в порядке, определенном в выражении SUBTYPE OF.
  В результате этой процедуры н а объект супертипа может быть несколько ссылок. В этом случае
  все ссылки, кроме первой, должны быть игнорированы.

  10.2.5.3 Внешнее отображение
  Если используется внешнее отображение, экземпляр объекта должен быть отображен в
  СОМPLEX_ENTITY_INSTANCE (см. таблицу 3).
  ГОСТ Р ИСО 10303-11 определяет “частное значение сложного объекта” (“partial complex entity
  value”) как множество значений атрибутов, описанных единственным EXPRESS-объявлением объ­
  екта. Каждое имя типа данных объекта в элементе определяемого множества обозначает частное
  значение сложного объекта для данного экземпляра объекта. Таким образом, элемент определяемого
  множества обозначает множество частных значений сложного объекта, что, вместе с именем экзем ­
  пляра объекта, полностью описывает заданный экземпляр объекта.
  Каждое частное значение сложного объекта, обозначаемое именем типа данны х объекта в
  элементе определяемого множества, должно быть отображено в SIMPLE RECORD (единичная
  запись) внутри SUBSUPERRECORD. Порядок SIMPLE RECORD внутри SUBSUPERRECORD
  должен быть возрастающей последовательностью имен типов данны х объекта с использованием
  схемы упорядочения, приведенной в 5.2.
  Каждая SIMPLE RECORD должна кодировать одно частное значение сложного объекта.
  KEYWORD в каждой SIMPLE RECORD должно кодировать соответствующее имя типа данных
  объекта, как определено в 10.2.11, a PARAMETER LIST должен кодировать значения явных
  атрибутов, если таковые появляю тся в соответствующем объявлении объекта. Порядок PARAMETER в
  структуре обмена должен быть тем же, что и порядок соответствующих атрибутов в EXPRESS-объявлении
  объекта. Если EXPRESS-объявление объекта не содержит явных атрибутов,
  PARAMETER_LIST должен быть пустым. Форма каждого PARAMETER должна зависеть от типа данных
  соответствующего атрибута согласно требованиям 10.1.

  10.2.6 Явные атрибуты, переобъявленные как DERIVE
  Если объект подтипа переобъявляет атрибут своего супертипа с помощью оператора DERIVE,
  а исходный атрибут является явным, то значение исходного атрибута в супертипе должно кодиро­
  ваться звездочкой “*”.

  10.2.7 Атрибуты, переобъявленные как INVERSE
  Если объект подтипа переобъявляет атрибут своего супертипа с помощью оператора INVERSE,
  это не влияет на кодирование. Переобъявленный атрибут в любом случае не кодируют.
  10.2.8 Атрибуты, переобъявленные как явные атрибуты
  Если объект подтипа переобъявляет атрибут одного из своих супертипов как явный атрибут,
  т.е. не с помощью оператора INVERSE или DERIVE, это не влияет на кодирование.
  Значение атрибута должно быть закодировано как атрибут супертипа (см. 10.2.5) с применением
  отображения, определенного в разделе 10 для типа данных атрибута в супертипе. Переобъявленный
  атрибут должен игнорироваться, т.е. он не должен применяться в качестве атрибута подтипа для
  целей кодирования.
   */
    std::string print_simple_entity() const {
      std::stringstream s;
      bool first = true;
      s << get_step_name();
      s << "(";
      /* Перебор информации о классах в иерархии от старшего к младшему */
      for (auto i = attr_info.cbegin(); i != attr_info.cend(); ++i) {
        std::string t = (*i).get_attributes_string();
        if (!t.empty()) {
          if (!first) s << STEP_SPACER; else first = false;
          s << t;
        }
      }
      s << ");";
      return s.str();
    }

  public:

    /**
     * \brief Добавить информацию об атрибутах очередного дочернего класса в иерархии наследования
     */
    void add_attr_info(const STEP_ATTR_LIST& m) {
      attr_info.push_back(m);
    }

#if 0
    // Найти индекс объекта иерархии с указанным именем или -1
    size_t find_name(const std::string& name) const {
      size_t k = 0;
      for (auto i = attr_info.cbegin(); i != attr_info.cend(); ++i, ++k) {
        if (name.compare((*i).get_classname()) == 0) return k;
      }
      return -1;
    }
#endif

    /** \brief Конструктор */
    STEP_ENTITY() : uid(0) {
    }

    /** \brief Деструктор */
    virtual ~STEP_ENTITY() {
    }

    /**
     * \brief Получить тип данных
     * \return тип данных в виде элемента перечисления STEP_OBJTYPE
     */
    virtual STEP_OBJTYPE objtype() const {
      return !complex.empty() ? STEP_OBJTYPE::ENTITY_COMPLEX : STEP_OBJTYPE::ENTITY;
    }

    /**
     * \brief Добавить объект-дополнение для создания комплексного типа
     */
    void add_complex(const STEP_ENTITY* obj) {
      complex.push_back(obj);
    }

    /**
     * \brief Установить указанному атрибуту одного из классов иерархии наследования статус DERIVED
     */
    void set_attr_derived(const std::string& name) {
      if (attr_info.empty()) {
        std::cout << "INTERNAL_ERROR: STEP_ENTITY::set_attr_derived() with empty arg_info" << std::endl;
        exit(static_cast<int>(err_enum_t::ERROR_INTERNAL));
      }
      if (name.empty()) {
        std::cout << "INTERNAL_ERROR: STEP_ENTITY::set_attr_derived() with empty name" << std::endl;
        exit(static_cast<int>(err_enum_t::ERROR_INTERNAL));
      }
      bool set = false;
      // Перебрать классы
      for (auto i = attr_info.begin(); i != attr_info.end(); ++i) {
        set = (*i).set_derived(name);
        if (set) break;
      }
      if (!set) {
        std::cout << "INTERNAL_ERROR: STEP_ENTITY::set_attr_derived() can't find argument" << std::endl;
        exit(static_cast<int>(err_enum_t::ERROR_INTERNAL));
      }
    }

#if 0
    // Отладочный вывод информации об аргументах
    void debug_attr(void) const {
      int offset = 0;
      for (auto i = attr_info.cbegin(); i != attr_info.cend(); ++i) {
        (*i).debug_attr(offset++);
      }
    }
#endif

    /**
     * \brief Вывод в виде строки если это атрибут
     */
    virtual std::string print_attr() const {
      std::stringstream s;
      s << "#" << uid;
      return s.str();
    }

    /**
     * \brief Отображение экземпляра типа данных объекта (ГОСТ Р ИСО 10303-21, 10.2).
     * \return Строка с текстом отображения.
     *
     * <B>10.2 Отображение типов данных объекта из языка EXPRESS</B><BR>
     * Экземпляр типа данных объекта из EXPRESS должен быть отображен в структуру обмена как
     * ENTITY_INSTANCE.
     */
    std::string print(void) const {

      std::stringstream s;
      if (uid > 0) {
        s << "#" << uid;
        s << " = ";
        if (complex.empty()) {
          /**
           * Как определено в ГОСТ Р ИСО 10303-11, “экземпляр простого объекта” (“simple entity
           * instance”) является экземпляром объекта, не являющегося экземпляром подтипа какого-либо типа
           * данных объекта. Все прочие экземпляры объекта называются “экземплярами сложного объекта”
           * (“complex entity instances”). Экземпляр простого объекта должен быть отображен согласно 10.2.1,
           */
          s << print_simple_entity();
        }
        else {
          /**
           * а экземпляр сложного объекта — согласно 10.2.5.<BR>
           * <SMALL>Примечание - Экземпляр простого объекта является экземпляром объекта, который полностью
           * описывается единственным объявлением объекта в EXPRESS. Экземпляр сложного объекта является экземпляром,
           * описание которого включает в себя несколько объявлений объекта, даже если только одно из них содержит
           * явные атрибуты. Экземпляр простого объекта может быть экземпляром супертипа, пока последний не является
           * экземпляром какого-либо подтипа, но экземпляр подтипа всегда является «сложным».</SMALL><BR>
           * Только явные атрибуты объекта в EXPRESS отображаются в структуру обмена. Специальные
           * средства, однако, применяются к необязательным (OPTIONAL) явным атрибутом (см. 10.2.2), явным
           * атрибутам, значениями которых являются экземпляры объекта (см. 10.2.4), и всем переобъявлениям
           * явных атрибутов (см. 10.2.6—10.2.8).
           */

           // Свести информацию об объектах, составляющих комплексный объект, в один список
           // Взять информацию о типах из первого объекта
          std::vector<STEP_ATTR_LIST> attr_list(attr_info);
          // Перебрать дополнительные объекты
          for (auto i = complex.cbegin(); i != complex.cend(); ++i) {
            const std::vector<STEP_ATTR_LIST>& attr_list_i = (*i)->attr_info;
            // Перебрать иерархию типов объекта
            for (auto j = attr_list_i.cbegin(); j != attr_list_i.cend(); ++j) {
              const STEP_ATTR_LIST& attr_list_j = *j;
              const std::string& classname = attr_list_j.get_classname();
              // Есть такое имя в attr_list?
              bool found(false);
              for (auto k = attr_list.begin(); k != attr_list.end(); ++k) {
                STEP_ATTR_LIST& a_list = *k;
                if (a_list.get_classname().compare(classname) == 0) {
                  found = true;
                  // Сопоставить атрибуты, и перенести DERIVED при необходимости
                  a_list.append_derived(attr_list_j);
                  break;
                }
              }
              if (!found) {
                // Добавить в список
                attr_list.push_back(attr_list_j);
              }
            }
          }
          std::sort(attr_list.begin(), attr_list.end());
          s << "(";
          for (auto i = attr_list.cbegin(); i != attr_list.cend(); ++i) {
            const STEP_ATTR_LIST& alist = *i;
            s << alist.get_classname();
            s << "(";
            s << alist.get_attributes_string();
            s << ")";
            if (i + 1 != attr_list.cend()) s << " ";
          }
          s << ");";
        }
        return s.str();
      }
      else {
        std::cout << "INTERNAL_ERROR: Wrong id in STEP_ENTITY::print()" << std::endl;
        exit(static_cast<int>(err_enum_t::ERROR_INTERNAL));
      }
    }

    /**
     * \brief Установить уникальное имя объекта.
     *
     * \param [in] Uid уникальное имя объекта в виде числа
     */
    void set_id(unsigned Uid) const {
      if (Uid == 0) {
        std::cout << "INTERNAL_ERROR: Wrong Uid in STEP_ENTITY::set_id(Uid)" << std::endl;
        exit(static_cast<int>(err_enum_t::ERROR_INTERNAL));
      }
      uid = Uid;
    }

    /**
     * \brief Получить уникальное имя объекта в виде числа.
     *
     * \return уникальное имя объекта в виде числа
     */
    unsigned get_id() const {
      return uid;
    }

    /**
     * \brief Получить указанный элемент дополнения комплексного объекта
     */
    const STEP_ENTITY* get_complex(size_t index) const {
      if (index < complex.size()) return complex[index];
      return nullptr;
    }
  };

  /**
   * \brief выбираемый тип EXPRESS (ГОСТ Р ИСО 10303-11, 8.4.2)
   *
   * <B>ГОСТ Р ИСО 10303-11, 8.4 Конструкционные типы данных</B><BR>
   * Существуют два вида конструкционных типов данных в языке EXPRESS: перечисляемый
   * (<B>ENUMERATION</B>) и выбираемый (<B>SELECT</B>). Эти типы данных имеют сходную синтаксическую структуру
   * и могут использоваться только для задания базисных представлений определенных типов данных (см. 9.1).
   * <BR>
   * <B>ISO 10303-11, 88.4.2 Выбираемый тип данных</B><BR>
   * Выбираемый  тип  данных  определяет  тип данных, позволяющий выбирать среди
   * нескольких   именованных  типов  данных.  Выбираемый  тип  данных  является
   * обобщением   именованных   типов   данных   в  своей  области  определения.
   * Определенный  тип  данных,  для  которого  выбираемый  тип  данных является
   * базисным  представлением,  может  добавлять  ограничения  на  свою  область
   * определения  посредством объявления локальных правил. Выбираемый тип данных
   * может  быть или не быть наращиваемым.<BR>
   * Областью  определения  выбираемого  типа данных,  который  не  является  ни
   * наращиваемым,   ни расширяющим, является объединение  областей  определения
   * именованных  типов данных из его списка выбора.
   * Областью   определения   наращиваемого  выбираемого  типа  данных  является
   * объединение   областей   определения   именованных   типов  данных  из  его
   * собственного  списка  выбора  плюс  объединение  областей  определения всех
   * расширяющих  выбираемых  типов  данных.  Наращиваемый выбираемый тип данных
   * задается посредством ключевого слова <B>EXTENSIBLE</B>.<BR>
   * Областью   определения   расширяющего   выбираемого  типа  данных  являются
   * именованные  типы данных из его собственного списка выбора плюс именованные
   * типы   данных,   указанные   непосредственно  (а  не  через  расширение)  в
   * наращиваемом  выбираемом  типе  данных,  на котором он основан. Расширяющий
   * выбираемый тип данных задается посредством ключевого слова <B>BASED_ON</B>.
   * Выбираемый  тип  данных  может  быть  как  наращиваемым,  так и расширяющим
   * выбираемым  типом  данных.  Наращиваемый  выбираемый  тип данных может быть
   * задан  без списка выбора, а также основан на другом наращиваемом выбираемом
   * типе  данных  без  задавания  списка  выбора,  расширяющего данный базисный
   * список выбора.<BR>
   * Только  наращиваемый  выбираемый тип данных может быть ограничен наличием в
   * своей области определения только экземпляров объектов посредством ключевого
   * слова  <B>GENERIC_ENTITY</B>.  В  данном  случае все элементы списка выбора должны
   * быть  элементами  обобщенного  объекта,  где  элемент  обобщенного  объекта
   * определяется  как относящийся к объектному типу данных либо к списку выбора
   * из  элементов  обобщенного объекта. Все расширения данного выбираемого типа
   * данных  должны  быть выбираемыми типами данных обобщенного объекта и должны
   * задаваться посредством ключевого слова <B>GENERIC_ENTITY</B>.
   */
  class SELECT : public STEP {

  private:

    /** \brief Переменная, которая может принимать значения указателей на типы и объекты из выбираемого типа */
    const STEP* value;

  protected:

    /** \brief Установить значение указателя на выбираемый тип */
    void set_value(const STEP* t) {
      value = t;
    }

  public:

    /** \brief Конструктор */
    SELECT(const STEP* t) {
      value = t;
    }

    /** \brief Деструктор */
    virtual ~SELECT() {
    }

    /** \brief Получить указатель на выбранный тип */
    const STEP* get_value() const {
      return value;
    }

    /**
     * \brief Получить тип данных
     * \return тип данных в виде элемента перечисления STEP_OBJTYPE
     */
    virtual STEP_OBJTYPE objtype() const {
      return STEP_OBJTYPE::SELECT;
    }

    /** \brief Получить имя типа данных выбранного типа */
    virtual const std::string get_value_step_name(void) const {
      if (value == nullptr) return "VALUE_NULLPTR";
      return value->get_step_name();
    }

    /** \brief Получить тип данных выбранного типа */
    virtual STEP_OBJTYPE get_value_objtype() const {
      if (value == nullptr) return STEP_OBJTYPE::NONE;
      return value->objtype();
    }

    /**
     * \brief Вывод в виде строки как атрибут объектного типа (ГОСТ Р ИСО 10303-21, 10.1.8)
     * 
     * <B>10.1.8 Выбираемый тип данных</B><BR>
     * Выбираемый тип данных в языке EXPRESS определяет список типов данных, называемый
     * “список-выбора” (“select-list”), значениями которого являются правильные экземпляры данных
     * выбираемого типа. Экземпляр данных выбираемого типа должен быть значением по меньшей мере
     * одного из типов данных в списке-выбора:
     * <OL><LI>если значение является экземпляром типа данных объекта в списке-выбора, оно должно быть
     * отображено в структуру обмена как имя экземпляра объекта (см. 6.3.4);</LI>
     * <LI>если значение является экземпляром простого определяемого типа в списке-выбора, оно
     * должно быть отображено в структуру обмена как TYPED PARAMETER (см. таблицу 3), в котором
     * KEYWORD должно обозначать простой определяемый тип, как определено ниже, a PARAMETER
     * должен быть кодированием значения простого определяемого типа, как определено в 10.1.6;</LI>
     * <LI>если значение является экземпляром перечисляемого типа данных в списке-выбора, оно
     * должно быть отображено в структуру обмена как TYPED PARAMETER (см. таблицу 3), в котором
     * KEYWORD должно обозначать перечисляемый тип данных, как определено ниже, a PARAMETER
     * должен быть кодированием значения перечисляемого типа данных, как определено в 10.1.7;</LI>
     * <LI>если значение является экземпляром (вложенного) выбираемого типа данных, оно должно
     * быть отображено в структуру обмена в виде экземпляра выбираемого типа, как указано в данном
     * разделе.</LI></OL>
     */
    virtual std::string print_attr() const {
      if (value == this) {
        std::cout << "INTERNAL_ERROR: " << get_type_name().c_str() << "::SELECT::print_attr() with value == this" << std::endl;
        exit(static_cast<int>(err_enum_t::ERROR_INTERNAL));
      }
      if (value == nullptr) {
        std::cout << "INTERNAL_ERROR: " << get_type_name().c_str() << "::SELECT::print_attr() with value == nullptr" << std::endl;
        exit(static_cast<int>(err_enum_t::ERROR_INTERNAL));
      }
      return value->print_attr();
    }
  };


  /** \brief Объявление конструктора выбираемого типа данных */
#define STEP_TYPE_SELECT_CONSTRUCTOR_DEF(B, T) B(const T* t)

  /** \brief Определение конструктора выбираемого типа данных */
#define STEP_TYPE_SELECT_CONSTRUCTOR(B, T) B::B(const T* t) : SELECT(t) { }



/*

  // Преобразование выбираемого типа к одному из составляющих типов
  operator const T* () const {
    return dynamic_cast<const T*>(get_value());
  }


//!!! Операторы присвоения????
  layered_item& operator=(const presentation_representation& t) {
    set_value(&t);
    return *this;
  }
  layered_item& operator=(const representation_item& t) {
    set_value(&t);
    return *this;
  }



*/


  /**
   * \brief Шаблон для типов данных AGGREGATE (ГОСТ Р ИСО 10303-11, 8.2)
   *
   * <B>8.2 Агрегированные типы данных</B><BR>
   * Областями определения агрегированных типов данных являются совокупности значений заданного
   * базисного типа данных (см. 8.6.1). Эти значения базисного типа данных называются элементами агрегированной
   * совокупности. В языке EXPRESS определены четыре вида агрегированных типов данных: <B>ARRAY</B>
   * (массив), <B>\ref LIST</B> (список), <B>BAG</B> (пакет) и <B>\ref SET</B> (набор). Значения каждого вида агрегированного типа данных
   * имеют разные свойства. Тип данных <B>\ref AGGREGATE</B> является обобщением этих четырех видов агрегированных
   * типов данных (см. 9.5.3.1).<BR>
   * Тип данных <B>ARRAY</B> представляет упорядоченное множество фиксированного размера, индексированное
   * последовательностью целых чисел.
   *
   * <SMALL><B><I>Пример - Матрица преобразования (в геометрии) может быть определена как массив массивов
   * (чисел).</I></B></SMALL>
   *
   * Тип данных <B>\ref LIST</B> представляет последовательность элементов, доступ к которым осуществляется по
   * их позициям. Число элементов в списке может изменяться и быть ограничено в определении типа данных.
   *
   * <SMALL><B><I>Пример - Операции технологического маршрута могут быть представлены списком. Операции
   * упорядочены и могут быть добавлены или удалены из технологического маршрута.</I></B></SMALL>
   *
   * Тип данных <B>BAG</B> представляет неупорядоченное множество, в котором разрешены повторяющиеся
   * элементы. Число элементов в пакете может изменяться и быть ограничено в определении типа данных.
   *
   * <SMALL><B><I>Пример - Совокупность крепежных деталей, используемых при сборке, может быть
   * представлено пакетом. В состав его элементов может входить некоторое число одинаковых болтов,
   * но неважно, который из них используется в конкретном отверстии.</I></B></SMALL>
   *
   * Тип данных <B>\ref SET</B> представляет неупорядоченное множество элементов, в котором нет двух
   * одинаковых элементов. Число элементов в наборе может изменяться и быть ограничено в определении
   * типа данных.
   *
   * <SMALL><B><I>Пример — Множество людей во всем мире является набором.</I></B></SMALL>
   *
   * <SMALL>Примечание - Агрегированные типы данных в языке EXPRESS являются одномерными. Объекты,
   * обычно рассматриваемые как многомерные (например, математические матрицы), могут быть представлены
   * агрегированным типом данных, базисным типом которого является другой агрегированный тип данных. Таким
   * образом, агрегированные типы данных могут быть вложенными на произвольную глубину, обеспечивая
   * представление структур данных любой размерности.</SMALL>
   *
   * <SMALL><B><I>Пример — Можно определить структуру LIST [1:3] OF ARRAY [5:10] OF INTEGER, которая в
   * действительности является двумерной.</I></B></SMALL>
   *
   * Внимание! Во всех дочених шаблонах элемент набора - это указатель на класс, дочерний классу STEP.
   */
  class AGGREGATE : public STEP_ENTITY {
  };

  /**
   * \brief Шаблон для типов данных <B>\ref LIST</B> (ГОСТ Р ИСО 10303-11, 8.2.2)
   *
   * <B>8.2.2 Тип данных \ref LIST</B><BR>
   * Областью определения типа данных <B>\ref LIST</B> являются последовательности подобных элементов.
   * Необязательные нижняя и верхняя границы, задаваемые выражениями, имеющими целочисленные
   * значения, определяют минимальное и максимальное число элементов в совокупности, определенной
   * типом данных <B>\ref LIST</B>. В определении типа данных <B>\ref LIST</B> может быть факультативно
   * установлено, что в списке не могут присутствовать одинаковые элементы.
   * \verbatim
   Синтаксис:
    250 list_type = LIST [ bound_spec ] OF [ UNIQUE ] instantiable_type .
    185 bound_spec = ' [ ' bound_1 ' : ' bound_2 ' ] ' .
    183 bound_1 = numeric_expression .
    184 bound_2 = numeric_expression .
   \endverbatim
   * Правила и ограничения:<BR>
   * a) Выражение <B>bound_1</B> должно иметь целочисленное значение, большее или равное нулю. Оно
   * задаёт нижнюю границу, определяющую минимальное число элементов, которое может содержаться в списке
   * этого типа данных. Выражение <B>bound_1</B> не должно иметь неопределенного (?) значения.<BR>
   * b) Выражение <B>bound_2</B> должно иметь целочисленное значение, большее или равное значению
   * <B>bound_1</B>, либо неопределенное (?) значение. Оно задает верхнюю границу, определяющую максимальное
   * число элементов, которое может содержаться в списке этого типа данных. Если значение данного
   * выражения является неопределенным (?), то число элементов в списке этого типа данных не ограничено сверху.<BR>
   * c) Если элемент <B>bound_spec</B> опущен, то границы списка определяются как [0:?].<BR>
   * d) Если указано ключевое слово <B>UNIQUE</B>, то каждый элемент в списке этого типа данных должен
   * отличаться (то есть не являться эквивалентным экземпляром) от любого другого элемента того же
   * списка.
   *
   * <SMALL><B><I>Пример — В данном примере определен список массивов. Список может содержать от нуля до
   * десяти массивов. Каждый массив из десяти целых чисел должен отличаться от других массивов в
   * данном списке.</I><BR>
   * complex_list : LIST[0:10] OF UNIQUE ARRAY[1:10] OF INTEGER;</B></SMALL>
   */
  template<class T>
  class LIST : public std::vector<T*>, public AGGREGATE {

  public:

    LIST() = default;


    /** Вывод в виде строки как атрибут объектного типа */
    virtual std::string print_attr(void) const {
      std::stringstream s;
      s << "(";
      for (auto i = LIST<T>::cbegin(); i != LIST<T>::cend(); ++i) {
        const STEP* step = *i;
        s << step->print_attr();
        if ((i + 1) != LIST<T>::cend()) {
          s << STEP_SPACER;
        }
      }
      s << ")";
      return s.str();
    }

    /** Получить имя типа данных вложенного типа */
    virtual const std::string get_value_step_name(void) const {
      if (LIST<T>::empty()) {
        std::cout << "INTERNAL_ERROR: " << get_type_name().c_str() << "::LIST::get_value_step_name() without elements" << std::endl;
        exit(static_cast<int>(err_enum_t::ERROR_INTERNAL));
      }
      return (*LIST<T>::cbegin())->get_step_name();
    }

    /** Получить тип данных вложенного типа */
    virtual STEP_OBJTYPE get_value_objtype() const {
      if (LIST<T>::empty()) return STEP_OBJTYPE::NONE;
      return (*LIST<T>::cbegin())->objtype();
    }

  };

  /**
   * \brief Шаблон для типов данных <B>\ref SET</B> (ГОСТ Р ИСО 10303-11, 8.2)
   *
   * <B>8.2.4 Тип данных \ref SET</B><BR>
   * Областью определения типа данных <B>\ref SET</B> являются неупорядоченные совокупности подобных
   * элементов. Тип данных <B>\ref SET</B> является конкретизацией типа данных BAG. Необязательные нижняя и верхняя
   * границы, задаваемые выражениями, имеющими целочисленные значения, определяют минимальное и
   * максимальное число элементов в совокупности, определенной типом данных <B>\ref SET</B>. Определенная типом
   * данных <B>\ref SET</B> совокупность не должна содержать двух или более одинаковых элементов.
   * \verbatim
     Синтаксис:
      303 set_type = SET [ bound_spec ] OF instantiable_type.
      185 bound_spec = ' [ ' bound_1 ' : ' bound_2 ' ] '.
      183 bound_1 = numeric_expression.
      184 bound_2 = numeric_expression.
   \endverbatim
   *
   * Правила и ограничения:<BR>
   * a) Выражение <B>bound_1</B> должно иметь целочисленное значение, большее или равное нулю. Оно
   * задаёт нижнюю границу, определяющую минимальное число элементов, которое может содержаться в
   * экземпляре набора этого типа данных. Выражение <B>bound_1</B> не должно иметь неопределенного (?) значения.<BR>
   * b) Выражение <B>bound_2</B> должно иметь целочисленное значение, большее или равное значению
   * <B>bound_1</B>, либо неопределенное (?) значение. Оно задает верхнюю границу, определяющую
   * максимальное число элементов, которое может содержаться в экземпляре набора этого типа данных. Если
   * значение данного выражения является неопределенным (?), то число элементов в экземпляре набора
   * этого типа данных не ограничено сверху.<BR>
   * c) Если элемент <B>bound_spec</B> опущен, то границы набора определяются как <B>[0:?]</B>.<BR>
   * d) Каждый элемент в экземпляре типа данных <B>\ref SET</B> должен отличаться (то есть не являться
   * эквивалентным экземпляром) от любого другого элемента того же экземпляра набора.
   *
   * <B><I>Пример — В данном примере атрибут </I>a_set_of_points<I> определен как набор объектов </I>point<I>
   * (объекты point относятся к именованному типу данных, который объявлен в другом месте).<BR>
   * </I>a_set_of_points : SET OF point;<I><BR>
   * Атрибут </I>a_set_of_points<I> может содержать ни одного или несколько объектов </I>point<I>. Каждый
   * экземпляр объекта </I>point<I> (в экземпляре набора) должен отличаться от любого другого объекта
   * </I>point<I> в наборе.<BR>
   * Если требуется, чтобы набор содержал не более 15 объектов </I>point<I>, то в спецификации верхняя
   * граница должна быть определена следующим образом:<BR>
   * </I>a_set_of_points : SET [0:15] OF point;<I><BR>
   * Теперь экземпляр атрибута </I>a_set_of_points<I> может содержать не более 15 точек.</I></B>
   *
   */
  template<class T>
  class SET : public std::vector<T*>, public AGGREGATE {

  private:

    /** \brief Нижняя граница, определяющая минимальное число элементов, которое может содержаться в наборе */
    size_t bound_1;
    /** \brief Верхняя граница, определяющая максимальное число элементов, которое может содержаться в наборе */
    size_t bound_2;

  public:

    /* \brief Неопределённое значение для верхней границы */
    static const size_t UNDEFINED = -1;


    SET(size_t Bound_1 = 0, size_t Bound_2 = UNDEFINED) {
      bound_1 = Bound_1;
      bound_2 = Bound_2;
    }

    /** \brief Вывод в виде строки как атрибут объектного типа */
    virtual std::string print_attr(void) const {
      std::stringstream s;
      s << "(";
      for (auto i = SET<T>::cbegin(); i != SET<T>::cend(); ++i) {
        const STEP* step = *i;
        s << step->print_attr();
        if ((i + 1) != SET<T>::cend()) {
          s << STEP_SPACER;
        }
      }
      s << ")";
      return s.str();
    }

    /** \brief Получить имя типа данных вложенного типа */
    virtual const std::string get_value_step_name(void) const {
      //!!!
      if (SET<T>::empty()) return "SET_EMPTY";
      return (*SET<T>::cbegin())->get_step_name();
    }

    /** \brief Получить тип данных вложенного типа */
    virtual STEP_OBJTYPE get_value_objtype() const {
      if (SET<T>::empty()) return STEP_OBJTYPE::NONE;
      return (*SET<T>::cbegin())->objtype();
    }

    /** \brief Получить количество элементов множества */
    size_t SIZEOF() const {
      return SET<T>::size();
    }

    /** \brief Добавить к множеству элемент */
    void ADD(T* x) {
      SET<T>::push_back(x);
    }

  };
}

#include "express_simple.h"

#include "express_list.h"

#include "iso10303_43a.h"
#include "iso10303_41.h"
#include "iso10303_43.h"
#include "iso10303_46.h"
#include "iso10303_42.h"
#include "iso10303_44.h"
#include "iso10303_511.h"
#include "iso10303_514.h"
#include "iso10303_517.h"

#endif /* _EXPRESS_H */

/**
 * \file
 * \brief Файл с описанием выбираемого типа данных SELECT языка EXPRESS 
 * (ГОСТ Р ИСО 10303-11-2009, 8.4.2)
 */

namespace express {

  /**
   * \brief Выбираемый тип EXPRESS (ГОСТ Р ИСО 10303-11-2009, 8.4.2)
   *
   * \ref express::SELECT "8.4.2 Выбираемый тип данных"
   *
   * Выбираемый  тип  данных  определяет  тип данных, позволяющий выбирать среди
   * нескольких   именованных  типов  данных.  Выбираемый  тип  данных  является
   * обобщением   именованных   типов   данных   в  своей  области  определения.
   * Определённый  тип  данных,  для  которого  выбираемый  тип  данных является
   * базисным  представлением,  может  добавлять  ограничения  на  свою  область
   * определения  посредством объявления локальных правил. Выбираемый тип данных
   * может  быть или не быть наращиваемым.
   *
   * Областью  определения  выбираемого  типа данных,  который  не  является  ни
   * наращиваемым,   ни расширяющим, является объединение  областей  определения
   * именованных  типов данных из его списка выбора.
   *
   * Областью   определения   наращиваемого  выбираемого  типа  данных  является
   * объединение   областей   определения   именованных   типов  данных  из  его
   * собственного  списка  выбора  плюс  объединение  областей  определения всех
   * расширяющих  выбираемых  типов  данных.  Наращиваемый выбираемый тип данных
   * задаётся посредством ключевого слова <B>EXTENSIBLE</B>.
   *
   * Областью   определения   расширяющего   выбираемого  типа  данных  являются
   * именованные  типы данных из его собственного списка выбора плюс именованные
   * типы   данных,   указанные   непосредственно  (а  не  через  расширение)  в
   * наращиваемом  выбираемом  типе  данных,  на котором он основан. Расширяющий
   * выбираемый тип данных задаётся посредством ключевого слова <B>BASED_ON</B>.
   *
   * Выбираемый  тип  данных  может  быть  как  наращиваемым,  так и расширяющим
   * выбираемым  типом  данных.  Наращиваемый  выбираемый  тип данных может быть
   * задан  без списка выбора, а также основан на другом наращиваемом выбираемом
   * типе  данных  без  задавания  списка  выбора,  расширяющего данный базисный
   * список выбора.
   *
   * Только  наращиваемый  выбираемый тип данных может быть ограничен наличием в
   * своей области определения только экземпляров объектов посредством ключевого
   * слова  <B>GENERIC_ENTITY</B>.  В  данном  случае все элементы списка выбора должны
   * быть  элементами  обобщённого  объекта,  где  элемент  обобщённого  объекта
   * определяется  как относящийся к объектному типу данных либо к списку выбора
   * из  элементов  обобщённого объекта. Все расширения данного выбираемого типа
   * данных  должны  быть выбираемыми типами данных обобщённого объекта и должны
   * задаваться посредством ключевого слова <B>GENERIC_ENTITY</B>.
   \verbatim
     Синтаксис:
      302 select_type = [ EXTENSIBLE [ GENERIC_ENTITY ] ] SELECT
                        [ select_list | select_extension ] .
      301 select_list = '(' named_types { ',' named_types } ')' .
      300 select_extension = BASED_ON type_ref [ WITH select_list ] .
   \endverbatim
   * Правила и ограничения:
   *
   * a) Все элементы в списке выбора должны относиться к объектному или определённому типу данных.
   *
   * b) Только выбираемый тип данных должен использоваться в качестве базисного типа для
   * определённого типа данных.
   *
   * c) Выбираемый тип данных может быть расширен, только если в его определении указано ключевое
   * слово EXTENSIBLE.
   *
   * d) Элемент type_ref в select_extension должен быть ссылкой на наращиваемый выбираемый тип.
   *
   * e) Для выбираемого типа данных, не являющегося ни наращиваемым, ни расширяющим, должен
   * быть задан в качестве его области определения непустой список выбора.
   *
   * f) Для выбираемого типа данных, не являющегося наращиваемым, но являющегося расширяющим,
   * должен быть задан непустой список выбора, расширяющий область определения наращиваемого
   * выбираемого типа данных, на котором он основан.
   *
   * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
   * Значение выбираемого типа данных может быть значением нескольких именованных
   * типов данных, указанных в списке выбора для данного выбираемого типа данных.</SMALL>
   *
   * <B><I>Примеры
   *
   * 1 Если a и b являются подтипами с, и они связаны выражением</I> ANDOR<I>, и существует тип
   * данных, определённый как</I> SELECT (а, b)<I>, то может оказаться, что значением выбираемого типа
   * данных будут одновременно а и b.
   *
   * 2 Должен быть сделан выбор среди нескольких типов предметов в заданном контексте:</I>
   <PRE>
       TYPE attachment_method = EXTENSIBLE SELECT(nail, screw);
       END_TYPE;
       TYPE permanent_attachment = SELECT BASED_ON attachment_method WITH (glue, weld);
       END_TYPE;
       ENTITY nail;
         length : REAL;
         head_area : REAL;
       END_ENTITY;
       ENTITY screw;
         length : REAL;
         pitch : REAL;
       END_ENTITY;
       ENTITY glue;
         composition : material_composition;
         solvent : material_composition;
       END_ENTITY;
       ENTITY weld;
         composition : material_composition;
       END_ENTITY;
       ENTITY wall_mounting;
         mounting : product;
         on : wall;
         using : attachment_method;
       END_ENTITY;
   </PRE>
   * <I>Элемент</I> wall_mounting <I>описывает соединение изделия</I> product <I>со стеной</I> wall <I>с использованием
   * способа соединения</I> attachment_method<I>. Исходный способ соединения описывает способы разборного
   * соединения. Эти способы затем расширяются, добавляя способы неразборного соединения</I>
   * permanent_attachment<I>. При определении значения элемента</I> wall_mounting <I>будет использоваться
   * значение атрибута</I> using<I>, то есть</I> nail, screw, glue<I> или</I> weld.</B>
   */
  class SELECT : public GENERIC {

  private:

    /** \brief Переменная, которая может принимать значения указателей на типы и объекты из выбираемого типа */
    const GENERIC* value;

  protected:

    /** \brief Установить значение указателя на выбираемый тип */
    void set_value(const GENERIC* t) {
      value = t;
      if (value == nullptr) {
        determinated = false;
      }
    }

    /** \brief Получить указатель на выбранный тип */
    const GENERIC* get_value() const {
      return value;
    }

  public:

    /** \brief Конструктор неопределённого объекта */
    SELECT() : GENERIC(false), value(nullptr) {
    }

    /** \brief Конструктор */
    SELECT(const GENERIC& t) : value(&t) {
    }

    /** \brief Деструктор */
    virtual ~SELECT() = default;

    /**
     * \brief Получить тип данных
     * \return тип данных в виде элемента перечисления OBJTYPE
     */
    virtual constexpr OBJTYPE objtype() const override {
      return OBJTYPE::OBJ_SELECT;
    }

    /** \brief Получить имя типа данных выбранного типа */
    virtual const std::string get_value_type_name() const override {
      if (value == nullptr) return "VALUE_NULLPTR";
      return value->get_type_name();
    }

    /** \brief Получить тип данных выбранного типа */
    virtual OBJTYPE get_value_objtype() const override {
      if (value == nullptr) return OBJTYPE::OBJ_GENERIC;
      return value->objtype();
    }

    /**
     * \brief Вывод в виде строки как атрибут объектного типа (ГОСТ Р ИСО 10303-21, 10.1.8)
     * 
     * <B>10.1.8 Выбираемый тип данных</B><BR>
     * Выбираемый тип данных в языке EXPRESS определяет список типов данных, называемый
     * “список-выбора” (“select-list”), значениями которого являются правильные экземпляры данных
     * выбираемого типа. Экземпляр данных выбираемого типа должен быть значением по меньшей мере
     * одного из типов данных в списке-выбора:
     * <OL><LI>если значение является экземпляром типа данных объекта в списке-выбора, оно должно быть
     * отображено в структуру обмена как имя экземпляра объекта (см. 6.3.4);</LI>
     * <LI>если значение является экземпляром простого определяемого типа в списке-выбора, оно
     * должно быть отображено в структуру обмена как TYPED PARAMETER (см. таблицу 3), в котором
     * KEYWORD должно обозначать простой определяемый тип, как определено ниже, a PARAMETER
     * должен быть кодированием значения простого определяемого типа, как определено в 10.1.6;</LI>
     * <LI>если значение является экземпляром перечисляемого типа данных в списке-выбора, оно
     * должно быть отображено в структуру обмена как TYPED PARAMETER (см. таблицу 3), в котором
     * KEYWORD должно обозначать перечисляемый тип данных, как определено ниже, a PARAMETER
     * должен быть кодированием значения перечисляемого типа данных, как определено в 10.1.7;</LI>
     * <LI>если значение является экземпляром (вложенного) выбираемого типа данных, оно должно
     * быть отображено в структуру обмена в виде экземпляра выбираемого типа, как указано в данном
     * разделе.</LI></OL>
     */
    virtual std::string print_value() const override {
      if (value == this) {
        throw exception{__MYFUNCNAME__, "value == this"};
      }
      if (value == nullptr) {
        throw exception{__MYFUNCNAME__, "value == nullptr"};
      }
      return value->print_value();
    }
  };

  /** \brief Объявление конструктора выбираемого типа данных */
  #define STEP_TYPE_SELECT_CONSTRUCTOR_DEF(B, T) B(const T* t)

  /** \brief Определение конструктора выбираемого типа данных */
  #define STEP_TYPE_SELECT_CONSTRUCTOR(B, T) B::B(const T* t) : SELECT(t) { }
}

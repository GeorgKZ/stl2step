/**
 * \file
 * \brief Файл с описанием перечисляемого типа данных ENUMERATION языка EXPRESS
 * (ГОСТ Р ИСО 10303-11-2009, 8.4.1)
 */

namespace express {

  /**
   * \brief Перечисляемый тип данных EXPRESS (ГОСТ Р ИСО 10303-11-2009, 8.4.1)
   *
   * \ref express::ENUMERATION "8.4.1 Перечисляемый тип данных"
   *
   * Областью определения перечисляемого типа данных является множество имен.
   * Размер данного множества имен определяется в зависимости от типа
   * перечисляемого типа данных. Различают следующие перечисляемые типы данных:
   * * наращиваемый перечисляемый тип данных;
   * * перечисляемый тип данных, расширяющий наращиваемый перечисляемый тип
   * данных, другими словами, основанный на наращиваемом перечисляемом типе
   * данных;
   * * перечисляемый тип данных, который не является ни наращиваемым, ни
   * расширяющим.
   *
   * Имена, объявляемые посредством ключевого слова \ref express::ENUMERATION "ENUMERATION", могут быть
   * только допустимыми значениями перечисляемого типа данных. Каждое имя из
   * данной области определения называется элементом перечисления и обозначается
   * <B>enumeration_id</B>.
   *
   * Областью определения перечисляемого типа данных, который не является ни
   * наращиваемым, ни расширяющим, задаваемой при его объявлении, является
   * упорядоченное множество элементов перечисления, указанных при его
   * объявлении.
   *
   * Областью определения наращиваемого перечисляемого типа данных является
   * множество элементов перечисления, указанных при его объявлении, плюс
   * объединение множеств элементов перечислений, заключающее в себе области
   * определения всех расширяющих перечисляемых типов данных. Наращиваемый
   * перечисляемый тип данных является обобщением основанных на нём
   * перечисляемых типов данных. Наращиваемый перечисляемый тип данных задаётся
   * посредством ключевого слова <B>EXTENSIBLE</B>.
   *
   * Областью определения расширяющего перечисляемого типа данных является множество элементов
   * перечисления, указанных при его объявлении, плюс элементы перечисления, указанные непосредственно
   * (а не через расширение) в наращиваемом перечисляемом типе данных, на котором он основан.
   * Расширяющий перечисляемый тип данных задаётся посредством ключевого слова <B>BASED_ON</B>.
   * 
   * Перечисляемый тип данных может быть как наращиваемым, так и расширяющим перечисляемым
   * типом данных. Наращиваемый перечисляемый тип данных может быть задан без элементов перечисления,
   * а также основан на другом наращиваемом перечисляемом типе данных без задания элементов
   * перечисления, расширяющих данное базисное перечисление. Взаимосвязь «основан на» является транзитивной, то
   * есть расширяющее перечисление остаётся основанным на наращиваемом перечислении самого верхнего
   * уровня даже при наличии нескольких уровней взаимосвязей «основан на»; расширяющее перечисление
   * включает все элементы, как промежуточных наращиваемых перечислений, так и наращиваемого
   * перечисления самого верхнего уровня.
   *
   * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;я
   *
   * 1 Наращиваемое перечисление, расширенное два или более раза в одном контексте, может иметь
   * большую область определения, чем его расширения, и в этом случае оно действительно является обобщением.
   *
   * 2 В первой редакции настоящего стандарта упорядочение элементов перечисления определяло
   * упорядочение значений. В настоящем стандарте не определено никакого упорядочения, за исключением указанного
   * ниже в правиле по перечислению d). Это сделано, чтобы обеспечить существование наращиваемых
   * перечисляемых типов данных, в которых упорядочение расширений не может быть определено.</SMALL>
   \verbatim
     Синтаксис:
      213 enumeration_type = [ EXTENSIBLE ] ENUMERATION [ ( OF
                             enumeration_items ) | enumeration_extension ] .
      211 enumeration_items = '(' enumeration_id { ',' enumeration_id } ')' .
      209 enumeration_extension = BASED_ON type_ref [ WITH enumeration_items ] .
   \endverbatim
   * Правила и ограничения:
   *
   * a) Перечисляемый тип данных должен использоваться только в качестве базисного типа данных для
   * определённого типа данных.
   *
   * b) Перечисляемый тип данных может быть расширен, только если в его определении указано
   * ключевое слово <B>EXTENSIBLE</B>.
   *
   * c) Элемент <B>type_ref</B> в <B>enumeration_extension</B> должен быть ссылкой на наращиваемый
   * перечисляемый тип.
   * 
   * d) В целях сравнения, упорядочение значений перечисляемого типа данных, который не является
   * ни наращиваемым, ни расширяющим, может быть определено их относительной позицией в списке
   * <B>enumeration_id</B>; первый встретившийся элемент должен быть меньше второго, второй --- меньше
   * третьего и т.д.
   *
   * e) Не существует упорядочения значений для наращиваемого перечисления или расширяющего
   * перечисления.
   *
   * f) Для перечисления, не являющегося ни наращиваемым, ни расширяющим, в качестве его области
   * определения должны быть заданы элементы перечисления.
   *
   * g) Для перечисления, не являющегося наращиваемым, но являющегося расширяющим, должны
   * быть заданы элементы перечисления, расширяющие область определения наращиваемого перечисления,
   * на котором оно основано.
   *
   * h) Два разных перечисляемых типа данных могут содержать одинаковый элемент <B>enumeration_id</B>
   * в своих множествах имен. Если перечисляемые типы данных не являются расширениями одного
   * наращиваемого типа данных, то их элементы <B>enumeration_id</B> относятся к разным понятиям, даже если их
   * локальные имена совпадают. В данном случае, любая ссылка на элемент <B>enumeration_id</B> (например, в
   * выражении) должна быть уточнена посредством идентификатора типа данных, чтобы обеспечить однозначность
   * ссылок. Ссылка при этом выглядит следующим образом: <B>type_id.enumeration_id</B>.
   *
   * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
   * Элемент <B>type_id</B>, используемый для уточнения элемента <B>enumeration_id</B>, всегда
   * определяется как перечисляемый тип данных.</SMALL>
   *
   * <B><I>Пример --- В данном примере перечисляемые типы данных использованы для демонстрации
   * того, как могут двигаться различные виды транспортных средств.</I></B>
   <PRE>
       TYPE car_can_move = ENUMERATION OF
            (left, right, backward, forward);
       END_TYPE;
       TYPE plane_can_move = ENUMERATION OF
            (left, right, backward, forward, up, down);
       END_TYPE;
   </PRE>
   * <B><I>Элемент перечисления</I> left <I>имеет два независимых определения, задаваемых каждым типом
   * данных, компонентом которого он является. Не существует никакой связи между этими двумя
   * определениями идентификатора</I> left. <I>Сама по себе ссылка на</I> left <I>или</I> right <I>является неоднозначной.
   * Для того, чтобы разрешить данную неоднозначность, ссылка на любое из этих значений должна
   * быть уточнена посредством указания имени типа данных, например,</I> car_can_move.left.</B>
   *
   * i) Наращиваемое перечисление и его расширения задают область определения, состоящую из
   * элементов <B>enumeration_id</B>. В пределах данной области определения все появления одного и того же
   * элемента <B>enumeration_id</B> обозначают одно и то же значение, даже если элемент <B>enumeration_id</B>
   * определён в нескольких перечисляемых типах данных, относящихся к данной области определения.
   *
   * <B><I>Пример --- В данном примере один элемент перечисления с именем</I> red <I>используется в двух
   * расширениях</I> stop_light <I>и</I> canadian_flag <I>области определения перечисляемого типа данных</I> colour.</B>
   <PRE>
       TYPE colour = EXTENSIBLE ENUMERATION; END_TYPE;
       TYPE stop_light = ENUMERATION BASED_ON colour WITH (red, yellow, green); END_TYPE;
       TYPE canadian_flag = ENUMERATION BASED_ON colour WITH (red, white); END_TYPE;
   </PRE>
   * j) Объявление типа, в котором объявляется перечисляемый тип данных, не должно содержать
   * правила для области определения (WHERE).
   *
   * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
   * Приведенные выше правила обеспечивают то, что определённый тип данных дает
   * имя перечисляемому типу данных, и определённый тип данных не является конкретизацией перечисляемого
   * типа данных.</SMALL>
   *
   * <B><I>Пример --- В данном примере показано, как наращиваемое перечисление может быть
   * использовано для моделирования контекстно-зависимого понятия «одобрение». Элемент</I> general_approval
   * <I>представляет наиболее общее понятие одобрения, однозначно определяя только два значения.
   * Объявление</I> general_approval <I>как наращиваемого перечисления позволяет ему принимать
   * контекстно-зависимые значения в схемах, в которых объявляются его расширения. При использовании
   * данного элемента для представления области определения атрибута, допустимые значения
   * атрибута становятся контекстно зависимыми.</I></B>
   <PRE>
       SCHEMA s1;
       TYPE general_approval = EXTENSIBLE ENUMERATION OF (approved, rejected);
       END_TYPE;
       END_SCHEMA;
       SCHEMA s2;
       USE FROM s1 (general_approval);
       TYPE domain2_approval = EXTENSIBLE ENUMERATION BASED_ON general_approval WITH (pending);
       END_TYPE;
       END_SCHEMA;
       SCHEMA s3;
       USE FROM s1 (general_approval);
       TYPE domain3_approval = EXTENSIBLE ENUMERATION BASED_ON general_approval WITH (cancelled);
       END_TYPE;
       END_SCHEMA;
       SCHEMA s4;
       USE FROM s2 (domain2_approval);
       REFERENCE FROM s3 (domain3_approval);
       TYPE specific_approval = ENUMERATION BASED_ON domain2_approval WITH (rework);
       END_TYPE;
       END_SCHEMA;
       SCHEMA s5;
       USE FROM s1 (general_approval);
       TYPE redundant_approval = ENUMERATION BASED_ON general_approval WITH (approved);
       END_TYPE;
       END_SCHEMA;
   </PRE>
   * <B><I>В контексте схемы</I> s1: general_approval <I>имеет область определения</I> (approved, rejected).
   *
   * <I>В контексте схемы</I> s2: general_approval <I>имеет область определения</I> (approved, rejected, pending);
   * domain2_approval <I>имеет область определения</I> (approved, rejected, pending).
   *
   * <I>В контексте схемы</I> s3: general_approval <I>имеет область определения</I> (approved, rejected, cancelled);
   * domain3_approval <I>имеет область определения</I> (approved, rejected, cancelled).
   *
   * <I>В контексте схемы</I> s4: general_approval <I>имеет область определения</I> (approved, rejected, pending,
   * cancelled, rework); domain2_approval <I>имеет область определения</I> (approved, rejected, pending, rework);
   * domain3_approval <I>имеет область определения</I> (approved, rejected, cancelled); specific_approval <I>имеет
   * область определения</I> (approved, rejected, pending, rework).
   *
   * <I>В контексте схемы</I> s5: general_approval <I>имеет область определения</I> (approved, rejected);
   * redundant_approval <I>имеет область определения</I> (approved, rejected).</B>
   */
  class ENUMERATION : public GENERIC {

  private:

    /**
     * Получить массив строкового представления типа перечисления
     *
     * \return массив строкового представления типа перечисления.
     */
    virtual const char* const* get_value_str() const = 0;
    
    /**
     * Получить количество строк массива строкового представления типа перечисления
     *
     * \return количество строк массива строкового представления типа перечисления.
     */
    virtual size_t get_value_str_size() const = 0;
    
    /**
     * Получить численное представление типа перечисления
     * 
     * \return численное представление типа перечисления.
     */
    virtual size_t get_enum_value() const = 0;

  public:

    /** \brief Конструктор, включающий возможность создания неопределённого типа */
    ENUMERATION(bool Determinated = true) : GENERIC(Determinated)  {
    }

    /** \brief Деструктор по умолчанию */
    virtual ~ENUMERATION() = default;

    /**
     * \brief Получить тип данных
     * \return тип данных в виде элемента перечисления OBJTYPE
     */
    virtual constexpr OBJTYPE objtype() const override {
      return OBJTYPE::OBJ_ENUMERATION;
    }

    /**
     * \brief Вывести в виде строки как значение
     *
     * <B>ISO 10303-21, 6.3.5 Перечисляемые значения</B>
     * Перечисляемое значение должно быть закодировано как последовательность <I>прописных букв</I>
     * или <I>цифр</I>, начинающаяся с <I>прописной буквы</I>, ограниченная <I>точками</I>. Смысл
     * заданного перечисляемого значения задаётся EXPRESS-схемой и соответствующими определениями
     * из объявлений перечисляемого типа.
     * 
     * <B>ISO 10303-21, 10.1.7 Тип данных enumeration (перечисление)</B>
     * Значения данных в языке EXPRESS типа ENUMERATION должны быть отображены в структуру
     * обмена как перечисляемый тип данных. В 6.3.5 описано содержание перечисляемого типа
     * данных.<BR>
     * Если документ, определяющий конкретную схему, экземплярами которой является предмет
     * этой секции данных, задающий набор сокращенных наименований для перечисляемых значений в
     * этой схеме, тогда фактическим значением конкретного экземпляра перечисления (ENUMERATION)
     * может быть сокращенное наименование, соответствующее одному из перечисляемых значений в
     * данной EXPRESS-схеме. В противном случае фактическим значением должно быть одно из
     * перечисляемых значений в EXPRESS-схеме. В любом случае строчные буквы должны быть преобразованы
     * в прописные буквы, а значение ограничено отделенными точками “.”, как это определено в выводе
     * ENUMERATION в таблице 2:
     <PRE>
         ENUMERATION = “.” UPPER { UPPER | DIGIT } “.” .
     </PRE>
     */
    virtual std::string print_value() const override {
      return print_enum_value(get_value_str(), get_value_str_size(), get_enum_value());
    }
  };
}
/**
 * \file
 * \brief Файл с описанием языка Express в ГОСТ Р ИСО 10303-11-2009
 *
 * <HR>
 * \anchor p11
 * <CENTER>
 * \image html GOST.png
 * \image latex GOST.png width=1.5cm
 * </CENTER>
 * <CENTER><B>ГОСТ Р ИСО 10303-11-2009</B></CENTER>
 * <HR>
 * <H2>
 * <BR>Системы автоматизации производства и их интеграция ---<BR>
 * ПРЕДСТАВЛЕНИЕ ДАННЫХ ОБ ИЗДЕЛИИ И ОБМЕН ЭТИМИ ДАННЫМИ ---<BR>
 * Часть 11:<BR>
 * Методы описания:<BR>
 * Справочное руководство по языку EXPRESS
 * </H2>
 *
 * \section p11_s1 1 Область применения
 *
 * В настоящем стандарте определён язык, посредством которого могут быть описаны данные об
 * изделии. Данный язык называется EXPRESS.
 *
 * В настоящем стандарте также определено графическое представление для подмножества
 * конструкций языка EXPRESS. Данное графическое представление называется EXPRESS-G.
 *
 * EXPRESS является языком определения данных, как это установлено в ИСО 10303-1. Данный язык
 * состоит из элементов, которые позволяют однозначно определять данные и устанавливать ограничения на
 * эти данные.
 *
 * Область применения настоящего стандарта распространяется на:
 * - типы данных;
 * - ограничения на экземпляры типов данных.
 *
 * Область применения настоящего стандарта не распространяется на:
 * - определение форматов баз данных;
 * - определение форматов файлов;
 * - определение форматов передачи;
 * - управление процессами;
 * - обработку информации;
 * - обработку исключительных ситуаций.
 *
 * Язык EXPRESS не является языком программирования.
 *
 * \section p11_s2 2 Нормативные ссылки
 *
 * В настоящем стандарте использованы ссылки на следующие международные стандарты:
 *
 * ИСО 10303-1:1994 Системы автоматизации производства и их интеграция. Представление данных
 * об изделии и обмен этими данными. Часть 1. Общие представления и основополагающие принципы
 * (ISO 10303-1:1994, Industrial automation systems and integration --- Product data representation and exchange ---
 * Part 1: Overview and fundamental principles)
 *
 * ИСО/МЭК 8824-1:2002 Информационные технологии. Взаимосвязь открытых систем. Абстрактная
 * синтаксическая нотация версии один (АСН.1). Часть 1. Спецификация основной нотации (ISO/IEC 8824-1:2002,
 * Information technology --- Abstract Syntax Notation One (ASN.1): Specification of basic notation)
 * ИСО/МЭК 10646:2003 Информационные технологии. Универсальный многооктетный набор
 * закодированных символов (UCS) [ISO/IEC 10646:2003, Information technology --- Universal Multiple-Octet Coded Character
 * Set (UCS)]
 *
 * \section p11_s3 3 Термины и определения
 *
 * \subsection p11_s3_1 3.1 Термины, определённые в ИСО 10303-1
 *
 * В настоящем стандарте применены следующие термины:
 * - <B>требование соответствия</B> (conformance requirement);
 * - <B>контекст</B> (context);
 * - <B>данные</B> (data);
 * - <B>язык определения данных</B> (data specification language);
 * - <B>информация</B> (information);
 * - <B>информационная модель</B> (information model);
 * - <B>форма ЗСРП</B> (PICS proforma)
 *
 * \subsection p11_s3_2 3.2 Термины, определённые в ИСО/МЭК 10646-1
 *
 *  В настоящем стандарте применён следующий термин:
 *
 * <B>графический символ</B> (graphic character).
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Данное определение охватывает только те символы из ИСО/МЭК 10646, которые
 * имеют установленное визуальное представление; тем самым исключаются любые пустые или
 * заштрихованные позиции в таблице символов.</SMALL>
 *
 * \subsection p11_s3_3 3.3 Другие определения
 *
 * В настоящем стандарте также применены следующие термины с соответствующими определениями:
 *
 * \anchor p11_s3_3_1
 * 3.3.1 <B>сложный объектный тип данных</B> (complex entity data type):
 * Представление объекта. Сложный объектный тип данных устанавливает область значений, определяемую общими атрибутами и
 * ограничениями допустимой комбинации объектных типов данных в конкретном графе подтипов/супертипов.
 *
 * \anchor p11_s3_3_2
 * 3.3.2 <B>экземпляр сложного объекта (сложного объектного типа данных)</B> [complex entity (data
 * type) instance]: Именованное значение сложного объектного типа данных. Имя экземпляра сложного
 * объекта используется для ссылок на данный экземпляр.
 *
 * \anchor p11_s3_3_3
 * 3.3.3 <B>значение сложного объекта (сложного объектного типа данных)</B> [complex entity (data
 * type) value]:
 * Элемент данных, представляющий элемент информации в рамках класса, определяемого
 * сложным объектным типом данных. Данный элемент принадлежит области определения, установленной данным
 * сложным объектным типом данных.
 *
 * \anchor p11_s3_3_4
 * 3.3.4 <B>константа</B> (constant): Именованный элемент данных из заданной области определения,
 * значение которого не может быть изменено.
 *
 * \anchor p11_s3_3_5
 * 3.3.5 <B>тип данных</B> (data type): Область значений.
 *
 * \anchor p11_s3_3_6
 * 3.3.6 <B>объект</B> (entity): Класс информации, определённый общими свойствами.
 *
 * \anchor p11_s3_3_7
 * 3.3.7 <B>объектный тип данных</B> (entity data type): Представление объекта. Объектный тип данных
 * устанавливает область значений, определяемую общими атрибутами и ограничениями.
 *
 * \anchor p11_s3_3_8
 * 3.3.8 <B>экземпляр объекта (объектного типа данных)</B> [entity (data type) instance]: Именованное
 * значение объектного типа данных. Имя экземпляра объекта используется для ссылок на данный
 * экземпляр.
 *
 * \anchor p11_s3_3_9
 * 3.3.9 <B>значение (отдельного) объекта (объектного типа данных)</B> [(single) entity (data type) value]:
 * Элемент данных, представляющий элемент информации в рамках класса, определённого объектным
 * типом данных. Данный элемент принадлежит области определения, установленной данным объектным типом
 * данных.
 *
 * \anchor p11_s3_3_10
 * 3.3.10 <B>экземпляр</B> (instance): Именованное значение.
 *
 * \anchor p11_s3_3_11
 * 3.3.11 <B>многолепестковый сложный объект (многолепестковый сложный объектный тип данных)</B>
 * [multi-leaf complex entity (data type)]: Сложный объектный тип данных, состоящий из нескольких
 * объектных типов данных, которые не имеют последующих подтипов в рамках данного сложного объектного типа
 * данных.
 *
 * \anchor p11_s3_3_12
 * 3.3.12 <B>экземпляр многолепесткового сложного объекта (многолепесткового сложного
 * объектного типа данных)</B> [multi-leaf complex entity (data type) instance]: Именованное значение
 * многолепесткового сложного объектного типа данных. Имя экземпляра многолепесткового сложного объекта
 * используется для ссылок на данный экземпляр.
 *
 * \anchor p11_s3_3_13
 * 3.3.13 <B>значение многолепесткового сложного объекта (многолепесткового сложного
 * объектного типа данных)</B> [multi-leaf complex entity (data type) value]: Элемент данных, представляющий элемент
 * информации в рамках класса, определяемого многолепестковым сложным объектным типом данных.
 * Данный элемент принадлежит области определения, установленной данным многолепестковым сложным
 * объектным типом данных.
 *
 * \anchor p11_s3_3_14
 * 3.3.14 <B>частичный сложный объектный тип данных</B> (partial complex entity data type):
 * Потенциальное представление объекта. Частичный сложный объектный тип данных является группировкой объектных
 * типов данных в графе подтипов/супертипов, которая может частично или полностью формировать сложный
 * объектный тип данных.
 *
 * \anchor p11_s3_3_15
 * 3.3.15 <B>значение частичного сложного объекта</B> (partial complex entity value): Значение частичного
 * сложного объектного типа данных. Данное значение само по себе не имеет смысла и должно объединяться
 * с другими значениями частичного сложного объекта и с именем для формирования экземпляра сложного
 * объекта.
 *
 * \anchor p11_s3_3_16
 * 3.3.16 <B>совокупность</B> (population): Множество экземпляров объектного типа данных.
 *
 * \anchor p11_s3_3_17
 * 3.3.17 <B>основная схема</B> (primary schema): Схема в группе взаимосвязанных схем, образующая
 * ориентированный граф, возможно, циклический. Основная схема является предметом интереса. В графе могут
 * существовать одна или несколько основных схем, тогда как остальные схемы графа служат только для
 * поддержки основных схем. Основная схема играет особую роль в преобразовании из короткой формы
 * схемы в длинную форму (см. приложение G).
 *
 * \anchor p11_s3_3_18
 * 3.3.18 <B>корневая схема</B> (root schema): Схема в группе взаимосвязанных схем, образующая
 * ориентированный граф, возможно, циклический. Корневая схема не является целью в какой-либо спецификации
 * интерфейса, но все другие схемы должны быть достижимы из корневой схемы. Корневая схема может
 * рассматриваться в качестве представителя графа. Корневая схема играет особую роль в преобразовании
 * из короткой формы схемы в длинную форму (см. приложение G).
 *
 * \anchor p11_s3_3_19
 * 3.3.19 <B>экземпляр простого объекта</B> (простого объектного типа данных) [simple entity (data type)
 * instance]: Именованный элемент данных, представляющий блок информации в рамках класса,
 * определённого объектом. Данный элемент принадлежит области определения, установленной отдельным объектным
 * типом данных.
 *
 * \anchor p11_s3_3_20
 * 3.3.20 <B>граф подтипов/супертипов</B> (subtype/supertype graph): Объявленная совокупность объектных
 * типов данных. Объектные типы данных, объявленные в графе подтипов/супертипов, связаны через
 * формулировку подтипов. Граф подтипов/супертипов определяет один или несколько сложных объектных типов
 * данных.
 *
 * \anchor p11_s3_3_21
 * 3.3.21 <B>лексема</B> (token): Не подлежащий декомпозиции лексический элемент языка.
 *
 * \anchor p11_s3_3_22
 * 3.3.22 <B>значение</B> (value): Элемент данных.
 *
 * \section p11_s4 4 Требования соответствия
 *
 * \subsection p11_s4_1 4.1 Формальные спецификации, написанные на языке EXPRESS
 *
 * \subsubsection p11_s4_1_1 4.1.1 Лексический язык
 *
 * Формальная спецификация, написанная на языке EXPRESS, должна быть согласована с заданным
 * уровнем, как определено ниже. Формальная спецификация считается согласованной с заданным уровнем,
 * если все проверки, установленные для данного уровня и всех более низких уровней, верифицированы для
 * данной спецификации.
 *
 * Уровни проверки
 *
 * Уровень 1 --- проверка ссылок. Данный уровень состоит из проверки формальной спецификации для
 * подтверждения её синтаксической и ссылочной корректности. Формальная спецификация синтаксически
 * корректна, если она соответствует синтаксису, сформированному посредством расширения основного
 * синтаксического правила (<B>syntax</B>), установленного в приложении А. Формальная спецификация корректна в
 * отношении ссылок, если все ссылки на элементы языка EXPRESS соответствуют области применения и
 * правилам видимости, установленным в разделах \ref p11_s10 "10" и \ref p11_s11 "11".
 *
 * Уровень 2 --- проверка типов. Данный уровень включает в себя проверку формальной спецификации
 * для подтверждения её соответствия следующим требованиям:
 * - выражения должны удовлетворять правилам, установленным в разделе \ref p11_s12 "12";
 * - присваивания должны удовлетворять правилам, установленным в \ref p11_s13_3 "13.3";
 * - объявления инверсных атрибутов должны удовлетворять правилам, установленным в \ref p11_s9_2_1_3 "9.2.1.3";
 * - повторные объявления атрибутов должны удовлетворять правилам, установленным в \ref p11_s9_2_3_4 "9.2.3.4".
 *
 * Уровень 3 --- проверка значений. Данный уровень состоит из проверки формальной спецификации
 * для подтверждения её соответствия утверждениям типа «А должно быть больше В», установленным
 * в разделах \ref p11_s7 "7" --- \ref p11_s16 "16". Данная проверка ограничена случаями, когда значения А и В могут быть выражены
 * литералами и/или константами.
 *
 * Уровень 4 --- полная проверка. Данный уровень включает в себя проверку формальной спецификации
 * для подтверждения её соответствия формулировкам требований, установленных в настоящем стандарте.
 *
 * <B><I>Пример --- В настоящем стандарте установлено, что функции должны содержать оператор
 * возврата для каждой из возможных ветвей, по которым может пойти процесс при вызове данной функции,
 * что и должно быть проверено.</I></B>
 *
 * \subsubsection p11_s4_1_2 4.1.2 Графическая форма
 *
 * Формальная спецификация, представленная в формате EXPRESS-G, должна быть согласована с
 * заданным уровнем, как определено ниже. Формальная спецификация считается согласованной с заданным
 * уровнем, если все проверки, установленные для данного уровня и всех более низких уровней,
 * верифицированы для данной спецификации.
 *
 * Уровни проверки
 *
 * Уровень 1 --- проверка символов и области видимости. Данный уровень включает в себя проверку
 * формальной спецификации для подтверждения её соответствия спецификации уровня объекта или
 * спецификации уровня схемы, которые определены в приложении D, разделы D.5 и D.6, соответственно. Данная
 * проверка предусматривает проверку использования в формальной спецификации символов в соответствии
 * с приложением D, разделы D.2, D.3 и D.4. Формальная спецификация также должна быть проверена на
 * соответствие страничных ссылок и повторно объявленных атрибутов требованиям приложения D,
 * подразделы D.4.1 и D.5.5, соответственно.
 *
 * Уровень 2 --- полная проверка. Данный уровень включает в себя проверку формальной спецификации
 * на предмет установления в ней мест, не соответствующих требованиям уровня полного объекта или уровня
 * полной схемы, установленным в приложении D, а также требованиям, установленным в разделах \ref p11_s7 "7" --- \ref p11_s16 "16".
 *
 * \subsection p11_s4_2 4.2 Реализации языка EXPRESS
 *
 * \subsubsection p11_s4_2_1 4.2.1 Синтаксический анализатор языка EXPRESS
 *
 * Реализация синтаксического анализатора языка EXPRESS должна обеспечивать синтаксический
 * разбор любой формальной спецификации, написанной на языке EXPRESS, в соответствии с ограничениями,
 * установленными в приложении Е и связанными с данной реализацией. Синтаксический анализатор языка
 * EXPRESS должен считаться соответствующим конкретному уровню проверки (см. \ref p11_s4_1_1 "4.1.1"), если он может
 * выполнять все требуемые для данного (и любого нижележащего) уровня проверки формальной
 * спецификации, написанной на языке EXPRESS.
 *
 * Разработчик синтаксического анализатора языка EXPRESS должен точно определить все
 * ограничения, которые реализация накладывает на число и длину идентификаторов, диапазон обрабатываемых
 * чисел и максимальную точность представления действительных чисел. Данные ограничения должны быть
 * документально оформлены в виде, установленном в приложении Е, необходимом для проведения
 * аттестационного тестирования.
 *
 * \subsubsection p11_s4_2_2 4.2.2 Графический редактор
 *
 * Реализация редактора для графической нотации EXPRESS-G должна обеспечивать создание и
 *  отображение формальных спецификаций, представленных в формате EXPRESS-G, в соответствии с
 * ограничениями, установленными в приложении Е и связанными с данной реализацией. Редактор
 * EXPRESS-G должен считаться соответствующим конкретному уровню проверки, если он может
 * создавать и отображать формальные спецификации в формате EXPRESS-G, соответствующие заданному (и любому
 * нижележащему) уровню проверки.
 *
 * Разработчик редактора EXPRESS-G должен точно определить любые ограничения, которые
 * реализация накладывает на число и длину идентификаторов, число доступных символов на странице модели и
 * максимальное число страниц. Данные ограничения должны быть документально оформлены в виде,
 * установленном в приложении Е, необходимом для проведения аттестационного тестирования.
 *
 * \section p11_s5 5 Фундаментальные принципы
 *
 * Для использования настоящего стандарта необходимо знание представленных ниже понятий.
 *
 * Схема, написанная на языке EXPRESS, описывает совокупность условий, устанавливающих область
 * её определения. Экземпляры объектов могут быть оценены на их принадлежность к данной области
 * определения. Если экземпляры объектов соответствуют всем условиям, то они объявляются принадлежащими
 * данной области определения. Если экземпляры объектов не соответствуют каким-либо из условий, то они
 * нарушают данные условия и поэтому не принадлежат данной области определения. В случае если
 * экземпляры объектов не содержат значения для необязательных атрибутов, а при некоторых условиях данные
 * необязательные атрибуты используются, то может оказаться невозможным определить, соответствуют ли
 * экземпляры объектов всем условиям. В таком случае считается, что экземпляры объектов принадлежат
 * данной области определения.
 *
 * Многим элементам языка EXPRESS присвоены имена. Имя позволяет другим элементам языка
 * ссылаться на связанное с этим именем представление. Использование имени в определении других
 * элементов языка создаёт ссылку на базовое представление. Хотя в соответствии с синтаксисом языка для
 * обозначения имени используется идентификатор, базовое представление должно быть изучено для понимания
 * его структуры.
 *
 * Спецификация объектного типа данных в языке EXPRESS описывает область определения.
 * Предполагается, что отдельные элементы области определения различаются некоторыми связанными с ними
 * уникальными идентификаторами. Язык EXPRESS не определяет содержание или представление этих
 * идентификаторов.
 *
 * Объявление постоянного экземпляра объекта определяет идентифицируемый элемент области
 * определения, представленный объектным типом данных. Такие экземпляры объектов не должны изменяться
 * или уничтожаться операциями, выполняемыми в данной области определения.
 *
 * Процедурные описания ограничений в языке EXPRESS могут объявлять или делать ссылки на
 * дополнительные экземпляры объекта как на локальные переменные, которые принимаются как временные
 * идентифицируемые элементы области определения. Данные процедурные описания могут изменять
 * дополнительные экземпляры объекта, но не могут изменять постоянные элементы области определения. Такие
 * временные элементы области определения доступны только в процессе выполнения процедуры, в которой
 * они объявлены, и прекращают своё существование после завершения её выполнения.
 *
 * Язык EXPRESS не описывает среду реализации. В частности язык EXPRESS не определяет:
 * - как реализуются ссылки на имена;
 * - какие другие схемы становятся известными;
 * - как и когда проверяются ограничения;
 * - что должна делать реализация, если ограничение нарушено;
 * - имеют или не имеют право на существование в реализации экземпляры объектов, которые не
 * соответствуют EXPRESS-схеме;
 * - когда и как в реализации создаются, изменяются и удаляются экземпляры объектов.
 *
 * \section p11_s6 6 Синтаксис спецификации языка
 *
 * В настоящем разделе определена нотация, используемая для представления синтаксиса языка
 * EXPRESS.
 *
 * Полный синтаксис языка EXPRESS приведен в приложении А. Части этих синтаксических правил
 * воспроизведены в различных разделах настоящего стандарта для иллюстрации синтаксиса конкретных
 * операторов. Эти части не всегда полны. Поэтому иногда необходимо руководствоваться приложением A в
 * отношении недостающих в данном примере правил. Части синтаксических правил в тексте настоящего
 * стандарта представлены в рамках. Каждое синтаксическое правило внутри рамки обозначено слева
 * уникальным номером для использования его в перекрёстных ссылках в других синтаксических правилах.
 *
 * \subsection p11_s6_1 6.1 Синтаксис спецификации
 *
 * Синтаксис языка EXPRESS определён как производная от синтаксической нотации Вирта (СНВ) [3].
 *
 * Соглашения об обозначениях и самоопределённая СНВ приведены ниже.
 <PRE>
     syntax           = { production } .
     production       = identifier '=' expression '.' .
     expression       = term { '|' term } .
     term             = factor { factor } .
     factor           = identifier | literal | group | option | repetition .
     identifier       = character { character } .
     literal          = ''' character { character } ''' .
     group            = '(' expression ')' .
     option           = '[' expression ']' .
     repetition       = '{' expression '}' .
 </PRE>
 * Знак равенства '<B>=</B>' обозначает порождающее правило. Элемент слева от знака равенства
 * определяется как комбинация элементов, расположенных справа от него. Любые пробелы между
 * элементами правой части не имеют значения, если только они не входят в состав литерала. В конце
 * порождающего правила ставится точка '<B>.</B>'.
 *
 * Использование идентификатора в любом элементе обозначает нетерминальный символ, который
 * присутствует в левой части другого порождающего правила. Идентификатор состоит из букв, цифр и символа
 * подчёркивания. Ключевые слова языка представлены порождающими правилами, идентификаторы
 * которых состоят только из прописных букв.
 *
 * Литерал используется для обозначения терминального символа, который не может быть раскрыт
 * в дальнейшем. Литерал представляется последовательностью не зависящих от регистра символов,
 * заключённой в апострофы. Под символом в данном случае понимается любой символ, определённый
 * в ИСО/МЭК 10646 в позициях 21 --- 7Е группы 00, плоскости 00, строки 00. Чтобы апостроф был включён
 * в литерал, он должен быть записан дважды.
 *
 * Семантика разных видов скобок определена следующим образом:
 * - фигурные скобки '<B>{ }</B>' обозначают ни одного или несколько повторений;
 * - квадратные скобки '<B>[ ]</B>' обозначают необязательные параметры;
 * - круглые скобки '<B>( )</B>' обозначают, что группа порождающих правил, заключённая в круглые скобки,
 * должна использоваться как единое порождающее правило;
 * - вертикальная линия '<B>|</B>' обозначает, что в выражении должен использоваться только один из
 * элементов, разделённых вертикальными линиями
 *
 * <B><I>Примеры
 *
 * 1 Синтаксис строкового типа данных определяется следующим образом:</I></B>
 \verbatim
   Синтаксис:
    311 string_type = STRING [ width_spec ] .
    341 width_spec = '(' width ')' [ FIXED ] .
    340 width = numeric_expression .
 \endverbatim
 * <B><I>Полное определение синтаксиса, представленное в приложении А, содержит определения лексем</I>
 * STRING, numeric_expression <I>и</I> FIXED.
 *
 * <I>2 В соответствии с синтаксисом, приведённом в примере 1, возможны следующие варианты:</I>
 *
 * string;
 *
 * string ( 22 );
 *
 * string ( 19 ) fixed.
 *
 * <I>Правило для</I> numeric_expression <I>является достаточно сложным и позволяет представить
 * много других вариантов.</I></B>
 *
 * \subsection p11_s6_2 6.2 Обозначение специальных символов
 *
 * Следующая нотация используется для представления полных наборов символов и некоторых
 * специальных символов, которые трудно визуально отобразить:
 *
 * <B>\\a</B> --- представляет символы в позициях 21-7Е строки 00, плоскости 00, группы 00 из ИСО/МЭК 10646;
 *
 * <B>\\n</B> --- представляет символ новой строки (newline), зависящий от системы (см. \ref p11_s7_1_5_2 "7.1.5.2");
 *
 * <B>\\q</B> --- представляет символ одиночной кавычки (апострофа) (') и входит в \а;
 *
 * <B>\\s</B> --- представляет символ пробела;
 *
 * <B>\\x9</B>, <B>\\xA</B> и <B>\\xD</B> --- представляют символы, расположенные соответственно в позициях 9, 10 и 13
 * строки 00, плоскости 00, группы 00 из ИСО/МЭК 10646.
 *
 * \section p11_s7 7 Основные элементы языка
 *
 * В данном разделе определены основные элементы, из которых формируется EXPRESS-схема: набор
 * символов, комментарии, знаки, зарезервированные слова, идентификаторы и литералы.
 *
 * Из основных элементов языка формируется текстовая структура, обычно разделяемая на физические
 * строки. Физическая строка представляет собой последовательность из любого числа (включая ни одного)
 * символов, заканчивающуюся символом новой строки (см. \ref p11_s7_1_5_2 "7.1.5.2").
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Схема более удобна для восприятия, если операторы разбиты на строки, а для
 * выделения разных конструкций использованы пробелы.</SMALL>
 *
 * <B><I>Пример --- Следующие форматы записи эквивалентны:</I>
 <PRE>
     entity point;x,у,z:real;end_entity;

     ENTITY point;
       x,
       y,
       z : REAL;
     END_ENTITY;
 </PRE>
 * </B>
 *
 * \subsection p11_s7_1 7.1 Набор символов
 *
 * В схемах, представленных на языке EXPRESS, должны использоваться только символы из набора,
 * включающего символы, расположенные в позициях 09, 0A, 0D, графические символы, лежащие в
 * диапазоне от 20 до 7Е из ИСО/МЭК 10646, а также специальный символ <B>\\n</B>, обозначающий новую строку. Данный
 * набор символов называется набором символов языка EXPRESS. На символы данного набора можно
 * ссылаться по позиции, на которой расположен данный символ; номера этих позиций определены в
 * шестнадцатеричной системе. Символы из данного набора, которые могут быть воспроизведены при печати
 * (позиции 21–7Е из ИСО/МЭК 10646), комбинируются для формирования лексем языка EXPRESS. Лексемами
 * EXPRESS являются ключевые слова, идентификаторы, знаки или литералы. Более подробно классификация
 * набора символов языка EXPRESS рассмотрена ниже.
 *
 * Таким образом, данный набор символов определён как абстрактный набор символов; он не зависит от
 * его представления в конкретной реализации.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;я 
 *
 * 1 В ИСО/МЭК 6429 [5] установлена семантика символов, расположенных в позициях 09, 0A, 0D из
 * ИСО/МЭК 10646. Для настоящего стандарта семантика, установленная в ИСО/МЭК 6429, не требуется, но она и не
 * противоречит ему.
 *
 * 2 В данном разделе приводятся только ссылки на символы, используемые для определения EXPRESS-схемы,
 * но не определяется область значений символов, допустимых для строкового типа данных.</SMALL>
 *
 * \subsubsection p11_s7_1_1 7.1.1 Цифры
 *
 * В языке EXPRESS используются арабские цифры 0 --- 9 (позиции 30 --- 39 из набора символов языка EXPRESS).
 \verbatim
   Синтаксис:
    124 digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' .
 \endverbatim
 *
 * \subsubsection p11_s7_1_2 7.1.2 Буквы
 *
 * В языке EXPRESS используются буквы верхнего и нижнего регистров английского алфавита (позиции
 * 41---5А и 61--- 7А из набора символов языка EXPRESS). Регистр букв имеет значение только в явных
 * строковых литералах.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * В структурах языка EXPRESS могут использоваться буквы верхнего, нижнего или обоих
 * регистров (см. пример в \ref p11_s7 "7").</SMALL>
 \verbatim
   Синтаксис:
    128 letter = 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' |
                 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' |
                 'w' | 'x' | 'y' | 'z' .
 \endverbatim
 *
 * \subsubsection p11_s7_1_3 7.1.3. Специальные символы
 *
 * Специальные символы (воспроизводимые при печати символы, не являющиеся буквами и цифрами)
 * используются главным образом для пунктуации и в качестве операторов. Специальные символы
 * соответствуют позициям 21 --- 2F, ЗА --- 3F, 40, 5В --- 5Е, 60 и 7В --- 7Е набора символов языка EXPRESS.
 \verbatim
   Синтаксис:
    137 special = not_paren_star_quote_special | '(' | ')' | '*' | ''' .
    132 not_paren_star_quote_special = '!' | '"' | '#' | '$' | '%' | '&' | '+' | ',' |
                                       '-' | '.' | '/' | ':' | ';' | '<' | '=' | '>' |
                                       '?' | '@' | '[' | '\' | ']' | '^' | '_' | '`' |
                                       '{' | '|' | '}' | '~' .
 \endverbatim
 *
 * \subsubsection p11_s7_1_4 7.1.4 Подчеркивание
 *
 * Символ подчеркивания ( '<B>_</B>', позиция 5F из набора символов языка EXPRESS) может использоваться
 * в идентификаторах и ключевых словах, но не в качестве первого символа.
 *
 * \subsubsection p11_s7_1_5 7.1.5 Пустое пространство
 *
 * Пустое пространство в тексте образуется посредством символов, определённых в
 * \ref p11_s7_1_5_1 "7.1.5.1" --- \ref p11_s7_1_5_3 "7.1.5.3" и \ref p11_s7_1_6 "7.1.6".
 * Пустое пространство должно использоваться для разделения лексем в EXPRESS-схемах.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Свободное и последовательное использование пустого пространства может
 * улучшить структуру и удобочитаемость схемы.</SMALL>
 *
 * \subsubsection p11_s7_1_5_1 7.1.5.1 Символ пробела
 *
 * Один или несколько пробелов (позиция 20 из набора символов EXPRESS) могут располагаться
 * между двумя лексемами. Обозначение <B>\\s</B> может использоваться для представления символа пробела в
 * синтаксических структурах языка.
 *
 * \subsubsection p11_s7_1_5_2 7.1.5.2 Новая строка
 *
 * Символом новой строки заканчивается каждая строка в формальной спецификации на языке EXPRESS.
 * Обычно символ новой строки трактуется как пробел, но он является значимым символом, если им
 * заканчивается комментарий или анормально заканчивается строковый литерал. В синтаксических структурах
 * языка символ новой строки представляется обозначением <B>\\n</B>.
 *
 * Представление символа новой строки зависит от конкретной реализации.
 *
 * \subsubsection p11_s7_1_5_3 7.1.5.3 Другие символы
 *
 * Символы из позиций 09, 0A и 0D должны трактоваться как пустое пространство, кроме случаев, когда
 * они встречаются в строковом литерале. Для представления этих символов в синтаксических структурах
 * языка должно использоваться обозначение <B>\\хn</B>, где <B>n</B> является одним из символов <B>9</B>, <B>А</B> или <B>D</B>.
 *
 * \subsubsection p11_s7_1_6 7.1.6 Комментарии
 *
 * Комментарий используется для документирования и должен интерпретироваться синтаксическим
 * анализатором языка EXPRESS как пустое пространство. Существуют две формы комментария – встроенный
 * комментарий и заключительный комментарий. Обе формы комментария могут быть ассоциированы с
 * идентифицированной конструкцией посредством метки комментария.
 *
 * \subsubsection p11_s7_1_6_1 7.1.6.1 Встроенный комментарий
 *
 * Пара символов <B>(*</B> обозначает начало встроенного комментария, а пара символов <B>*)</B> обозначает его
 * окончание. Встроенный комментарий может располагаться между любыми двумя лексемами.
 *
 * Любой символ из набора символов языка EXPRESS может присутствовать между началом и концом
 * встроенного комментария, включая символ новой строки, поэтому встроенные комментарии могут
 * содержать несколько физических строк.
 \verbatim
   Cинтаксис:
    145 embedded_remark = '(*' [ remark_tag ] { (not_paren_star { not_paren_star } ) |
                          lparen_then_not_lparen_star | ( '*' { '*' } ) |
                          not_rparen_star_then_rparen | embedded_remark } '*)' .
    147 remark_tag = '"' remark_ref { '.' remark_ref } '"' .
    148 remark_ref = attribute_ref | constant_ref | entity_ref | enumeration_ref |
                     function_ref | parameter_ref | procedure_ref | rule_label_ref |
                     rule_ref | schema_ref | subtype_constraint_ref | type_label_ref |
                     type_ref | variable_ref .
    131 not_paren_star = letter | digit | not_paren_star_special .
    128 letter = 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' |
                 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' |
                 'w' | 'x' | 'y' | 'z' .
    124 digit =  '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' .
    133 not_paren_star_special = not_paren_star_quote_special | ' ' ' ' .
    132 not_paren_star_quote_special = '!' | '"' | '#' | '$' | '%' | '&' | '+' | ',' |
                                       '-' | '.' | '/' | ':' | ';' | '<' | '=' | '>' |
                                       '?' | '@' | '[' | '\' | ']' | '^' | '_' | '`' |
                                       '{' | '|' | '}' | '~' .
    129 lparen_then_not_lparen_star = '(' { '(' } not_lparen_star { not_lparen_star }.
    130 not_lparen_star = not_paren_star | ')' .
    138 not_rparen_star_then_rparen = not_rparen_star { not_rparen_star } ')' { ')' }.
    135 not_rparen_star = not_paren_star | '(' .
 \endverbatim
 * Встроенные комментарии могут быть вложенными.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * При формировании вложенных комментариев необходимо обратить внимание на
 * наличие согласованных пар символов, обозначающих начало и конец комментария.</SMALL>
 *
 * <B><I>Пример --- Следующая строка демонстрирует пример встроенного комментария:</I>
 *
 * (* Символы '(*' начинают комментарий, а символы '*)' его заканчивают *)</B>
 *
 * \subsubsection p11_s7_1_6_2 7.1.6.2 Заключительный комментарий
 *
 * Заключительный комментарий записывается в конце физической строки. Два последовательных
 * дефиса «<B>––</B>» начинают заключительный комментарий, а первый встреченный символ «новая строка»
 * заканчивает его.
 \verbatim
   Cинтаксис:
    149 tail_remark = '--' [ remark_tag ] { \а | \s | \х9 | \хА | \xD } \n .
    147 remark_tag = '"' remark_ref { '.' remark_ref } '\"' .
    148 remark_ref = attribute_ref | constant_ref | entity_ref | enumeration_ref |
                     function_ref | parameter_ref | procedure_ref | rule_label_ref |
                     rule_ref | schema_ref | subtype_constraint_ref | type_label_ref |
                     type_ref | variable_ref .
 \endverbatim
 * <B><I>Пример</I> --- это комментарий, заканчивающийся символом «новая строка».</B>
 *
 * \subsubsection p11_s7_1_6_3 7.1.6.3 Метка комментария
 *
 * Комментарий может быть соотнесён с именованным элементом, то есть с элементом, обозначенным
 * идентификатором, посредством размещения метки комментария в качестве первой последовательности
 * символов. Метка комментария должна следовать непосредственно за парой символов, идентифицирующих
 * комментарий. Сама метка комментария состоит из ссылки на идентификатор, определённый
 * последовательностью символов, заключённой в кавычки.
 \verbatim
   Cинтаксис:
    147 remark_tag = '"' remark_ref { '.' remark_ref } '"' .
    148 remark_ref = attribute_ref | constant_ref | entity_ref | enumeration_ref |
                     function_ref | parameter_ref | procedure_ref | rule_label_ref |
                     rule_ref | schema_ref | subtype_constraint_ref | type_label_ref |
                     type_ref | variable_ref .
 \endverbatim
 * Правила и ограничения:
 *
 * a) Элемент <B>remark_ref</B> должен соответствовать правилам видимости, определённым в \ref p11_s10_2 "10.2".
 *
 * b) В составной ссылке комментария правила видимости, определённые в \ref p11_s10_2 "10.2", должны
 * использоваться следующим образом: ссылка слева от символа '<B>.</B>' должна идентифицировать область видимости, в
 * которой определена ссылка, расположенная справа от символа '<B>.</B>'.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Составная ссылка комментария представляет собой ссылку комментария, в которой
 * используется нотация с символом '<B>.</B>' (см. синтаксическое правило 147).</SMALL>
 *
 * c) Если ссылка комментария не найдена в соответствии с указанными выше правилами видимости, то
 * комментарий не должен ассоциироваться с каким-либо элементом.
 *
 * d) Помеченный комментарий, содержащий другие помеченные комментарии (посредством
 * вложенности), должен ассоциироваться целиком (включая вложенные комментарии) с указанным
 * элементом.
 *
 * e) Если вложенный комментарий и комментарий, в который он вложен, оба ссылаются на один и тот
 * же идентифицированный элемент, то вложенный комментарий должен быть связан с этим элементом
 * дважды: один раз в составе комментария, в который он вложен, и второй раз непосредственно.
 *
 * <B><I>Примеры
 *
 * 1 Помеченный комментарий в данном примере ссылается на атрибут</I> attr <I>в области
 * видимости объекта</I> ent:
 *
 <PRE>
     ENTITY ent;
       attr: INTEGER;
     END_ENTITY;
     (* "ent.attr" Атрибут attr ... *)
 </PRE>
 * <I>2 За ссылкой на схему</I> my_second_schema <I>в помеченном комментарии может следовать любой
 * идентификатор, объявленный непосредственно в области видимости данной схемы, например,
 * имя функции</I> a_complicated_function<I>, как в данном примере:</I>
 <PRE>
     SCHEMA my_second_schema;
     ...
     FUNCTION a_complicated_function;
     ...
     END_FUNCTION;
     (* "my_second_schema.a_complicated_function" Данная сложная функция ... *)
     ...
     END_SCHEMA;
 </PRE> </B>
 *
 * \subsection p11_s7_2 7.2 Зарезервированные слова
 *
 * Зарезервированными словами языка EXPRESS являются ключевые слова и имена встроенных
 * констант, функций и процедур. Зарезервированные слова не должны использоваться в качестве
 * идентификаторов. Зарезервированные слова языка EXPRESS описаны ниже.
 *
 * \subsubsection p11_s7_2_1 7.2.1 Ключевые слова
 *
 * Ключевые слова языка EXPRESS представлены в \ref p11_table1 "таблице 1".
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Ключевые слова представляются литералом, состоящим из заглавных букв. Это
 * сделано для облегчения чтения синтаксических конструкций.</SMALL>
 *
 * \anchor p11_table1
 * Т&nbsp;а&nbsp;б&nbsp;л&nbsp;и&nbsp;ц&nbsp;а 1 --- Ключевые слова языка EXPRESS
 \verbatim
   ABSTRACT            AGGREGATE           ALIAS               ARRAY
   AS                  BAG                 BASED_ON            BEGIN
   BINARY              BOOLEAN             BY                  CASE
   CONSTANT            DERIVE              ELSE                END
   END_ALIAS           END_CASE            END_CONSTANT        END_ENTITY
   END_FUNCTION        END_IF              END_LOCAL           END_PROCEDURE
   END_REPEAT          END_RULE            END_SCHEMA          END_SUBTYPE_CONSTRAINT
   END_TYPE            ENTITY              ENUMERATION         ESCAPE
   EXTENSIBLE          FIXED               FOR                 FROM
   FUNCTION            GENERIC             GENERIC_ENTITY      IF
   INTEGER             INVERSE             LIST                LOCAL
   LOGICAL             NUMBER              OF                  ONEOF
   OPTIONAL            OTHERWISE           PROCEDURE           QUERY
   REAL                RENAMED             REFERENCE           REPEAT
   RETURN              RULE                SCHEMA              SELECT
   SET                 SKIP                STRING              SUBTYPE
   SUBTYPE_CONSTRAINT  SUPERTYPE           THEN                TO
   TOTAL_OVER          TYPE                UNIQUE              UNTIL
   USE                 VAR                 WHERE               WHILE
 \endverbatim
 *
 * \subsubsection p11_s7_2_2 7.2.2 Зарезервированные слова, обозначающие операторы
 *
 * Операторы, обозначенные зарезервированными словами, представлены в \ref p11_table2 "таблице 2". Определения
 * этих операторов даны в разделе \ref p11_s12 "12".
 *
 * \anchor p11_table2
 * Т&nbsp;а&nbsp;б&nbsp;л&nbsp;и&nbsp;ц&nbsp;а 2 --- Зарезервированные слова, обозначающие операторы языка EXPRESS
 \verbatim
   AND                 ANDOR               DIV                 IN
   LIKE                MOD                 NOT                 OR
   XOR
 \endverbatim
 *
 * \subsubsection p11_s7_2_3 7.2.3 Встроенные константы
 *
 * Имена встроенных констант представлены в \ref p11_table2 "таблице 3". Определения этих констант даны в
 * разделе \ref p11_s14 "14".
 *
 * \anchor p11_table3
 * Т&nbsp;а&nbsp;б&nbsp;л&nbsp;и&nbsp;ц&nbsp;а 3 --- Зарезервированные слова, обозначающие константы языка EXPRESS
 \verbatim
   ?                   SELF                CONST_E             PI
   FALSE               TRUE                UNKNOWN
 \endverbatim
 *
 * \subsubsection p11_s7_2_4 7.2.4 Встроенные функции
 *
 * Имена встроенных функций представлены в \ref p11_table4 "таблице 4". Определения этих функций даны в
 * разделе \ref p11_s15 "15".
 *
 * \anchor p11_table4
 * Т&nbsp;а&nbsp;б&nbsp;л&nbsp;и&nbsp;ц&nbsp;а 4 --- Зарезервированные слова, являющиеся именами функций языка EXPRESS
 \verbatim
   ABS                 ACOS                ASIN                ATAN
   BLENGTH             COS                 EXISTS              EXP
   FORMAT              HIBOUND             HIINDEX             LENGTH
   LOBOUND             LOG                 LOG2                LOG10
   LOINDEX             NVL                 ODD                 ROLESOF
   SIN                 SIZEOF              SQRT                TAN
   TYPEOF              USEDIN              VALUE               VALUE_IN
   VALUE_UNIQUE
 \endverbatim
 *
 * \subsubsection p11_s7_2_5 7.2.5 Встроенные процедуры
 *
 * Имена встроенных процедур представлены в \ref p11_table5 "таблице 5". Определения этих процедур даны в
 * разделе \ref p11_s16 "16".
 *
 * \anchor p11_table5
 * Т&nbsp;а&nbsp;б&nbsp;л&nbsp;и&nbsp;ц&nbsp;а 5 --- Зарезервированные слова, являющиеся именами процедур языка EXPRESS
 \verbatim
   INSERT              REMOVE
 \endverbatim
 *
 * \subsection p11_s7_3 7.3 Знаки
 *
 * Знаки являются специальными символами или группами специальных символов, имеющими
 * особое значение в языке EXPRESS. Знаки используются в языке EXPRESS как разделители и операторы.
 * Разделители используются для начала, разделения или завершения смежных лексических или
 * синтаксических элементов. Интерпретация этих элементов была бы невозможна без разделителей. Операторы
 * обозначают выполнение действий над операндами, связанными с оператором. Описание операторов дано
 * в разделе \ref p11_s12 "12". Знаки языка EXPRESS представлены в \ref p11_table6 "таблице 6".
 *
 * \anchor p11_table6
 * Т&nbsp;а&nbsp;б&nbsp;л&nbsp;и&nbsp;ц&nbsp;а 6 --- Знаки языка EXPRESS
 \verbatim
   .                   ,                   ;                   :
   *                   +                   -                   =
   %                   '                   \                   /
   <                   >                   [                   ]
   {                   }                   |                   е
   (                   )                   <=                  <>
   >=                  <*                  :=                  ||
   **                  --                  (*                  *)
   :=:                 :<>:
 \endverbatim
 *
 * \subsection p11_s7_4 7.4 Идентификаторы
 *
 * Идентификаторы являются именами, присвоенными объявленным в схеме элементам (см. \ref p11_s9_3 "9.3"),
 * включая саму схему. Идентификатор не должен совпадать с зарезервированными словами языка EXPRESS.
 \verbatim
   Cинтаксис:
    143 simple_id = letter { letter | digit | '_' } .
    128 letter = 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' |
                 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' |
                 'w' | 'x' | 'y' | 'z' .
    124 digit =  '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' .
 \endverbatim
 * Первый символ идентификатора должен быть буквой. Остальные символы (при их наличии) могут
 * являться любой комбинацией букв, цифр и символа подчёркивания.
 *
 * При разработке синтаксического анализатора языка EXPRESS необходимо задать максимальное
 * число символов в идентификаторе, распознаваемых данным анализатором, используя в качестве
 * руководства приложение Е.
 *
 * \subsection p11_s7_5 7.5 Литералы
 *
 * Литерал является самоопределяемой константой. Тип литерала зависит от композиции символов,
 * формирующих лексему. Литералы могут быть следующих типов: двоичный, целочисленный, действительный,
 * строковый и логический.
 \verbatim
   Cинтаксис:
     251 literal = binary_literal | integer_literal | real_literal |
                   string_literal | logical_literal .
 \endverbatim
 * 
 * \subsubsection p11_s7_5_1 7.5.1 Двоичный литерал
 *
 * Двоичный литерал представляет значение двоичного типа данных и состоит из символа «%», за
 * которым следует один или более битов (0 или 1).
 \verbatim
   Синтаксис:
    139 binary_literal = '%' bit { bit } .
    123 bit = '0' | '1' .
 \endverbatim
 * При разработке синтаксического анализатора языка EXPRESS необходимо задать максимальное
 * число битов в двоичном литерале, распознаваемое данным анализатором, используя в качестве
 * руководства приложение Е.
 *
 * <B><I>Пример --- Правильная запись двоичного литерала:</I>
 *
 * %0101001100</B>
 *
 * \subsubsection p11_s7_5_2 7.5.2 Целочисленный литерал
 *
 * Целочисленный литерал представляет значение целого типа данных и состоит из одной или более
 * цифр.
 \verbatim
   Синтаксис:
    141 integer_literal = digits .
    125 digits = digit { digit } .
    124 digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' .
 \endverbatim
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Знак целочисленного литерала не моделируется в синтаксисе, так как в языке
 * EXPRESS в синтаксисе выражений используется концепция унарных операторов.</SMALL>
 *
 * При разработке синтаксического анализатора языка EXPRESS необходимо задать максимальное
 * целое значение для целочисленного литерала, распознаваемое данным анализатором, используя в качестве
 * руководства приложение Е.
 *
 * <B><I>Пример --- Правильная запись целочисленных литералов:</I>
 <PRE>
     4016
     38
 </PRE> </B>
 *
 * \subsubsection p11_s7_5_3 7.5.3 Действительный литерал
 *
 * Действительный литерал представляет значение действительного типа данных и состоит из мантиссы
 * и необязательного показателя степени; мантисса должна содержать десятичную точку.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Знак действительного литерала не моделируется в синтаксисе, так как в языке EXPRESS
 * в синтаксисе выражений используется концепция унарных операторов.</SMALL>
 \verbatim
   Синтаксис:
    142 real_literal = integer_literal |
                       ( digits '.' [ digits ] [ 'e' [ sign ] digits ] ) .
    125 digits = digit { digit } .
    124 digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' .
    304 sign = '+' | '-' .
 \endverbatim
 * При разработке синтаксического анализатора языка EXPRESS необходимо задать максимальную
 * точность и максимальный показатель степени действительного литерала, распознаваемые данным
 * анализатором, используя в качестве руководства приложение Е.
 *
 * <B><I>Примеры
 *
 * 1 Правильная запись действительных литералов:</I>
 <PRE>
     1.Е6              <I>Символ</I> «Е» <I>может быть введён на верхнем или на нижнем регистре.</I>
     3.5е-5
     359.62
 </PRE>
 * <I>2 Неправильная запись действительных литералов:</I>
 <PRE>
     .001              <I>По крайней мере одна цифра должна предшествовать десятичной точке.</I>
     1e10              <I>Десятичная точка должна быть частью литерала.</I>
     1. е10            <I>Пробел не является частью действительного литерала.</I>
 </PRE> </B>
 *
 * \subsubsection p11_s7_5_4 7.5.4 Строковый литерал
 *
 * Строковый литерал представляет значение строкового типа данных. Существуют две формы
 * строкового литерала: простой строковый литерал и кодированный строковый литерал. Простой строковый литерал
 * состоит из последовательности символов из набора символов языка EXPRESS (см. \ref p11_s7_1 "7.1"), заключённой в
 * апострофы ('). Апостроф в составе простого строкового литерала представляется двумя
 * последовательными апострофами. Кодированный строковый литерал состоит из четырёхоктетного кодированного
 * представления каждого символа в последовательности символов ИСО/МЭК 10646-1, заключённой в кавычки (\").
 * Кодирование определяется следующим образом:
 * - первый октет --- группа ИСО/МЭК 10646-1, в которой определён символ;
 * - второй октет --- плоскость ИСО/МЭК 10646-1, в которой определён символ;
 * - третий октет --- строка ИСО/МЭК 10646-1, в которой определён символ;
 * - четвертый октет --- позиция ИСО/МЭК 10646-1, в которой определён символ.
 *
 * Последовательность октетов должна определять один из допустимых символов ИСО/МЭК 10646-1.
 *
 * Строковый литерал никогда не должен выходить за границу физической строки, то есть символ
 * «новая строка» не должен встречаться между апострофами, ограничивающими строковый литерал.
 \verbatim
   Cинтаксис:
    310 string_literal = simple_string_literal | encoded_string_literal .
    144 simple_string_literal = \q { ( \q \q ) | not_quote | \s | \x9 | \xA | \xD } \q .
    134 not_quote = not_paren_star_quote_special | letter | digit | '(' | ')' | '*' .
    132 not_paren_star_quote_special = '!' | '"' | '#' | '$' | '%' | '&' | '+' | ',' |
                                       '-' | '.' | '/' | ':' | ';' | '<' | '=' | '>' |
                                       '?' | '@' | '[' | '\' | ']' | '^' | '_' | '`' |
                                       '{' | '|' | '}' | '~'.
    128 letter = 'a' | 'b' | 'c' | 'd' | 'e '| 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' |
                 'm' | 'n' | 'o' | 'p' | 'q '| 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' |
                 'y' | 'z' .
    124 digit =  '0' | '1' | '2' | '3' | '4 '| '5' | '6' | '7' | '8' | '9' .
    140 encoded_string_literal = '"' encoded_character { encoded_character } '"' .
    126 encoded_character = octet octet octet octet .
    136 octet = hex_digit hex_digit .
    127 hex_digit = digit | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' .
 \endverbatim
 * При разработке синтаксического анализатора языка EXPRESS необходимо задать максимальное число
 * символов простого строкового литерала, распознаваемое данным анализатором, используя в качестве
 * руководства приложение Е.
 *
 * При разработке синтаксического анализатора языка EXPRESS необходимо задать максимальное число
 * октетов (которое должно быть кратно четырём) кодированного строкового литерала, распознаваемое
 * данным анализатором, используя в качестве руководства приложение Е.
 <PRE>
     <B><I>Примеры
     1 Правильная запись простых строковых литералов:</I>
     'Baby needs a new pair of shoes!'
     <I>Значением данного литерала является</I> Baby needs a new pair of shoes!
     'Ed''s Computer Store'
     <I>Значением данного литерала является</I> Ed's Computer Store
     <I>2 Неправильная запись простых строковых литералов:</I>
     'Ed's Computer Store'
     <I>Литерал всегда должен содержать чётное число апострофов.</I>
     'Ed''s Computer
     Store'
     <I>Литерал выходит за границы физической строки.
     3 Правильная запись кодированных строковых литералов:</I>
     "00000041"
     <I>Значением данного литерала является</I> A.
     "000000С5"
     <I>Значением данного литерала является</I> &Aring;.
     "0000795Е00006238"
     <I>Значением данного литерала являются японские иероглифы</I></B>
     \image{inline} html kobe.png width=100
     \image latex kobe.png width=50pt
     <B><I>обозначающие Kobe.
     4 Неправильная запись кодированных строковых литералов:</I>
     "000041"
     <I>Октеты должны быть сгруппированы по четыре.</I>
     "00000041 000000С5"
     <I>Между кавычками разрешены только шестнадцатеричные символы.</I></B>
 </PRE>
 *
 * \subsubsection p11_s7_5_5 7.5.5 Логический литерал
 *
 * Логический литерал представляет значение логического или булевого типа данных и является одной
 * из встроенных констант
 * \ref express::LOGICAL.TRUE "TRUE",
 * \ref express::LOGICAL.FALSE "FALSE" или
 * \ref express::LOGICAL.UNKNOWN "UNKNOWN".
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Константа \ref express::LOGICAL.UNKNOWN "UNKNOWN" несовместима с булевым типом данных.</SMALL>
 \verbatim
   Синтаксис:
    255 logical_literal = FALSE | TRUE | UNKNOWN .
 \endverbatim
 *
 * \section p11_s8 8 Типы данных
 *
 * В данном разделе определены типы данных, используемые в языке EXPRESS. Каждый атрибут,
 * локальная переменная или формальный параметр имеет связанный с ним тип данных.
 * 
 * Типы данных подразделяются на простые, агрегированные, именованные, конструкционные и
 * обобщённые. Кроме того, типы данных подразделяются, в соответствии с их применением, на
 * конкретизирующие, параметрические, базисные и именованные типы данных. Взаимосвязь между
 * этими двумя классификациями определена в \ref p11_s8_6 "8.6".
 * 
 * Операции, которые могут выполняться над значениями этих типов данных, определены в
 * разделе \ref p11_s12 "12".
 *
 * \subsection p11_s8_1 8.1 Простые типы данных
 *
 * \copydetails express::SIMPLE
 *
 * <BR>
 *
 * \copydetails express::NUMBER
 *
 * <BR>
 *
 * \copydetails express::REAL
 *
 * <BR>
 *
 * \copydetails express::INTEGER
 *
 * <BR>
 *
 * \copydetails express::LOGICAL
 *
 * <BR>
 *
 * \copydetails express::BOOLEAN
 *
 * <BR>
 *
 * \copydetails express::STRING
 *
 * <BR>
 *
 * \copydetails express::BINARY
 *
 * <BR>
 *
 * \anchor p11_s8_2
 * \copydetails express::AGGREGATE
 *
 * <BR>
 *
 * \copydetails express::ARRAY_GENERIC
 *
 * <BR>
 *
 * \copydetails express::LIST_GENERIC
 *
 * <BR>
 *
 * \copydetails express::BAG_GENERIC
 *
 * <BR>
 *
 * \copydetails express::SET_GENERIC
 *
 * \subsubsection p11_s8_2_5 8.2.5 Уникальность значений в агрегированных структурах
 *
 * Уникальность среди элементов агрегированных структур основана на сравнении экземпляров (см.
 * \ref p11_s12_2_2 "12.2.2"). К агрегированным структурам может быть предъявлено требование уникальности значений их
 * элементов посредством использования функции \ref express::VALUE_UNIQUE() "VALUE_UNIQUE" (см. \ref express::VALUE_UNIQUE() "15.29").
 *
 * <B><I>Пример --- Определение набора с уникальными значениями:</I></B>
 <PRE>
   TYPE value_unique_set = SET OF a;
   WHERE
     wrl : value_unique(SELF);
   END_TYPE;
 </PRE>
 * Примечание --- Определяемая разработчиком уникальность значений может быть задана
 * посредством двух функций с именами, например, <B>my_equal</B> и <B>my_unique</B>, как показано в следующем
 * псевдокоде:
 <PRE>
   FUNCTION my_equal (v1,v2: GENERIC: gen): LOGICAL;
     (*Функция my_equal возвращает значение TRUE, если vl «равно» v2 *)
   END_FUNCTION;
   FUNCTION my_unique (c: AGGREGATE OF GENERIC): LOGICAL;
     (* Функция my_unique возвращает значение FALSE, если два элемента из с имеют одинаковое «значение»,
        или возвращает значение UNKNOWN, если любой из сравниваемых элементов имеет значение
        UNKNOWN, в противном случае возвращает значение TRUE *)
   LOCAL
     result : LOGICAL;
     unknownp : BOOLEAN := FALSE;
   END_LOCAL;
   IF (SIZEOF(c) = 0) THEN
     RETURN(TRUE); END_IF;
   REPEAT i := LOINDEX(c) TO (HIINDEX(c) - 1);
     REPEAT j := (i+1) TO HIINDEX(c);
       result := my_equal(c[i], c[j]);
       IF (result = TRUE) THEN
         RETURN(FALSE); END_IF;
       IF (result = UNKNOWN) THEN
         unknownp := TRUE; END IF;
     END REPEAT;
   END_REPEAT;
   IF unknownp THEN
     RETURN(UNKNOWN);
   ELSE
     RETURN(TRUE);
   END_IF;
   END_FUNCTION;
 </PRE>
 * Функция <B>my_equal</B> должна иметь следующие свойства, позволяющие формировать классы
 * эквивалентности. Ниже через <B>S</B> обозначен рассматриваемый набор объектов, a <B>my_equal(i, j)</B>,
 * где <B>i</B> и <B>j</B> принадлежат <B>S</B>, возвращает одно из значений <B>[FALSE, UNKNOWN, TRUE]</B>:
 *
 * <B>my_equal(i, i)</B> имеет значение TRUE для всех <B>i</B> из <B>S</B> (так как в <B>S</B>
 * нет неопределённых (<B>?</B>) значений, то не требуется, чтобы значением <B>my_equal(?, ?)</B> было <B>TRUE</B>);
 *
 * <B>my_equal(i, j) = my_equal(j, i)</B> для всех <B>i</B> и <B>j</B> из <B>S</B>;
 *
 * <B>(my_equal(i, j) = TRUE) AND (my_equal(j, k) = TRUE)</B> влечет за собой <B>(my_equal(i, k) = TRUE)</B>
 * для всех <B>i</B>, <B>j</B>, <B>k</B> из <B>S</B>.
 *
 * \subsection p11_s8_3 8.3 Именованные типы данных
 *
 * Именованными типами данных являются типы данных, которые могут быть объявлены в формальной
 * спецификации. Существуют два вида именованных типов данных: объектный и определённый. В данном
 * подразделе определено обращение к именованным типам данных; объявление этих типов данных
 * определено в разделе \ref p11_s9 "9".
 *
 * <BR>
 *
 * \anchor p11_s8_3_1
 * \copydetails express::GENERIC_ENTITY
 *
 * \subsubsection p11_s8_3_2 8.3.2 Определённый тип данных
 *
 * Определённые типы данных устанавливаются объявлениями посредством ключевого слова <B>TYPE</B>
 * (см. \ref p11_s9_1 "9.1"). Определённый тип данных задаётся назначаемым пользователем идентификатором типа.
 * Обращение к определённому типу данных осуществляется посредством данного идентификатора.
 \verbatim
   Синтаксис:
    162 type_ref = type_id .
 \endverbatim
 * Правило: элемент <B>type_ref</B> должен быть именем определённого типа данных, видимым в текущей
 * области видимости (см. раздел 10).
 *
 * <B><I>Пример --- В данном примере определённый тип данных использован для указания единиц
 * измерения, связанных с атрибутом.</I>
 <PRE>
   TYPE volume = REAL;
   END_TYPE;
   ENTITY PART;
   ...
     bulk : volume;
   END_ENTITY;
 </PRE>
 * <I>Атрибут с именем</I> bulk <I>представлен действительным числом, но использование
 * определённого типа данных</I> volume <I>помогает пояснить смысл и контекст данного действительного числа.
 * В данном примере действительное число определяет объём, а не какое-либо другое понятие,
 * значение которого может также определяться действительным числом.</I></B>
 *
 * \subsection p11_s8_4 8.4 Конструкционные типы данных
 *
 * Существуют два вида конструкционных типов данных в языке EXPRESS: перечисляемый
 * (\ref express::ENUMERATION "ENUMERATION") и выбираемый (\ref express::SELECT "SELECT").
 * Эти типы данных имеют сходную синтаксическую структуру
 * и могут использоваться только для задания базисных представлений определённых типов данных (см. \ref p11_s9_1 "9.1").
 *
 * <BR>
 *
 * \anchor p11_s8_4_1
 * \copydetails express::ENUMERATION
 *
 * <BR>
 *
 * \anchor p11_s8_4_2
 * \copydetails express::SELECT
 *
 * \subsection p11_s8_5 8.5 Обобщённые типы данных
 *
 \verbatim
   Синтаксис:
    223 generalized_types = aggregate_type | general_aggregation_types |
                            generic_entity_type | generic_type .
 \endverbatim
 * Обобщённые типы данных используются для определения обобщения некоторых других типов
 * данных и могут быть использованы только в некоторых очень специфичных контекстах. Тип GENERIC является
 * обобщением всех типов данных. Тип данных AGGREGATE является обобщением всех агрегированных
 * типов данных. Общий агрегированный тип данных является обобщением агрегированных типов данных,
 * смягчающим некоторые ограничения, обычно применяемые к агрегированным типам данных. Все эти типы
 * данных определены в \ref p11_s9_5_3 "9.5.3".
 *
 * \subsection p11_s8_6 8.6 Классификация применения типов данных
 *
 * В разделе 8 типы данных языка EXPRESS систематизированы по их сущности: простые типы данных,
 * агрегированные типы данных, конструкционные типы данных, именованные типы данных и обобщённые
 * типы данных. В настоящем подразделе определена классификация типов данных в соответствии с их
 * применением.
 *
 * В языке EXPRESS типы данных применяются шестью разными способами в качестве:
 * - типов данных элементов агрегированных типов данных;
 * - элементов списка выбора при определении или расширении выбираемого типа данных;
 * - базисных типов для типов данных;
 * - типов данных атрибутов объектных типов данных;
 * - типов данных констант;
 * - типов данных формальных параметров и локальных переменных в функциях и процедурах.
 *
 * Кроме того, существует несколько специальных применений объектных типов данных, определённых
 * в разделе \ref p11_s9 "9", которые применяются не к другому классу типов данных, и поэтому в настоящем подразделе
 * не рассматриваются.
 *
 * Типы данных классифицируются в соответствии с их применением следующим образом:
 * - конкретизирующие типы данных применяются для представления элементов агрегированных
 * структур и типов данных констант;
 *
 * - параметрические типы данных применяются для представления явных и производных атрибутов,
 * формальных параметров, результатов функций и локальных переменных в функциях и процедурах;
 * - базисные типы данных применяются для представления определённых типов данных;
 * - именованные типы данных применяются в качестве элементов списка выбора, то есть для
 * возможных представлений значения выбираемого типа данных.
 *
 * Некоторые классы типов данных могут применяться разными способами, в то время как другие могут
 * применяться только в определённых контекстах. Данные различия представлены в \ref p11_table7 "таблице 7".
 *
 * \anchor p11_table7
 * Т&nbsp;а&nbsp;б&nbsp;л&nbsp;и&nbsp;ц&nbsp;а 7 --- Применение типов данных
 *
 * <TABLE border="1" cellpadding="4" cellspacing="0">
 * <tr><td>
 * <TABLE border="1" cellpadding="4" cellspacing="0">
 * <tr><td>Типы данных    </td><td> a             </td><td> b             </td><td> c                   </td><td> d             </td></tr>
 * <tr><td>Простые        </td><td>\f$ \bullet \f$</td><td>\f$ \bullet \f$</td><td>\f$ \bullet \f$      </td><td>               </td></tr>
 * <tr><td>Агрегированные </td><td>\f$ \bullet \f$</td><td>\f$ \bullet \f$</td><td>\f$ \bullet \f$      </td><td>               </td></tr>
 * <tr><td>Именованные    </td><td>\f$ \bullet \f$</td><td>\f$ \bullet \f$</td><td>\f$ \bullet ^{*)} \f$</td><td>\f$ \bullet \f$</td></tr>
 * <tr><td>Конструкционные</td><td>               </td><td>               </td><td>\f$ \bullet \f$      </td><td>               </td></tr>
 * <tr><td>Обобщённые     </td><td>               </td><td>\f$ \bullet \f$</td><td>                     </td><td>               </td></tr>
 * </TABLE></td><td>
 * a) Конкретизирующие типы данных --- представление
 * элементов агрегированных структур и констант.
 *
 * b) Параметрические типы данных --- представление явных и
 * производных атрибутов, формальных параметров, локальных
 * переменных или результата функции.
 *
 * c) Базисные типы данных --- представление определённого
 * типа (см. \ref p11_s9_1 "9.1").
 *
 * d) Именованные типы данных --- возможные представления
 * выбираемого типа данных.
 *
 * ---
 *
 * \f$ ^* \f$ ) Из именованных типов данных только определённый тип
 * может применяться в качестве базисного типа данных.
 * </td></tr></TABLE>
 *
 * Именованные типы данных определены в \ref p11_s8_3 "8.3". Конкретизирующие, параметрические и базисные
 * типы данных определены в \ref p11_s8_6_1 "8.6.1" --- \ref p11_s8_6_3 "8.6.3".
 *
 * \subsubsection p11_s8_6_1 8.6.1 Конкретизирующие типы данных
 *
 * Конкретизирующие типы данных используются для представления констант, элементов
 * агрегированных типов данных и атрибутов неабстрактных объектных типов данных (см. \ref express::STEP_ATTRIBUTE "9.2.1").
 *
 * К конкретизирующим типам данных относятся простые, агрегированные и именованные типы данных.
 \verbatim
   Синтаксис:
    240 instantiable_type = concrete_types | entity_ref .
    193 concrete_types = aggregation_types | simple_types | type_ref .
 \endverbatim
 * Правила и ограничения:
 *
 * a) Тип данных константы не должен быть абстрактным объектным типом данных (см. \ref p11_s9_4 "9.4").
 *
 * b) Тип данных любого атрибута неабстрактного объектного типа данных должен быть
 * конкретизирующим типом данных или переобъявлен как таковой (см. \ref p11_s9_2_1 "9.2.1").
 *
 * \subsubsection p11_s8_6_2 8.6.2 Параметрические типы данных
 *
 * Параметрические типы данных применяются для представления атрибутов объектных типов данных
 * или формальных параметров алгоритмов (функций и процедур). Параметрические типы данных могут
 * также применяться для представления результатов функций и локальных переменных, объявленных
 * в алгоритмах.
 *
 * К параметрическим типам данных относятся конкретизирующие и обобщённые типы данных.
 * Другими словами, все типы данных языка EXPRESS являются параметрическими типами данных (при этом
 * конструкционные типы данных могут применяться только в качестве основанных на них определённых
 * типах данных).
 \verbatim
   Синтаксис:
    266 parameter_type = generalized_types | named_types | simple_types .
    223 generalized_types = aggregate type | general_aggregation_types | generic_entity_type | generic_type .
 \endverbatim
 * Правила и ограничения:
 *
 * a) Любой параметрический тип данных, соответствующий спецификациям конкретизирующего типа
 * данных, считается конкретизирующим типом данных для применений, в которых требуется
 * конкретизирующий тип данных.
 *
 * b) Общий агрегированный тип данных (см. \ref p11_s9_5_3_5 "9.5.3.5"), базовым типом которого является
 * конкретизирующий тип данных, считается конкретизирующим типом данных.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Синтаксическая конструкция, такая как <B>ARRAY[1:3] OF REAL</B>, соответствует двум
 * синтаксическим порождениям --- <B>aggregation_type</B> и <B>general_aggregation_type</B>. Она считается
 * конкретизирующей независимо от того, какое из порождений требуется для соответствия синтаксису.</SMALL>
 *
 * \subsubsection p11_s8_6_3 8.6.3 Базисные типы данных
 *
 * Базисные типы данных применяются для представления определённых типов данных.
 *
 * К базисным типам данных относятся простые, агрегированные, конструкционные и определённые
 * типы данных.
 \verbatim
   Синтаксис:
    332 underlying_type = concrete_types | constructed_ types .
    193 concrete_types = aggregation_types | simple_types | type_ref
 \endverbatim
 *
 * \section p11_s9 9 Объявления
 *
 * В данном разделе определены объявления, установленные в языке EXPRESS. Объявление в языке
 * EXPRESS создаёт новый элемент языка EXPRESS и связывает с ним некоторый идентификатор. На
 * элемент языка EXPRESS можно ссылаться в любом месте посредством имени связанного с ним
 * идентификатора (см. раздел 10).
 *
 * Основные возможности языка EXPRESS обеспечиваются посредством следующих объявлений:
 * - типа;
 * - объекта;
 * - ограничения на подтипы;
 * - схемы;
 * - константы;
 * - функции;
 * - процедуры;
 * - правила.
 *
 * Объявления могут быть явными или неявными. В данном разделе описаны явные объявления.
 * Неявные объявления описаны в данном разделе и последующих подразделах, наряду с элементами и
 * условиями, при которых они устанавливаются.
 *
 * \subsection p11_s9_1 9.1 Объявление типа
 *
 * Объявление типа создаёт определённый тип данных (см. \ref p11_s8_3_2 "8.3.2") и задаёт идентификатор для ссылки
 * на данный тип. В частности, имя определённого типа данных объявляется как <B>type_id</B>. Представлением
 * данного типа данных является <B>underlying_type</B>. Область определения определённого типа данных
 * совпадает с областью определения базисного типа <B>underlying_type</B>, но может быть дополнительно ограничена
 * конструкцией <B>where_clause</B> (при её наличии). Определённый тип данных является конкретизацией
 * базисного типа данных и, следовательно, совместимым с базисным типом. Исключением являются
 * конструкционные типы данных, когда определённый тип данных используется для задания имени конструкционного
 * типа данных, и фактически не является конкретизацией конструкционного типа данных даже в случае, если
 * выбираемый тип данных \ref express::SELECT "SELECT" ограничен правилом <B>WHERE</B>.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Несколько определённых типов данных могут быть связаны с одним и тем же
 * представлением. Имена могут помочь пользователю в понимании назначения (или контекста) применения
 * базисного типа данных <B>underlying_type</B>.</SMALL>
 \verbatim
   Синтаксис:
    327 type_deсl = TYPE type_id '=' underlying_type ';' [ where_clause ] END_TYPE ';' .
    332 underlying_type = concrete_types | constructed_types .
 \endverbatim
 * Правило: результатом объявлений типа <B>TYPE</B> не должны быть циклические определения типа.
 *
 * <B><I>Пример --- Следующее объявление задаёт определённый тип данных с именем</I> person_name <I>и
 * базовым представлением</I> STRING<I>. Определённый тип</I> person_name <I>после данного объявления
 * доступен для использования в качестве представления атрибутов, локальных переменных и
 * формальных параметров. Это придаёт ему большую осмысленность, чем простое использование типа</I> \ref express::STRING.
 <PRE>
   TYPE person_name = STRING;
   END TYPE;
 </PRE>
 * </B>
 * Правила области определения (условие <B>WHERE</B>).
 *
 * Правила области определения устанавливают ограничения для области определения определённого
 * типа данных. Область определения определённого типа данных является областью определения
 * его базисного представления, ограниченного правилом (или правилами) области определения.
 * Правила области определения указываются после ключевого слова <B>WHERE</B>.
 \verbatim
   Синтаксис:
    338 where_clause = WHERE domain_rule ';' { domain rule ';' } .
 \endverbatim
 * Для каждого объекта <B>domain_rule</B> может быть задана метка правила.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Если метки правил заданы, то они могут использоваться в метках комментария
 * (см. 7.1.6.3) или для идентификации правил в реализациях, например в документации, сообщениях об ошибках
 * и спецификациях применения. Задание меток правил для указанных целей является желательным.</SMALL>
 *
 * Правила и ограничения:
 *
 * a) Результатом оценки каждого правила области определения должно быть логическое (
 * \ref express::LOGICAL.TRUE "TRUE",
 * \ref express::LOGICAL.FALSE "FALSE" или
 * \ref express::LOGICAL.UNKNOWN "UNKNOWN") или неопределённое (<B>?</B>) значение.
 *
 * b) Ключевое слово <B>SELF</B> (см. \ref p11_s14_5 "14.5") должно присутствовать в каждом правиле области определения,
 * по крайней мере, один раз. Правило области определения должно оцениваться для конкретного значения
 * из области определения базисного типа путём подстановки данного значения вместо каждого ключевого
 * слова <B>SELF</B>, присутствующего в правиле.
 *
 * c) Правило области определения должно быть применено, если оценкой выражения является
 * \ref express::LOGICAL.TRUE "TRUE";
 * правило должно быть отклонено, если оценкой выражения является
 * \ref express::LOGICAL.FALSE "FALSE"; правило не должно быть
 * ни применено, ни отклонено, если оценкой выражения является \ref express::LOGICAL.UNKNOWN "UNKNOWN"
 * или неопределённое (<B>?</B>) значение.
 *
 * d) Область определения определённого типа данных состоит из всех значений области определения
 * базисного типа, не нарушающих ни одного правила области определения.
 *
 * e) Метки правил области определения должны быть уникальными в рамках данного объявления
 * типа <B>TYPE</B>.
 * 
 * <B><I>Пример --- Может быть создан определённый тип данных, ограничивающий базисный
 * целочисленный тип данных только положительными целыми числами.</I>
 <PRE>
   TYPE positive = INTEGER;
   WHERE
     notnegative : SELF > 0;
   END_TYPE;
 </PRE>
 * <I>Любой атрибут, локальная переменная или формальный параметр, объявленный принадлежащим
 * к типу</I> positive<I>, при этом будет ограничен только положительными целочисленными значениями.</I></B>
 *
 * \subsection p11_s9_2 9.2 Объявление объекта
 *
 * Объявление объекта \ref express::GENERIC_ENTITY "ENTITY" создаёт объектный тип данных и задаёт
 * идентификатор для ссылок на него.
 *
 * Каждый атрибут представляет свойство объекта и может быть ассоциирован со значением в каждом
 * экземпляре объекта. Тип данных атрибута устанавливает область определения его возможных значений.
 *
 * Каждое ограничение представляет одно из следующих свойств объекта:
 *
 * a) Ограничения на число, вид и структуру значений атрибутов, задаваемые в объявлениях атрибутов.
 *
 * b) Необходимые взаимосвязи между значениями атрибута или ограничения на допустимые значения
 * атрибута для данного экземпляра, задаваемые условием WHERE и рассматриваемые как правила области
 * определения.
 *
 * c) Необходимые взаимосвязи между значениями атрибута для всех экземпляров объектного типа
 * данных, задаваемые в следующих конструкциях:
 *
 * 1) в условии уникальности, где они рассматриваются как ограничения на уникальность;
 *
 * 2) в условии инверсии, где они рассматриваются как ограничения на мощность множества;
 *
 * 3) в глобальных правилах (см. \ref p11_s9_6 "9.6").
 *
 * d) Необходимые взаимосвязи между экземплярами нескольких объектных типов, задаваемые не в
 * самом объявлении объекта, а в форме глобальных правил (см. \ref p11_s9_6 "9.6").
 *
 * Экземпляр объекта в языке EXPRESS может быть создан только посредством конструктора объекта
 * (см. \ref p11_s9_2_6 "9.2.6") или оператора построения сложного объекта (см. \ref p11_s12_10 "12.10").
 \verbatim
   Синтаксис:
    206 entity_decl = entity_head entity_body END_ENTITY ';' .
    207 entity_head = ENTITY entity_id subsuper ';' .
    204 entity_body = { explicit_attr } [ derive_clause ] [ inverse_clause ] [ unique_clause ] [ where_clause ] .
 \endverbatim
 * Правила и ограничения:
 *
 * a) Каждый идентификатор атрибута и метка, указанная в объявлении объекта, должны быть
 * уникальными в рамках объявления.
 *
 * b) Подтип не должен объявлять атрибут, имеющий такой же идентификатор, что и атрибут одного из
 * супертипов, за исключением случая, когда подтип повторно объявляет атрибут, унаследованный от одного
 * из его супертипов (см. \ref p11_s9_2_3_4 "9.2.3.4").
 *
 * \anchor p11_s9_2_1
 *
 * \copydetails express::STEP_ATTRIBUTE
 *
 * \subsubsection p11_s9_2_1_1 9.2.1.1 Явный атрибут
 *
 * Явный атрибут представляет свойство, значение которого должно быть обеспечено реализацией
 * при создании экземпляра. Каждый явный атрибут определяет отдельное свойство. Объявление явного
 * атрибута создаёт один или несколько явных атрибутов, имеющих указанную область определения,
 * и назначает каждому из них идентификатор.
 \verbatim
   Синтаксис:
    215 explicit_attr = attribute_decl { ',' attribute_decl } ':' [ OPTIONAL ] parameter_type ';' .
    177 attribute_decl = attribute_id | redeclared_attribute .
    266 parameter_type = generalized_types | named_types | simple_types .
 \endverbatim
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Синтаксис объекта <B>redeclared_attribute</B> обеспечивает повторное определение
 * атрибута, установленное в \ref p11_s9_2_3_4 "9.2.3.4".</SMALL>
 *
 * Правила и ограничения:
 *
 * a) Если явный атрибут не объявлен как <B>OPTIONAL</B>, то каждый экземпляр объектного типа данных
 * должен иметь значение для данного атрибута.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Если типом данных явного атрибута является наращиваемый перечисляемый тип
 * данных, для которого не заданы элементы перечисления, то такой объект не может быть реализован, если
 * только какое-нибудь расширение перечисляемого типа, содержащее, по крайней мере, один элемент
 * перечисления, не будет объявлено. Если типом данных явного атрибута является наращиваемый выбираемый тип
 * данных, для которого не заданы элементы списка выбора, то такой объект не может быть реализован, если
 * только какое-нибудь расширение выбираемого типа, содержащее, по крайней мере, один именованный тип,
 * не будет объявлено.</SMALL>
 *
 * b) Ключевое слово <B>OPTIONAL</B> указывает на то, что в конкретном экземпляре объекта данный атрибут
 * не обязательно должен иметь значение. Если атрибут не имеет значения, то считается, что он имеет
 * неопределённое (<B>?</B>) значение.
 *
 * c) Явный атрибут не должен объявляться ни явно, ни косвенно как имеющий тип данных <B>GENERIC</B>.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;я
 *
 * 1 Данное правило справедливо, несмотря на то, что такое объявление допускается синтаксисом.
 *
 * 2 Ключевое слово <B>OPTIONAL</B> указывает, что данный атрибут всегда является значимым для
 * экземпляров данного объектного типа, но при этом для некоторых экземпляров он может не иметь значения,
 * соответствующего роли, определяемой данным атрибутом. Ключевое слово <B>OPTIONAL</B> не указывает на то, что атрибут
 * является значимым только для некоторых экземпляров объектного типа данных. Ситуация, при которой
 * атрибут не является значимым для некоторых экземпляров, должным образом моделируется путём
 * определения подтипов (см. \ref p11_s9_2_3 "9.2.3").
 *
 * 3 Необходимо обратить внимание на ссылки на необязательные атрибуты, особенно в правилах,
 * поскольку такие атрибуты могут не иметь значения. Встроенная функция EXISTS может использоваться для
 * определения существования значения атрибута, а встроенная функция NVL позволяет обеспечить значение
 * по умолчанию для вычислений. Если ни одна из данных функций не используется, то могут получиться
 * непредсказуемые результаты.</SMALL>
 *
 * <B><I>Пример --- Следующие объявления эквивалентны:</I>
 <PRE>
     ENTITY point;
       х, у, z : REAL;
     END_ENTITY;
     ENTITY point;
       x : REAL;
       у : REAL;
       z : REAL;
     END_ENTITY;
 </PRE> </B>
 *
 * \subsubsection p11_s9_2_1_2 9.2.1.2 Вычисляемый атрибут
 *
 * Вычисляемый атрибут представляет свойство, значение которого определяется посредством
 * вычисления значения выражения. Вычисляемые атрибуты объявляются после ключевого слова <B>DERIVE</B>.
 * Объявление состоит из идентификатора атрибута, типа его представления и выражения, которое должно
 * использоваться для вычисления значения атрибута.
 \verbatim
   Синтаксис:
    200 derived_attr = attribute_decl ':' parameter_type ':=' expression ';' .
    177 attribute_decl = attribute_id | redeclared_attribute .
    266 parameter_type = generalized_types | named_types | simple_types .
 \endverbatim
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Синтаксис элемента <B>qualified_attribute</B> обеспечивает повторное объявление
 * атрибута, установленное в \ref p11_s9_2_3_4 "9.2.3.4".</SMALL>
 *
 * Выражение может ссылаться на любой атрибут, константу (включая SELF) или идентификатор
 * функции, принадлежащий к области видимости.
 *
 * Правила и ограничения:
 *
 * a) Элемент <B>expression</B> должен быть совместимым с типом данных атрибута, которому присваивается
 * его вычисленное значение (см. \ref p11_s13_3 "13.3").
 *
 * b) Для конкретного экземпляра объекта значение вычисляемого атрибута определяется путём
 * вычисления значения выражения с заменой каждого ключевого слова SELF данным экземпляром и каждой
 * ссылки на атрибут --- значением соответствующего атрибута.
 *
 * c) Вычисляемый атрибут не должен объявляться ни явно, ни косвенно как имеющий тип данных GENERIC.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Данное правило справедливо, несмотря на то, что такое объявление допускается
 * синтаксисом.</SMALL>
 *
 * <B><I>Пример --- В данном примере, круг</I> (circle) <I>определяется центром</I> (centre), <I>осью</I> (axis) <I>и
 * радиусом</I> (radius). <I>Помимо этих явных атрибутов, необходимо знать значения таких важных
 * параметров, как площадь</I> (area) <I>и периметр</I> (perimeter). <I>Данное требование может быть реализовано
 * посредством определения данных параметров как вычисляемых атрибутов, значения которых
 * определены выражениями.</I>
 <PRE>
     ENTITY circle;
       centre : point;
       radius : REAL;
       axis   : vector;
     DERIVE
       area      : REAL := PI*radius**2;
       perimeter : REAL := 2.0*PI*radius;
     END_ENTITY;
 </PRE> </B>
 *
 * \subsubsection p11_s9_2_1_3 9.2.1.3 Инверсный атрибут
 *
 * Если другой объект установил взаимосвязь с данным объектом посредством явного атрибута, то
 * инверсный атрибут может быть использован для описания этой взаимосвязи в контексте данного объекта.
 * Данный инверсный атрибут может также быть использован для того, чтобы ограничить эту взаимосвязь в
 * дальнейшем.
 *
 * Инверсные атрибуты объявляются после ключевого слова <B>INVERSE</B>. Каждый инверсный атрибут
 * должен быть определён отдельно.
 *
 * Ограничения мощности множества, применяемые к инверсной взаимосвязи, устанавливаются
 * спецификацией границ для инверсного атрибута так же, как и для явных атрибутов.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Более подробная информация о взаимосвязи между явными и инверсными
 * атрибутами приведена в приложении H.</SMALL>
 *
 * Инверсный атрибут представляется объектным типом данных либо типами данных \ref express::BAG_GENERIC "BAG" или
 * \ref express::SET_GENERIC "SET", базисным типом которых является объектный тип данных. Обращение к объектному типу данных
 * осуществляется как на ссылочный объект.
 *
 * В объявлении инверсного атрибута также указывается явный атрибут ссылочного объекта. Для
 * конкретного экземпляра данного объектного типа данных значение инверсного атрибута состоит из экземпляра
 * или экземпляров типов данных ссылочного объекта, использующих данный экземпляр в определённой
 * роли. В случае неоднозначности, возникшей из-за идентичности имён атрибутов в графе
 * подтипов/супертипов ссылочного объекта, имени явного атрибута должно предшествовать имя объекта, который
 * первоначально объявляет данный атрибут.
 *
 * Каждый из трёх возможных типов данных для представления инверсного атрибута устанавливает
 * некоторые ограничения на взаимосвязь между двумя объектами, представленные ниже.
 *
 * Тип данных \ref express::BAG_GENERIC "BAG":
 *
 * Спецификация границ, если она задана, определяет минимальное и максимальное число
 * экземпляров ссылочного объекта, которое может использовать экземпляр данного объекта. Поскольку
 * неупорядоченное множество (пакет), представляемое типом данных \ref express::BAG_GENERIC "BAG", может содержать отдельный экземпляр
 * несколько раз, то один или несколько экземпляров могут ссылаться на данный экземпляр, а конкретный
 * экземпляр может ссылаться на данный экземпляр несколько раз.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;я
 *
 * 1 Если инвертированный атрибут представлен неуникальным агрегированным типом данных, то есть
 * списком или массивом, для которого не задано ключевое слово <B>UNIQUE</B>, либо пакетом, то конкретный экземпляр
 * данного объекта может быть использован конкретным экземпляром ссылочного объекта несколько раз.
 *
 * 2 Если инвертированный атрибут представлен уникальным агрегированным типом данных, то есть
 * списком или массивом, для которого задано ключевое слово <B>UNIQUE</B>, либо набором, то конкретный экземпляр
 * данного объекта может быть использован конкретным экземпляром ссылочного объекта только один раз.</SMALL>
 *
 * Представление инверсного атрибута с нижней границей равной нулю указывает на то, что на данный
 * экземпляр данного объекта не обязательно должен ссылаться любой экземпляр ссылочного объекта.
 *
 * Тип данных \ref express::SET_GENERIC "SET":
 *
 * Справедливо все сказанное выше для типа данных \ref express::BAG_GENERIC "BAG", но с дополнительным ограничением,
 * определяющим уникальность ссылочных экземпляров. Данное ограничение также означает, что конкретный
 * ссылочный экземпляр может использовать данный экземпляр в инвертированной роли только один раз.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Если инвертированный атрибут представлен уникальным агрегированным типом
 * данных, то есть списком или массивом, для которого задано ключевое слово <B>UNIQUE</B>, либо набором, то инверсия
 * не добавляет новых ограничений относительно уникальности.</SMALL>
 *
 * Объектный тип данных:
 *
 * Инверсный атрибут содержит точно тот один экземпляр ссылочного объектного типа данных, который
 * использует данный экземпляр в определённой роли. В данном случае мощность множества инверсной
 * взаимосвязи имеет соотношение 1:1.
 \verbatim
   Синтаксис:
    248 inverse_attr = attribute_decl ':' [ ( SET | BAG ) [ bound_spec ] OF ]
                       entity_ref FOR [ entity_ref '.' ] attribute_ref ';' .
    177 attribute_decl = attribute_id | rediclared_attribute .
    185 bound_spec = '[' bound_1 ':' bound_2 ']' .
    183 bound_1 = numeric_expression .
    184 bound_2 = numeric_expression .
 \endverbatim
 * Правила и ограничения:
 *
 * a) Объект, в котором определяется объявление прямой взаимосвязи с данным объектом, должен
 * реализовать данное объявление в форме явного атрибута.
 *
 * b) Типом данных явного атрибута в объекте, определяющем прямую взаимосвязь, должен быть один
 * из следующих:
 *
 * 1) тип объявляемого объекта;
 *
 * 2) супертип объявляемого объекта;
 *
 * 3) определённый тип данных, основанный на выбираемом типе данных, содержащем один из
 * перечисленных выше типов;
 *
 * 4) агрегированный тип данных, основным типом которого является один из перечисленных выше.
 *
 * c) Объект, на который имеется ссылка в объявлении инверсного атрибута, может быть подтипом объекта,
 * объявившего прямую взаимосвязь. В данном случае инверсный атрибут содержит только экземпляры
 * данного подтипа. Подтипы, на которые даются ссылки подобным образом, не должны повторно объявлять
 * явный атрибут как вычисляемый атрибут.
 *
 * d) Если имя явного атрибута в объекте, определяющем прямую взаимосвязь, не уникально в графе
 * подтипов/супертипов данного объекта, то для уточнения имени данного явного атрибута после ключевого
 * слова <B>FOR</B> должно быть использовано имя объектного типа данных.
 *
 * e) Инверсный атрибут не должен объявляться ни явно, ни косвенно как имеющий тип данных <B>GENERIC</B>.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Данное правило справедливо, несмотря на то, что такое объявление допускается
 * синтаксисом.</SMALL>
 *
 * <B><I>Пример --- Предположим, что имеется следующее объявление для определения двери (объект</I> door):
 <PRE>
     ENTITY door;
       handle : knob;
       hinges : SET [1 : ?] OF hinge;
     END_ENTITY;
 </PRE>
 * <I>Мы можем ограничить объявление шарообразной ручки (объект</I> knob<I>) так, чтобы
 * шарообразные ручки могли существовать только, если они используются в роли поворотной ручки (объект</I>
 * handle<I>) в одном экземпляре двери.</I>
 <PRE>
     ENTITY knob;
     ...
     INVERSE
       opens : door FOR handle;
     END_ENTITY;
 </PRE>
 * <I>С другой стороны, мы можем просто указать, что шарообразная ручка используется в одной
 * двери или не используется (например, она уже установлена на двери или ещё только должна быть к ней
 * присоединена).</I>
 <PRE>
     ENTITY knob;
     ...
     INVERSE
       opens : SET [0 : 1] OF door FOR handle;
     END_ENTITY;
 </PRE> </B>
 *
 * \subsection p11_s9_2_2 9.2.2 Локальные правила
 *
 * Локальные правила являются формальными утверждениями для области определения экземпляров
 * объекта и, таким образом, применимы ко всем экземплярам данного объектного типа данных. Существуют
 * два вида локальных правил. Правила уникальности контролируют уникальность значений атрибутов среди
 * всех экземпляров заданного объектного типа данных. Правила области определения описывают другие
 * ограничения на значения или между значениями атрибутов каждого экземпляра заданного объектного типа
 * данных.
 *
 * Каждому из локальных правил может быть присвоена метка правила.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Метки правил, если они заданы, могут быть использованы в метках комментария
 * (см. 7.1.6.3) или для идентификации правил в реализациях, например, в документации, сообщениях об
 * ошибках и спецификациях применения. Задание меток правил для указанных целей является желательным.</SMALL>
 *
 * \subsubsection p11_s9_2_2_1 9.2.2.1 Правило уникальности
 *
 * В правиле уникальности может быть определено ограничение уникальности для отдельных атрибутов
 * или комбинаций атрибутов. Правила уникальности записывают после ключевого слова <B>UNIQUE</B>, указывая
 * имя одиночного атрибута или список имён атрибутов. Правило, в котором указано имя одиночного
 * атрибута, называется правилом простой уникальности и устанавливает, что никакие два экземпляра объектного
 * типа данных из области определения не должны использовать один и тот же экземпляр именованного
 * атрибута. Правило, в котором указаны два или более имён атрибутов, называется правилом совместной
 * уникальности и устанавливает, что никакие два экземпляра объектного типа данных не должны иметь
 * одинаковую комбинацию экземпляров именованных атрибутов.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * При сравнении оценивается равенство экземпляров, а не равенство значений
 * (см. \ref p11_s12_2_2 "12.2.2").</SMALL>
 *
 * Правило: если явный атрибут, который отмечен как OPTIONAL (см. \ref p11_s9_2_1_1 "9.2.1.1"), появляется в правиле
 * уникальности, и если при этом атрибут не имеет значения для конкретного экземпляра объекта, то правило
 * уникальности не является ни нарушенным, ни доказанным, и поэтому данный экземпляр объекта
 * принадлежит области определения.
 \verbatim
   Синтаксис:
    333 unique_clause = UNIQUE unique_rule ';' { unique rule ';' } .
    334 unique_rule = [ rule_label_id ':' ] referenced_attribute { ','
           referenced_attribute } .
    280 referenced_attribute = attribute_ref | qualified_attribute .
 \endverbatim
 * <B><I>Примеры
 *
 * 1 Если объект не имеет три атрибута</I> a, b <I>и</I> с<I>, то следующий фрагмент на языке EXPRESS
 * означает, что два экземпляра объявленного объектного типа данных не могут иметь одинаковые
 * значения для</I> a, b <I>или</I> с.
 <PRE>
     ENTITY e;
     a, b, c : INTEGER;
     UNIQUE
     ur1 : а;
     ur2 : b;
     ur3 : с;
     END_ENTITY;
 </PRE>
 * <I>2 Объект</I> person_name <I>может быть определён следующим образом:</I>
 <PRE>
     ENTITY person name;
       last : STRING;
       first : STRING;
       middle : STRING;
       nickname : STRING;
     END_ENTITY;
 </PRE>
 * <I>Данный объект может быть использован следующим образом:</I>
 <PRE>
     ENTITY employee;
       badge : NUMBER;
       name : person_name;
       ...
     UNIQUE
       ur1 : badge, name;
       ...
     END_ENTITY;
 </PRE>
 * <I>В данном примере два экземпляра объекта</I> person_name <I>могли бы иметь одинаковый набор
 * значений для четырёх атрибутов. Однако для объекта</I> employee <I>введено требование, чтобы
 * совместное использование атрибутов</I> badge <I>и</I> name <I>было уникальным. Таким образом, два
 * экземпляра объекта</I> employee <I>могут иметь одинаковое значение атрибута</I> badge <I>и одинаковое значение
 * атрибута</I> name<I>. Однако никакие два экземпляра объекта</I> employee <I>не могут иметь одинаковый
 * экземпляр атрибута</I> badge <I>и одинаковый экземпляр атрибута</I> name<I>, поскольку при совместном
 * использовании данная комбинация экземпляров должна быть уникальной (см. \ref p11_s9_6 "9.6" по поводу способа
 * описания уникальности значений атрибутов).</I></B>
 *
 * \subsubsection p11_s9_2_2_2 9.2.2.2 Правила области определения (условие WHERE)
 *
 * Правила области определения ограничивают значения отдельных атрибутов или комбинаций
 * атрибутов для каждого экземпляра объекта. Все правила области определения указывают после ключевого слова
 * WHERE.
 \verbatim
   Синтаксис:
    338 where_clause = WHERE domain_rule ';' { domain_rule ';' } .
 \endverbatim
 * Правила и ограничения:
 *
 * a) Результатом оценки выражения, описывающего правило области определения, должно быть
 * логическое значение (\ref express::LOGICAL::TRUE "TRUE",
 * \ref express::LOGICAL::FALSE "FALSE" или
 * \ref express::LOGICAL::UNKNOWN "UNKNOWN") или неопределённое (<B>?</B>) значение.
 *
 * b) Каждое выражение, описывающее правило области определения, должно содержать ключевое
 * слово <B>SELF</B> или атрибуты, объявленные в определении объекта или любого его супертипа.
 *
 * c) Появление ключевого слова <B>SELF</B> должно означать ссылку на экземпляр объявляемого объекта.
 *
 * d) Правило области определения должно считаться доказанным, если оценкой выражения является
 * значение \ref express::LOGICAL::TRUE "TRUE"; правило должно считаться нарушенным, если оценкой выражения является значение
 * \ref express::LOGICAL::FALSE "FALSE"; правило будет считаться ни доказанным, ни нарушенным, если оценкой выражения является
 * неопределённое (<B>?</B>) значение или значение \ref express::LOGICAL::UNKNOWN "UNKNOWN".
 *
 * e) Все правила должны выполняться для допустимого экземпляра объекта (в данной области
 * определения).
 *
 * <B><I>Пример --- Для объекта</I> unit_vector <I>требуется, чтобы его длина была равна точно единице. Это
 * ограничение может быть определено следующим образом:</I>
 <PRE>
     ENTITY unit_vector;
       a, b, с : REAL;
     WHERE
       length_1 : a**2 + b**2 + c**2 = 1.0;
     END_ENTITY;
 </PRE>
 * </B>
 * Необязательные атрибуты в правилах области определения:
 *
 * Правило области определения, содержащее необязательный атрибут, должно трактоваться в
 * соответствии с описанными ниже правилами и ограничениями.
 *
 * Правила и ограничения:
 *
 * a) Если атрибут имеет значение, то правило области определения должно оцениваться как любое
 * другое правило области определения.
 *
 * b) Если атрибут не имеет значения, то в качестве значения атрибута при оценке выражения,
 * описывающего правило области определения, используется неопределённое (<B>?</B>) значение. Оценка выражений,
 * содержащих неопределённое (<B>?</B>) значение, рассмотрена в разделе \ref p11_s12 "12".
 *
 * <B><I>Пример --- Рассмотрим следующий вариант предыдущего примера:</I>
 <PRE>
     ENTITY unit_vector;
       a, b : REAL;
       с    : OPTIONAL REAL;
     WHERE
       length_1 : а**2 + b**2 + с**2 = 1.0;
     END_ENTITY;
 </PRE>
 * <I>Целью правила области определения является обеспечение того, чтобы объект</I> unit_vector
 * <I>сделать единичным. Однако если атрибут с имеет неопределённое (?) значение, то оценкой
 * правила области определения всегда является значение</I> \ref express::LOGICAL::UNKNOWN "UNKNOWN",
 * <I>независимо от значений аргументов</I> а <I>и</I> b.
 *
 * <I>Стандартная функция</I> \ref express::NVL() "NVL" <I>(см. \ref express::NVL() "15.18") может быть использована
 * для обеспечения приемлемого значения в случае, если необязательный атрибут имеет неопределённое (?) значение.
 * Если необязательный атрибут имеет значение, то функция</I> \ref express::NVL() "NVL" <I>возвращает данное значение;
 * в противном случае она возвращает подстановочное значение.</I>
 <PRE>
     ENTITY unit_vector;
       а, b : REAL;
       с : OPTIONAL REAL;
     WHERE
       length_1 : a**2 + b**2 + NVL(c, 0.0)**2 = 1.0;
     END_ENTITY;
 </PRE>
 * </B>
 *
 * \subsection p11_s9_2_3 9.2.3 Подтипы и супертипы
 *
 * Язык EXPRESS допускает определение объектов как подтипов других объектов, где подтип объекта
 * является конкретизацией его супертипа. Тем самым устанавливается наследственная взаимосвязь
 * (подтип/супертип) между объектами, в которых подтип наследует свойства (то есть атрибуты и ограничения)
 * своего супертипа. Последовательные взаимосвязи подтип/супертип определяют граф наследования, в
 * котором каждый экземпляр подтипа является экземпляром его супертипа (или супертипов).
 *
 * Граф наследования, определённый взаимосвязями подтип/супертип, должен быть ациклическим.
 *
 * Если в объявлении объекта полностью определены все значимые свойства данного объекта, то это
 * означает, что объявлен простой объектный тип данных. Если в объявлении объекта установлены
 * наследственные взаимосвязи с супертипами, то это означает, что объявлен сложный объектный тип данных. Сложный
 * объектный тип данных в рамках графа наследования использует характеристики своего супертипа (или
 * супертипов). Сложный объектный тип данных может иметь дополнительные характеристики, не
 * содержащиеся в его супертипе (или супертипах).
 \verbatim
   Синтаксис:
    312 subsuper = [ supertype_constraint ] [ subtype_declaration ] .
 \endverbatim
 * Следующие положения относятся к взаимосвязям подтип/супертип и основываются на графе
 * подтипов/супертипов. Граф подтипов/супертипов является многокорневым направленным ациклическим графом,
 * в котором узлы представляют объектные типы данных, а ребра представляют взаимосвязи
 * подтип/супер тип. Следующие за ключевыми словами <B>SUBTYPE OF</B> связи ведут к супертипам, тогда как следующие за
 * ключевыми словами <B>SUBTYPE OF</B> связи ведут от супертипов к подтипам.
 *
 * Правила и ограничения:
 *
 * a) Ограничение супертипа, при его наличии, должно предшествовать ограничению подтипа, если
 * оно присутствует.
 *
 * b) Подтип может иметь более одного супертипа.
 *
 * c) Супертип может иметь более одного подтипа.
 *
 * d) Супертип может сам быть подтипом одного или нескольких других объектных типов данных. То
 * есть пути в графе подтипов/супертипов могут проходить через несколько узлов.
 *
 * e) Взаимосвязь подтип/супертип должна быть транзитивной. То есть, если А является подтипом В, а В
 * является подтипом С, то А является подтипом С. Объекты, являющиеся супертипами некоторого
 * объектного типа данных, должны быть такими объектами, к которым можно найти путь на графе, начиная с данного
 * объектного типа данных и следуя по связям <B>SUBTYPE OF</B>.
 *
 * f) Подтип не должен быть супертипом любого из типов, указанных в списке всех его супертипов, то
 * есть граф подтипов/супертипов должен быть ациклическим.
 *
 * \subsubsection p11_s9_2_3_1 9.2.3.1 Определение подтипов
 *
 * Объект является подтипом, если он содержит объявление с ключевым словом <B>SUBTYPE</B>. В
 * объявлении подтипа должны указываться все непосредственные супертипы объекта. Экземпляр объектного типа
 * данных, определённый как подтип, является экземпляром каждого из его супертипов.
 \verbatim
   Синтаксис:
    318 subtype_declaration = SUBTYPE OF '(' entity_ref { ',' entity_ref } ')' .
 \endverbatim
 *
 * \subsubsection p11_s9_2_3_2 9.2.3.2 Определение супертипов
 * Объект может быть объявлен супертипом посредством явного или неявного определения. Объект
 * объявлен супертипом в явной форме, если он содержит объявление с ключевым словом <B>ABSTRACT
 * SUPERTYPE</B>. Объект объявлен супертипом в неявной форме, если его имя задано в объявлении
 * <B>SUBTYPE</B>, по крайней мере, одного другого объекта.
 \verbatim
   Синтаксис:
    319 supertype_constraint = abstract_entity_declaration | abstract_supertype_declaration | supertype_rule .
    164 abstract_entity_declaration = ABSTRACT .
    166 abstract_supertype_declaration = ABSTRACT SUPERTYPE [ subtype_constraint ] .
    313 subtype_constraint = OF '(' supertype_expression ')' .
    320 supertype_expression = supertype_factor { ANDOR supertype_factor } .
    321 supertype_factor = supertype_term { AND supertype_term } .
    323 supertype_term = entity_ref | one of | '(' supertype_expression ')' .
    263 one_of = ONEOF '(' supertype_expression { ',' supertype_expression } ')' .
    322 supertype_rule = SUPERTYPE subtype_constraint .
 \endverbatim
 * Правило: все подтипы, указанные в выражении для супертипа, должны содержать объявление
 * подтипа, идентифицирующее данный объект как супертип.
 *
 * <B><I>Пример --- Нечётные числа являются подтипом целых чисел, следовательно, целые числа
 * являются супертипом нечётных чисел.</I>
 <PRE>
     ENTITY integer_number;
       val : INTEGER;
     END_ENTITY;
     ENTITY odd_number
       SUBTYPE OF (integer_number);
     WHERE
       not_even : ODD(val) ;
     END_ENTITY;
 </PRE>
 * </B>
 *
 * \subsubsection p11_s9_2_3_3 9.2.3.3 Наследование атрибутов
 *
 * Идентификаторы атрибутов в супертипе определены в рамках области видимости подтипа (см. раздел
 * \ref p11_s10 "10"). Таким образом, подтип наследует все атрибуты своего супертипа. Это позволяет подтипам
 * определять ограничения или свои собственные атрибуты с использованием унаследованного атрибута.
 * Если подтип имеет несколько супертипов, то подтип наследует все атрибуты от всех своих супертипов.
 * Это называется множественным наследованием.
 *
 * Правила и ограничения:
 *
 * a) Объект не должен объявлять атрибут с таким же именем, как у атрибута, унаследованного от
 * одного из его супертипов, если только он не объявляет унаследованный атрибут повторно (см. \ref p11_s9_2_3_4 "9.2.3.4").
 *
 * b) Если подтип наследует атрибуты от двух супертипов, не имеющих общих элементов, то
 * допускается, чтобы они имели отличающиеся атрибуты с одинаковыми идентификаторами. Неоднозначность имён
 * должна разрешаться посредством добавления к идентификатору префикса с именем супертипа, от
 * которого унаследован каждый из атрибутов.
 *
 * <B><I>Пример --- В данном примере показано, как объект</I> е12 <I>наследует два атрибута с
 * одинаковыми именами</I> attr<I>, а для того, чтобы указать, для какого из двух атрибутов задаётся
 * ограничение, к его имени добавляется префикс.</I>
 <PRE>
     ENTITY e1;
       attr : REAL;
       ...
     END_ ENTITY;
  
     ENTITY e2;
       attr : BINARY;
       ...
     END_ENTITY;
  
     ENTITY e12
     SUBTYPE OF (e1,e2);
       ...
     WHERE
       positive : SELF\e1.attr > 0.0 ; -- атрибут attr, объявленный в e1
     END_ENTITY;
  </PRE> </B>
 *
 * Подтип может наследовать один и тот же атрибут от разных супертипов, которые в свою очередь
 * унаследовали его от одного супертипа. Это называется повторным наследованием. В данном случае
 * подтип наследует атрибут только один раз, то есть существует только одно значение для данного атрибута в
 * экземпляре данного объектного типа данных.
 *
 * \subsubsection p11_s9_2_3_4 9.2.3.4 Повторное объявление атрибута
 *
 * Атрибут, объявленный в супертипе, может быть повторно объявлен в подтипе. Атрибут остаётся в
 * супертипе, но допустимая область значений для данного атрибута определяется повторным объявлением,
 * заданным в подтипе.
 *
 * Первоначальное объявление может быть изменено тремя основными способами:
 * - атрибуту может быть присвоено другое имя;
 * - тип данных атрибута может быть изменён конкретизацией исходного типа данных (см. \ref p11_s9_2_7 "9.2.7").
 *
 * <B><I>Пример --- Атрибут типа данных</I> NUMBER <I>может быть изменён на тип данных</I> INTEGER <I>или</I> REAL;</B>
 *
 * - если исходным типом данных атрибута является определённый тип данных, основанный на
 * выбираемом типе данных, то он может быть изменён другим списком выбора, определяющим подмножество или
 * конкретизацию элементов исходного списка выбора, либо конкретизацией одного из элементов исходного
 * типа выбора;
 * - необязательный атрибут в супертипе может быть изменён на обязательный атрибут в подтипе;
 * - явный атрибут в супертипе может быть изменён на вычисляемый атрибут в подтипе;
 * - атрибуту в супертипе может быть присвоен новый идентификатор в подтипе. Новый идентификатор
 * подчиняется всей области видимости и правилам видимости, определённым в разделе \ref p11_s10 "10", для
 * идентификатора атрибута подтипа, объявление которого содержит данное повторное объявление; но данный
 * идентификатор всегда относится также и к исходному атрибуту в супертипе.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Объявление нового идентификатора не удаляет старый идентификатор из области
 * видимости имен. Старый идентификатор остаётся доступным в своём объектном типе данных и в любых
 * подтипах, объявленных для данного объектного типа данных.</SMALL>
 \verbatim
   Синтаксис:
    279 redeclared_attribute = qualified_attribute [ RENAMED attribute_id ] .
    275 qualified_attribute = SELF group_qualifier attribute_qualifier .
    232 group_qualifier = '\' entity_ref .
    179 attribute_qualifier = '.' attribute_ref .
 \endverbatim
 * Правила и ограничения:
 *
 * a) Тип данных в повторном объявлении должен совпадать или являться конкретизацией типа данных
 * атрибута, объявленного в супертипе. Применяются правила конкретизации по \ref p11_s9_2_7 "9.2.7".
 *
 * b) Имя повторно объявленного атрибута должно быть задано с использованием синтаксиса элемента
 * <B>qualified_attribute</B>.
 *
 * c) Если тип данных, использованный при определении исходного атрибута, был ограничен правилом
 * <B>WHERE</B>, то тип данных, используемый для определения повторно объявленного атрибута, должен быть
 * ограничен так, чтобы область определения повторно объявленного атрибута являлась подмножеством
 * области определения исходного атрибута.
 *
 * d) Элемент <B>group_qualifier</B> в синтаксисе элемента <B>qualified_attribute</B> должен идентифицировать
 * объектный тип данных, в котором данный атрибут был первоначально объявлен, либо объектный тип
 * данных, который повторно объявляет атрибут из другого супертипа.
 *
 * e) Если атрибут супертипа повторно объявлен в двух не взаимоисключающих подтипах, то
 * экземпляр, содержащий оба подтипа, должен иметь единственное значение для атрибута, являющегося
 * допустимым для обоих повторных объявлений.
 *
 * f) Если атрибуту присвоен новый идентификатор, то данный идентификатор не должен совпадать
 * с идентификатором любого атрибута в любом супертипе данного объектного типа данных.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Правило <B>WHERE</B>, заданное для исходного атрибута, остаётся в силе и для повторных
 * объявлений данного атрибута (см. \ref p11_s9_2_3_5 "9.2.3.5").</SMALL>
 *
 * <B><I>Примеры
 *
 * 1 В некоторых геометрических системах используются координаты с плавающей точкой,
 * в то время как другие системы работают в целочисленном координатном пространстве.
 * Понятия</I> GENERIC_ENTITY <I>и</I> RENAMED <I>обеспечивают спецификации общей применимости и
 * конкретизации для специфической области применения.</I>
 <PRE>
   ENTITY point;
     х : NUMBER;
     у : NUMBER;
   END_ENTITY;
   ENTITY integer_point
     SUBTYPE OF (point);
     SELF\point.x RENAMED integer_x : INTEGER;
     SELF\point.y RENAMED integer_y : INTEGER;
   END_ENTITY;
   ENTITY line ABSTRACT;
     start : GENERIC_ENTITY;
     end : GENERIC_ENTITY;
   END_ENTITY;
   ENTITY integer_point_line;
     SUBTYPE OF (line);
     SELF\line.start RENAMED integer_start : INTEGER_point;
     SELF\line.end RENAMED integer_end : INTEGER_point;
   END_ENTITY;
</PRE>
 * <I>2 Данный пример демонстрирует изменение элементов агрегированного типа данных на
 * уникальные, уменьшение числа элементов агрегированного типа данных и изменение
 * необязательного атрибута на обязательный.</I>
 <PRE>
   ENTITY super;
     things : LIST [3 : ?] OF thing;
     items : BAG [0 : ?] OF widget;
     may_be : OPTIONAL stuff;
   END_ENTITY;
   ENTITY sub
     SUBTYPE OF (super);
     SELF\super.things : LIST [3 : ?] OF UNIQUE thing;
     SELF\super.items : SET [1 : 10] OF widget;
     SELF\super.may_be : stuff;
   END_ENTITY;
 </PRE>
 * <I> 3 В данном примере круг задан центром, осью и радиусом. Вариант круга задан центром и
 * двумя точками, через которые он проходит. Эти три точки представляют данные, посредством
 * которых задан данный вариант круга. В дополнение к этим данным необходимо учесть и другие
 * важные параметры --- радиус и ось. Это осуществляется посредством их повторного объявления
 * как вычисляемых атрибутов с заданием их значений выражениями.</I>
 <PRE>
  FUNCTION distance(p1, p2 : point) : REAL;
    (* Вычисляет кратчайшее расстояние между двумя точками *)
  END_FUNCTION;
  FUNCTION normal (p1, p2, p3 : point) : vector;
    (* Вычисляет нормаль к плоскости, заданной тремя точками на ней *)
  END_FUNCTION;
  ENTITY circle;
    centre : point;
    radius : REAL;
    axis : vector;
  DERIVE
    area : REAL := PI*radius**2;
  END_ENTITY;
  ENTITY circle_by_points
    SUBTYPE OF (circle);
    p2 : point;
    p3 : point;
  DERIVE
    SELF\circle.radius : REAL := distance (centre, p2);
    SELF\circle.axis : vector := normal (centre, p2, p3);
  WHERE
    not coincident : (centre <> p2) AND
                     (p2 <> p3) AND
                     (рЗ <> centre);
    is_circle : distance (centre,p3) =
                distance (centre,p2);
  END_ENTITY;
 </PRE>
 * <I>В подтипе три определяющие точки</I> (centre, p2 <I>и</I> рЗ) <I>являются явными атрибутами, а объекты</I>
 * radius, axis <I>и</I> area <I>являются вычисляемыми атрибутами. Значения вычисляемых атрибутов
 * определяются выражением, следующим за оператором присваивания. Значения объектов</I> radius <I>и</I> axis
 * <I>получаются посредством вызова функции; заодно вычисляется значение объекта</I> area.</B>
 *
 * \subsubsection p11_s9_2_3_5 9.2.3.5 Наследование правил
 *
 * Каждое локальное или глобальное правило, относящееся ко всем экземплярам супертипа,
 * применимо и ко всем экземплярам его подтипов. Таким образом, подтип наследует все правила своего супертипа.
 * Если подтип имеет несколько супертипов, то подтип должен наследовать все правила, ограничивающие
 * супертипы.
 *
 * Нельзя изменить или удалить какое-либо из правил, связанных с подтипом, через наследование
 * правил, но можно добавить новые правила, ещё более ограничивающие подтип.
 *
 *  Правило: на экземпляр объекта распространяются все ограничения, установленные для каждого из
 * его объектных типов данных.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Если ограничения, установленные в двух (или более) объектных типах данных,
 * противоречат друг другу, то не может существовать допустимого экземпляра, содержащего эти объектные типы
 * данных.</SMALL>
 *
 * <B><I>Пример --- В данном примере выпускником (объект</I> graduate<I>) является лицо (объект</I> person<I>),
 * которое и учит, и учится. Объект</I> graduate <I>наследует атрибуты и ограничения от своих супертипов
 * (объектов</I> teacher <I>(преподаватель) и</I> student <I>(студент)) вместе с атрибутами и ограничениями из
 * их общего супертипа (объекта</I> person<I>). Но выпускнику, в отличие от преподавателя, не разрешено
 * преподавать на старших курсах.</I>
 <PRE>
  SCHEMA s;
  ENTITY person;
    ss_no : INTEGER;
    born : date;
    ...
  DERIVE
    age : INTEGER := years_since (born);
  UNIQUE
    un1 : ss_no;
  END_ENTITY;
  ENTITY teacher
    SUBTYPE OF (person);
    teaches : SET [1 : ?] OF course;
    ...
  WHERE
    old : age >= 21;
  END_ENTITY;
  ENTITY student
    SUBTYPE OF (person);
    takes : SET [1 : ?] OF course;
    ...
  WHERE
    young : age >= 5;
  END_ENTITY;
  ENTITY graduate
    SUBTYPE OF (student, teacher);
    ...
  WHERE
    limited : NOT (GRAD_LEVEL IN teaches);
  END_ENTITY;
  TYPE course = ENUMERATION OF (... , GRAD_LEVEL, ...);
  END TYPE;
    ...
  END_SCHEMA; -- конец схемы S
 </PRE>
 * </B>
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Если подтип наследует взаимно противоречащие ограничения от своих супертипов, то
 * не может существовать соответствующий экземпляр данного подтипа, поскольку любой экземпляр будет
 * нарушать одно из ограничений.</SMALL>
 *
 * \subsubsection p11_s9_2_4 9.2.4 Абстрактный объектный тип данных
 *
 * Язык EXPRESS позволяет объявлять объектные типы данных, не предназначенные для
 * непосредственной реализации, а только для реализации через свои подтипы. Абстрактный объектный тип данных
 * может объявить явные или вычисляемые атрибуты, типами данных которых являются обобщённые типы
 * данных (см. \ref p11_s8_5 "8.5"). Эти обобщённые типы данных могут затем быть повторно объявлены как реализуемые
 * типы данных в подтипах абстрактного объектного типа данных. Если подтип абстрактного объектного типа
 * данных сам является абстрактным объектным типом данных, то он не должен повторно объявлять
 * нереализуемые унаследованные атрибуты как реализуемые типы данных. В подтипе абстрактного объектного типа
 * данных, который не является абстрактным объектным типом данных, никакие унаследованные или явно
 * объявленные атрибуты не должны иметь нереализуемый тип данных.
 *
 * Метки типа (см. \ref p11_s9_5_3_4 "9.5.3.4") могут быть использованы для обеспечения того, что два или более атрибута,
 * типами данных которых являются обобщенные типы данных, имеют одинаковые типы данных на момент
 * обращения.
 *
 * Правила и ограничения:
 *
 * a) Объявление абстрактного объектного типа данных содержит ключевое слово ABSTRACT в
 * объявлении объектного типа данных ENTITY, но не содержит ключевое слово SUPERTYPE (понятие ABSTRACT
 * SUPERTYPE определено в \ref p11_s9_2_5_1 "9.2.5.1").
 *
 * b) Абстрактный объектный тип данных не является реализуемым, если только он не является частью
 * сложного объектного типа данных, все атрибуты которого, имеющие обобщенные типы данных, были
 * объявлены повторно как имеющие реализуемый тип данных.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;я
 *
 * 1 Правило по перечислению b) обеспечивает соответствие любого абстрактного объектного типа данных
 * ограничению абстрактного супертипа (см. \ref p11_s9_2_5_1 "9.2.5.1").
 *
 * 2 Повторное объявление может быть осуществлено непосредственно в реализуемом подтипе или в одном
 * из его супертипов (см. \ref p11_s9_2_4 "9.2.4").</SMALL>
 *
 * <B><I>Пример --- В обобщённой модели согласования может потребоваться определить, что может
 * быть согласована группа объектов. Данная модель затем может быть использована в ряде других
 * схем и уточнена в части определения согласования реальных объектов.</I>
 <PRE>
   ENTITY general_approval ABSTRACT;
     approved_items : BAG OF GENERIC_ENTITY;
     status : approval_status;
   END_ENTITY;
 </PRE>
 * </B>
 *
 * \subsubsection p11_s9_2_5 9.2.5 Ограничения подтипов/супертипов
 *
 * Экземпляр объектного типа данных, объявленный явно или неявно как супертип (см. \ref p11_s9_2_3_2 "9.2.3.2"), может
 * также являться экземпляром одного или нескольких из его подтипов (см. H.2).
 \verbatim
   Синтаксис:
    319 supertype_constraint = abstract_entity_declaration |
                               abstract_supertype_declaration | supertype_rule .
    164 abstract_entity_declaration = ABSTRACT .
    166 abstract_supertype_declaration = ABSTRACT SUPERTYPE [ subtype_constraint ] .
    313 subtype_constraint = OF '(' supertype_expression ')' .
    320 supertype_expression = supertype_factor { ANDOR supertype_factor } .
    321 supertype_factor = supertype_term { AND supertype_term } .
    323 supertype_term = entity_ref | one_of | '(' supertype_expression ')' .
    263 one_of = ONEOF '(' supertype_expression { ',' supertype_expression } ')' .
    322 supertype_rule = SUPERTYPE subtype_constraint .
 \endverbatim
 * Имеется возможность определить ограничения, в соответствии с которыми могут быть реализованы
 * графы подтипов/супертипов. Данные ограничения могут быть определены в объявлении супертипа
 * посредством условия <B>SUPERTYPE</B>. Они могут также быть определены как отдельные правила посредством
 * объявлений <B>SUBTYPE_CONSTRAINT</B> (см. \ref p11_s9_7 "9.7").
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Для того, чтобы существующие схемы, разработанные в соответствии с первой
 * редакцией справочного руководства по языку EXPRESS, оставались допустимыми, объявление ограничений
 * на подтипы/супертипы, в котором при объявлении объекта используются ключевые слова <B>ONEOF</B>, <B>ANDOR</B>
 * или <B>AND</B>, остаётся допустимым по отношению к настоящему стандарту. Однако, данный способ объявления
 * нежелателен, поскольку в последующих редакциях стандарта планируется его запрет. Рекомендуется
 * использовать объявление <B>SUBTYPE_CONSTRAINT</B>.</SMALL>
 *
 * Объявление <B>SUBTYPE_CONSTRAINT</B> содержит совокупность ограничений, установленных в
 * выражении <B>supertype_expression</B>. Объявление <B>SUBTYPE_CONSTRAINT</B> может содержать любое число
 * ограничений <B>AND</B> и <B>ONEOF</B>, каждое из которых интерпретируется как отдельное ограничение.
 *
 * Кроме того, при включении в формулировку какого-либо более сложного ограничения каждое
 * выражение <B>ONEOF</B>, <B>AND</B> и <B>ANDOR</B> интерпретируется как совокупность экземпляров супертипа. При
 * интерпретации выражения supertype_expression применяют следующие правила:
 * - имя объектного типа данных, встретившееся где-либо в выражении <B>supertype_expression</B>,
 * интерпретируется как множество экземпляров объекта, образующих полную совокупность данного типа данных,
 * как и в глобальном правиле (см. \ref p11_s9_6 "9.6");
 * - результат вычисления выражения <B>supertype_expression</B> интерпретируется как множество
 * экземпляров супертипа в соответствии с определёнными ниже ограничениями <B>ONEOF</B>, <B>AND</B> и <B>ANDOR</B>.
 *
 * Несмотря на то, что конечным результатом вычисления выражения <B>supertype_expression</B> для
 * объявления <B>SUBTYPE_CONSTRAINT</B> является множество экземпляров объекта, данное множество не имеет
 * значения. То есть результат всего выражения <B>supertype_expression</B> не устанавливает никакого
 * ограничения, поскольку он не обязательно содержит все экземпляры супертипа и может содержать экземпляры, к
 * которым не применяется ни одно из установленных ограничений.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Следовательно, независимые ограничения могут быть связаны оператором <B>ANDOR</B>,
 * который только добавляет экземпляры к общему (не имеющему значения) результату выражения
 * <B>supertype_expression</B>.</SMALL>
 *
 * Формальный подход к определению возможных комбинаций подтипов/супертипов, которые могут
 * быть реализованы с учетом некоторых возможных ограничений, определённых ниже, представлен в
 * приложении В.
 * 
 * \subsubsection p11_s9_2_5_1 9.2.5.1 Абстрактные супертипы
 *
 * Язык EXPRESS допускает объявление супертипов, не предназначенных для непосредственной
 * реализации. Для этого объектный тип данных должен содержать ключевые слова <B>ABSTRACT SUPERTYPE</B>
 * в ограничении супертипа. Абстрактный супертип не должен быть реализован, кроме как в сочетании, по
 * крайней мере, с одним из его подтипов.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Это означает, что схема, содержащая определение абстрактного супертипа без
 * каких-либо подтипов, является неполной и не может быть реализована, если только подтипы не объявлены
 * в ссылочной схеме.</SMALL>
 *
 * <B><I>Пример --- В модели перевозок транспортное средство (объект</I> vehicle<I>) может быть
 * представлено абстрактным супертипом, поскольку все экземпляры данного объектного типа данных
 * предназначены быть его подтипами (например, наземное или водное транспортное средство).
 * Объектный тип данных для транспортного средства не должен реализовываться независимо.</I>
 <PRE>
  ENTITY vehicle
    ABSTRACT SUPERTYPE;
  ENDENTITY;
  ENTITY land_based
    SUBTYPE OF (vehicle);
    ...
  END ENTITY;
  ENTITY water_based
  SUBTYPE OF (vehicle);
    ...
  ENDENTITY;
 </PRE>
 * </B>
 *
 * \subsubsection p11_s9_2_5_2 9.2.5.2 ONEOF
 *
 * Ограничение \ref p11_s9_2_5_2 "ONEOF" устанавливает, что совокупности операндов из списка \ref p11_s9_2_5_2 "ONEOF"
 * являются взаимоисключающими. Никакой экземпляр любой совокупности операндов из списка ONEOF не должен
 * присутствовать в совокупности любого другого операнда из списка \ref p11_s9_2_5_2 "ONEOF".
 \verbatim
   Синтаксис:
    263 one_of = ONEOF '(' supertype_expression { ',' supertype_expression } ')' .
    320 supertype_expression = supertype_factor { ANDOR supertype_factor } .
    321 supertype_factor = supertype_term { AND supertype_term } .
    323 supertype_term = entity_ref | one_of | '(' supertype_expression ')' .
 \endverbatim
 *
 * Ограничение \ref p11_s9_2_5_2 "ONEOF" может комбинироваться с другими ограничениями супертипов, чтобы дать
 * возможность записывать сложные ограничения. Когда ограничение \ref p11_s9_2_5_2 "ONEOF" присутствует как операнд в
 * другом ограничении, оно представляет множество экземпляров объектов, являющееся объединением
 * совокупностей операндов из списка \ref p11_s9_2_5_2 "ONEOF".
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * На естественном языке фраза \ref p11_s9_2_5_2 "ONEOF"<B>(a, b, с)</B> означает, что «экземпляр объекта
 * должен состоять только из одного из объектных типов данных <B>а, b, с</B>».</SMALL>
 *
 * <B><I>Пример --- Экземпляр супертипа может быть установлен посредством реализации только
 * одного из его подтипов. Данное ограничение объявляется с использованием ключевого слова</I> \ref p11_s9_2_5_2 "ONEOF".
 * <I>Существует множество видов домашних животных (объект</I> pet<I>), но ни одно домашнее животное не
 * может одновременно принадлежать к двум или более видам.</I>
 <PRE>
     ENTITY pet
       ABSTRACT SUPERTYPE OF (ONEOF (cat,
                                     rabbit,
                                     dog,
                                     ...) );
       name : pet_name;
       ...
     END ENTITY;
     ENTITY cat
       SUBTYPE OF (pet);
       ...
     END ENTITY;
     ENTITY rabbit
       SUBTYPE OF (pet);
       ...
     END ENTITY;
     ENTITY dog
       SUBTYPE OF (pet);
         ...
     END ENTITY;
 </PRE>
 * </B>
 *
 * \subsubsection p11_s9_2_5_3 9.2.5.3 ANDOR
 *
 * Экземпляр совокупности, определяемой выражением с ключевым словом \ref p11_s9_2_5_3 "ANDOR", может быть
 * экземпляром совокупности любого из операндов или обоих. Таким образом, \ref p11_s9_2_5_3 "ANDOR" не определяет
 * ограничение. В сложном ограничении ANDOR представляет множество экземпляров объектов, являющееся
 * объединением совокупностей выражений, определяющих операнды.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * \ref p11_s9_2_5_3 "ANDOR" используется только при построении совокупностей для более сложного
 * ограничения. На естественном языке фраза <B>«b \ref p11_s9_2_5_3 "ANDOR" c»</B> означает «все экземпляры типа <B>b</B> и все экземпляры
 * типа <B>c</B>, включая те, которые являются экземплярами обоих типов».</SMALL>
 *
 * <B><I>Пример --- Человек (объект</I> person<I>) может быть служащим, посещающим вечерние занятия,
 * и поэтому являться одновременно и служащим (объект</I> employee<I>), и студентом (объект</I> student<I>).</I>
 *
 <PRE>
     ENTITY person
       SUPERTYPE OF (employee ANDOR student);
       ...
     END_ENTITY;
     ENTITY employee
       SUBTYPE OF (person);
       ...
     END ENTITY;
     ENTITY student
       SUBTYPE OF (person);
       ...
     END ENTITY;
 </PRE>
 * </B>
 *
 * \subsubsection p11_s9_2_5_4 9.2.5.4 AND
 *
 * Ключевое слово \ref p11_s9_2_5_4 "AND" определяет ограничение, что совокупности, заданные двумя операндами,
 * должны быть идентичными. То есть любой экземпляр совокупности левого операнда должен также быть
 * экземпляром совокупности правого операнда, а любой экземпляр совокупности правого операнда должен также
 * быть экземпляром совокупности левого операнда.
 *
 * Когда выражение с ключевым словом \ref p11_s9_2_5_4 "AND" присутствует в качестве операнда в сложном
 * ограничении, оно представляет любую из совокупностей своих операндов, поскольку они идентичны.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * На естественном языке фраза <B>«b \ref p11_s9_2_5_4 "AND" с»</B> означает, что «экземпляр должен
 * одновременно состоять из типов <B>b</B> и <B>с</B>».</SMALL>
 *
 * <B><I>Пример --- Человек (объект</I> person<I>) может быть классифицирован как лицо мужского (объект</I>
 * male<I>) или женского (объект</I> female<I>) пола, либо как гражданин (объект</I> citizen<I>) или иностранец (объект</I>
 * alien<I>).</I>
 *
 <PRE>
     ENTITY person
       SUPERTYPE OF (ONEOF (male, female) AND
                     ONEOF (citizen, alien));
       ...
     END_ENTITY;
     ENTITY male
       SUBTYPE OF (person);
       ...
     END_ENTITY;
     ENTITY female
       SUBTYPE OF (person);
       ...
     END_ENTITY;
     ENTITY citizen
       SUBTYPE OF (person);
       ...
     END_ENTITY;
     ENTITY alien
       SUBTYPE OF (person);
       ...
     END_ENTITY;
 </PRE>
 * </B>
 *
 * \subsubsection p11_s9_2_5_5 9.2.5.5 Приоритеты операторов супертипов
 *
 * Оценка выражений супертипов проводится слева направо, при этом сначала определяются
 * значения операторов с наивысшим приоритетом. Правила приоритетов для операторов выражений супертипов
 * представлены в \ref p11_table8 "таблице 8". Операторы, расположенные в одной строке, имеют равный приоритет, а строки
 * упорядочены по уменьшению приоритета.
 *
 * \anchor p11_table8
 * Т&nbsp;а&nbsp;б&nbsp;л&nbsp;и&nbsp;ц&nbsp;а 8 --- Приоритет оператора выражения супертипа
 *
 * <TABLE border="1" cellspacing="0">
 * <tr><td><CENTER>Приоритет</CENTER> </td><td> <CENTER>Операторы</CENTER>      </td></tr>
 * <tr><td></td><td></td></tr>
 * <tr><td> <CENTER>1</CENTER>        </td><td> <CENTER><B>()ONEOF</B></CENTER> </td></tr>
 * <tr><td> <CENTER>2</CENTER>        </td><td> <CENTER><B>AND</B></CENTER>     </td></tr>
 * <tr><td> <CENTER>3</CENTER>        </td><td> <CENTER><B>ANDOR</B></CENTER>   </td></tr>
 * </TABLE></td><td>
 *
 * \subsubsection p11_s9_2_5_6 9.2.5.6 Ограничения между подтипами по умолчанию
 *
 * Если в объявлении объекта не указано никаких ограничений на супертипы, то подтипы (при их
 * наличии) должны быть взаимно инклюзивными, то есть, как если бы все подтипы были бы неявно представлены
 * в конструкции <B>ANDOR</B>.
 *
 * Если ограничение на супертипы задано для подмножества подтипов данного объекта, то оно
 * должно включать в себя ограничения, установленные для этих подтипов, и ограничение <B>ANDOR</B> для
 * других подтипов.
 *
 * <B><I>Пример --- Модель из примера в \ref p11_s9_2_5_3 "9.2.5.3" эквивалентна использованию следующей конструкции по
 * умолчанию:</I>
 <PRE>
   ENTITY person
     ...
   END ENTITY;
   ENTITY employee
     SUBTYPE OF (person);
     ...
  END ENTITY;
  ENTITY student
    SUBTYPE OF (person);
    ...
  END ENTITY;
 </PRE>
 * </B>
 *
 * \subsubsection p11_s9_2_6 9.2.6 Неявные объявления
 *
 * При объявлении объекта, одновременно неявным образом объявляется конструктор. Идентификатор
 * конструктора совпадает с идентификатором объекта и область видимости объявления конструктора
 * совпадает с областью видимости объявления объекта.
 *
 * При запуске конструктора он должен возвращать в точку вызова значение частичного сложного
 * объекта для данного объектного типа данных. Каждый атрибут данного значения частичного сложного
 * объекта задаётся фактическим параметром, заданным в вызове конструктора мнимой копией. Мнимая
 * копия представляет собой объект, в который экземпляр объекта копируется посредством ссылки, то
 * есть атрибут является ссылкой на экземпляр, используемый в качестве фактического параметра, простой
 * тип данных имеет скопированное значение, а агрегированные структуры имеют элементы, скопированные
 * в мнимую копию. Конструктор должен обеспечивать только явные атрибуты из объявления конкретного
 * объекта.
 \verbatim
   Синтаксис:
    205 entity_constructor = entity_ref '(' [ expression { ',' expression } ] ')' .
 \endverbatim
 * При создании экземпляра сложного объекта (экземпляра объекта, присутствующего в графе
 * подтипов/супертипов) конструкторы всех составляющих его объектов должны объединяться посредством
 * оператора <B>||</B> (см. \ref p11_s12_10 "12.10").
 *
 * Правила и ограничения:
 *
 * a) Конструктор должен иметь один формальный параметр для каждого явного атрибута, объявленного
 * в данном объектном типе данных. Это не относится к атрибутам, унаследованным от супертипов и повторно
 * объявленным в данном объектном типе данных.
 *
 * b) Порядок формальных параметров должен быть идентичен порядку объявления явных атрибутов в
 * объекте.
 *
 * c) Параметрический тип данных каждого из формальных параметров должен быть идентичен типу
 * данных соответствующего атрибута.
 *
 * d) Если объект не имеет явных атрибутов, то должен быть указан пустой список параметров (то есть
 * круглые скобки всегда должны присутствовать).
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Обязательное присутствие круглых скобок отличается от явно объявленных функций.</SMALL>
 *
 * e) Необязательные атрибуты могут быть заданы неопределённым (<B>?</B>) значением при вызове неявно
 * определённого конструктора. Это указывает на то, что явное значение не было задано.
 *
 * f) Если в экземпляре сложного объекта имеется подтип, содержащий вычисляемые атрибуты,
 * являющиеся повторно объявленными явными атрибутами супертипа, то конструктор супертипа должен задавать
 * значения для данных повторно объявленных атрибутов. Вместо этих значений используется вычисленное
 * значение.
 *
 * <B><I>Пример --- Допустим, имеется следующее объявление объекта:</I>
 <PRE>
     ENTITY point;
       х, у, z : REAL;
     END_ENTITY;
 </PRE>
 * <I>Тогда неявно объявленный конструктор объекта</I> point <I>может быть представлен следующим образом:</I>
 <PRE>
     FUNCTION point (x,y,z : REAL) : point;
 </PRE>
 * <I>Данный конструктор затем может использоваться при присваивании значений экземпляру
 * данного объектного типа данных:</I>
 <PRE>
     CONSTANT
       origin : point := point(0.0, 0.0, 0.0);
     END_CONSTANT;
 </PRE>
 * </B>
 *
 * \subsubsection p11_s9_2_7 9.2.7 Конкретизация
 *
 * Конкретизация является более ограниченной формой исходного объявления. Существуют
 * следующие варианты определения конкретизации:
 * - объект, относящийся к подтипу данных, является конкретизацией любого из своих супертипов;
 * - тип данных <B>ENTITY</B> является конкретизацией типа данных <B>GENERIC_ENTITY</B>;
 * - тип данных <B>EXTENSIBLE GENERIC_ENTITY SELECT</B> является конкретизацией типа данных
 * <B>GENERIC_ENTITY</B>;
 * - тип данных <B>SELECT</B>, содержащий только типы данных <B>ENTITY</B>, является конкретизацией типа
 * данных <B>GENERIC_ENTITY</B>;
 * - агрегированные типы данных являются конкретизациями типа данных \ref express::AGGREGATE "AGGREGATE";
 * - тип данных \ref express::SELECT "SELECT", состоящий из объектов <B>a, b, c</B>, является конкретизацией
 * типа данных \ref express::SELECT "SELECT", состоящего из объектов <B>d, e, f</B>, если объекты
 * <B>a, b, c</B> являются конкретизациями объектов <B>d, e, f</B>;
 * - тип данных \ref express::SELECT "SELECT", состоящий из объектов <B>a, b, c</B>, является конкретизацией
 * супертипа, если <B>a, b, c</B> являются подтипами данного супертипа;
 * - типы данных \ref express::INTEGER "INTEGER" и \ref express::REAL "REAL" оба являются
 * конкретизациями типа данных \ref express::NUMBER "NUMBER";
 * - тип данных \ref express::INTEGER "INTEGER" является конкретизацией типа данных \ref express::REAL "REAL";
 * - тип данных \ref express::BOOLEAN "BOOLEAN" является конкретизацией типа данных \ref express::LOGICAL "LOGICAL";
 * - выражение <B>LIST OF UNIQUE item</B> является конкретизацией выражения <B>LIST OF item</B>;
 * - выражение <B>ARRAY OF UNIQUE item</B> является конкретизацией выражения <B>ARRAY OF item</B>;
 * - выражение <B>ARRAY OF item</B> является конкретизацией выражения <B>ARRAY OF OPTIONAL item</B>;
 * - выражение <B>SET OF item</B> является конкретизацией выражения <B>BAG OF item</B>;
 * - пусть <B>AGG</B> обозначает один из типов данных <B>ARRAY, BAG, LIST</B> или <B>SET</B>, тогда выражение
 * <B>AGG OF item</B> является конкретизацией выражения <B>AGG OF original</B> при условии, что <B>item</B> является
 * конкретизацией <B>original</B>;
 * - пусть <B>AGG</B> обозначает один из типов данных <B>BAG, LIST</B> или <B>SET</B>, тогда выражение <B>AGG [b : t]</B>
 * является конкретизацией выражения <B>AGG [l : u]</B> при условии, что
 * <B>b</B> &le; <B>t</B> и <B>l</B> &le; <B>b</B> &le; <B>u</B> и <B>l</B> &le; <B>t</B> &le; <B>u</B>;
 * - пусть <B>BSR</B> обозначает один из типов данных
 * \ref express::BINARY "BINARY", \ref express::STRING "STRING" или \ref express::REAL "REAL", тогда <B>BSR(length)</B>
 * является конкретизацией <B>BSR</B>;
 * - <B>BSR(short)</B> является конкретизацией <B>BSR(long)</B> при условии, что <B>short</B> меньше чем <B>long</B>;
 * - тип данных \ref express::BINARY "BINARY", в котором используется ключевое слово <B>FIXED</B>, является конкретизацией типа
 * данных \ref express::BINARY "BINARY" переменной длины;
 * - тип данных \ref express::STRING "STRING", в котором используется ключевое слово <B>FIXED</B>, является конкретизацией
 * типа данных \ref express::STRING "STRING" переменной длины;
 * - конструкционный тип данных, основанный на расширяемом конструкционном типе данных, является
 * конкретизацией данного расширяемого конструкционного типа данных;
 * - определённый тип данных является конкретизацией базисного типа данных, использованного для
 * объявления данного определённого типа данных.
 *
 * \subsection p11_s9_3 9.3 Схема
 *
 * Объявление схемы (<B>SCHEMA</B>) определяет общую область видимости для совокупности относящихся
 * к нему объявлений объектных и других типов данных. Схема может подвергаться изменениям в рамках
 * среды разработки или стандартизации. Для поддержки возможности идентификации конкретной версии
 * схемы определяется идентификатор версии схемы. В настоящем стандарте не определяется формат
 * идентификатора версии схемы, за исключением того, что он должен быть строковым литералом. Ни в одной
 * конструкции, определённой в настоящем стандарте, нет ссылок на идентификатор версии схемы. Кроме
 * того, в настоящем стандарте не определён способ управления изменениями в схемах с использованием
 * идентификаторов версии схемы. Если две схемы с одинаковым именем имеют разные идентификаторы
 * версии схемы, то они не должны рассматриваться как одна и та же схема.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Для схем, установленных в стандартах комплекса ИСО 10303, определено
 * использование идентификатора информационного объекта, включающего в себя идентификатор версии. Смысл
 * идентификатора объекта установлен в ИСО/МЭК 8824-1 и описан в ИСО 10303-1. Данный идентификатор объекта
 * рекомендуется использовать в качестве идентификатора версии схемы.</SMALL>
 *
 * <B><I>Примеры
 *
 * 1 Идентификатор</I> geometry <I>может быть именем схемы, содержащей объявления точек, кривых,
 * поверхностей и других, связанных с ними, типов данных.
 *
 * 2 Может существовать множество версий схем, идентификаторы которых могут включать
 * также идентификатор версии языка. В данном примере в схеме</I> support_resource_schema
 * <I>используется идентификатор информационного объекта, соответствующий определению ИСО/МЭК 8842-1 и
 * описанию в ИСО 10303-1.</I>
 <PRE>
     SCHEMA geometry_schema ' version_1' ;
     END_SCHEMA;
     SCHEMA geometry_schema ' version_2 ' ;
     END_SCHEMA;
     SCHEMA support_resource_schema '{ISO standard 10303 part(41) object(1)
            version(8) } ' ;
     END_SCHEMA;
     SCHEMA support_resource_schema '{ISO standard 10303 part(41) object(1)
            version(9) }' ;
     END_SCHEMA;
 </PRE>
 * </B>
 *
 * Порядок, в котором объявления появляются в объявлении схемы, значения не имеет.
 *
 * Объявления, сделанные в одной схеме, могут быть сделаны видимыми в области видимости другой
 * схемы посредством спецификации интерфейса в соответствии с разделом \ref p11_s11 "11".
 \verbatim
   Синтаксис:
    296 schema_decl = SCHEMA schema_id [ schema_version_id ] ';' schema _body
                      END_SCHEMA ';' .
    298 schema_version_id = string_literal .
    295 schema_body = { interface_specification } [ constant_decl ]
                      { declaration | rule_decl } .
    242 interface_specification = reference_clause | use_clause .
    199 declaration = entity_decl | function_decl | procedure_decl |
                      subtype_constraint_decl | type_decl .
 \endverbatim
 *
 * \subsection p11_s9_4 9.4 Константа
 *
 * Объявление константы используется для объявления именованных констант. Областью видимости
 * идентификатора константы должна быть функция, процедура, правило или схема, в которых происходит
 * объявление константы. Именованная константа, появляющаяся в объявлении <B>CONSTANT</B>, должна иметь
 * явную инициализацию, значение которой вычисляется посредством оценивания выражения. Именованная
 * константа может присутствовать в объявлении другой именованной константы. Объявление констант
 * должно быть ациклическим.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Требование ацикличности объявлений констант необходимо для обеспечения
 * достоверности инициализации в любом случае, поскольку инициализация не обязательно реализуется в порядке
 * объявления.</SMALL>
 *
 \verbatim 
   Синтаксис:
    195 constant_decl = CONSTANT constant_body { constant_body} END_CONSTANT ';' .
    194 constant_body = constant_id ':' instantiable_type ':=' expression ';' .
    240 instantiable_type = concrete_types | entity_ref .
 \endverbatim
 *
 * Правила и ограничения:
 *
 * a) Значение константы не должно изменяться после инициализации.
 *
 * b) Любое появление именованной константы вне её объявления должно быть эквивалентно
 * появлению её инициализированного значения.
 *
 * c) Выражение <B>expression</B> в синтаксическом правиле 194 должно возвращать значение
 * соответствующее указанному базовому типу.
 *
 * <B><I>Пример --- Ниже приведены допустимые объявления констант:</I>
 <PRE>
     CONSTANT
       thousand : NUMBER := 1000;
       million : NUMBER := thousand**2;
       origin : point := point(0.0, 0.0, 0.0);
     END_CONSTANT;
 </PRE>
 * </B>
 *
 * \subsection p11_s9_5 9.5 Алгоритмы
 *
 * Алгоритм является последовательностью операторов, выполнение которых приводит к некоторому
 * желаемому конечному состоянию. Существуют два вида алгоритмов --- функции и процедуры.
 *
 * Формальные параметры определяют исходные данные для алгоритма. Обращение к алгоритму
 * осуществляется с фактическими параметрами, обеспечивающими фактические значения или экземпляры.
 * Фактические параметры должны соответствовать формальным параметрам по типу данных, порядку
 * следования и числу.
 *
 * Если в алгоритме необходимо сделать локальные объявления, то они приводятся непосредственно
 * после заголовка алгоритма. Локальными объявлениями могут быть объявления типов данных, локальных
 * переменных, других алгоритмов и т.д.
 *
 * После локальных объявлений следует тело алгоритма.
 *
 * \subsubsection p11_s9_5_1 9.5.1 Функция
 *
 * Функция является алгоритмом, который обрабатывает параметры и выдает единственное
 * результирующее значение установленного типа данных. При обращении к функции (см. \ref p11_s12_8 "12.8")
 * в выражении вычисляется результирующее значение в точке вызова.
 *
 * Функция должна завершаться выполнением оператора <B>RETURN</B>. Значение выражения, связанного с
 * оператором <B>RETURN</B>, определяет результат, полученный при вызове функции.
 \verbatim
   Синтаксис:
    220 function_decl = function_head algorithm_head stmt { stmt } END_FUNCTION ';' .
    221 function_head = FUNCTION function_id [ '(' formal_parameter
                        { ';' formal_parameter } ')' ] ' :' parameter_type ';' .
    218 formal_parameter = parameter_id { ',' parameter_id } ':' parameter_type .
    266 parameter_type = generalized_types | named_types | simple_types .
    173 algorithm_head = { declaration } [ constant_decl ] [ local_decl ] .
    199 declaration = entity_decl | function_decl | procedure_decl |
                      subtype_constraint_decl | type_decl .
 \endverbatim
 *
 * Правила и ограничения:
 *
 * a) Оператор <B>RETURN</B> должен быть определён в теле функции для каждой из возможных ветвей
 * вычислительного процесса, активизируемого при обращении к данной функции.
 *
 * b) Для каждого оператора <B>RETURN</B>, присутствующего в функции, должно быть задано выражение, по
 * которому вычисляется значение, возвращаемое в точку вызова.
 *
 * c) Выражения, заданные для операторов <B>RETURN</B>, должны соответствовать объявленному типу
 * данных возвращаемого функцией значения.
 *
 * d) Функции не должны иметь побочных эффектов. Поскольку формальные параметры функции не
 * должны определяться ключевым словом <B>VAR</B>, изменения этих параметров внутри функции не
 * показываются в точке вызова функции.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Локальным переменным, объявленным объектными типами данных, могут быть
 * назначены экземпляры формальных параметров. Изменение этих локальных переменных будет влиять на
 * формальный параметр, поскольку назначение осуществляется по ссылке. В соответствии с приведенным выше
 * правилом, изменения формальных параметров не показываются в точке вызова функции, поэтому особое внимание
 * необходимо обратить на попытку возврата этих локальных переменных.</SMALL>
 *
 * e) Функции могут модифицировать локальные переменные или параметры, объявленные во внешней
 * области видимости, то есть если данная функция объявлена в заголовке (элемент <B>algorithm_head</B> в
 * определении синтаксиса) оператора <B>FUNCTION</B>, <B>PROCEDURE</B> или <B>RULE</B>.
 *
 * \subsubsection p11_s9_5_2 9.5.2 Процедура
 *
 * Процедура является алгоритмом, который получает параметры в точке вызова и обрабатывает их
 * некоторым образом для получения желаемого конечного состояния. Изменения параметров внутри
 * процедуры показываются в точке вызова только в том случае, если формальному параметру предшествует
 * ключевое слово <B>VAR</B>.
 \verbatim
   Синтаксис:
    271 procedure_decl = procedure_head algorithm_head { stmt } END_PROCEDURE ';' .
    272 procedure head = PROCEDURE procedure_id [ '(' [ VAR ] formal_parameter
                         { ';' [ VAR ] formal_parameter } ')' ] ';' .
    218 formal_parameter = parameter_id { ',' parameter_id } ':' parameter_type .
    266 parameter_type = generalized_types | named_types | simple_types .
    173 algorithm_head = { declaration } [ constant_decl ] [ local_decl ] .
    199 declaration = entity_decl | function_decl | procedure_decl |
                      subtype_constraint_decl | type_decl .
 \endverbatim
 * Правило: процедуры могут модифицировать локальные переменные или параметры, объявленные во
 * внешней области видимости, то есть если данная функция объявлена в заголовке (элемент <B>algorithm_head</B>
 * в определении синтаксиса) оператора <B>FUNCTION</B>, <B>PROCEDURE</B> или <B>RULE</B>.
 *
 * \subsubsection p11_s9_5_3 9.5.3 Параметры
 *
 * Функция или процедура может иметь формальные параметры. Каждый формальный параметр
 * устанавливает имя и тип параметра. Имя является идентификатором, который должен быть уникальным в
 * области видимости функции или процедуры. Формальный параметр процедуры может, кроме того, быть
 * объявлен с ключевым словом VAR (изменяемый), которое означает, что если данный параметр изменяется
 * внутри процедуры, то данное изменение должно быть передано в точку вызова процедуры. Параметры, не
 * объявленные как VAR, также могут изменяться, но такое изменение не будет видимым после возврата
 * управления вызвавшей структуре.
 \verbatim
   Синтаксис:
    218 formal_parameter = parameter_id { ',' parameter_id } ':' parameter_type .
    266 parameter_type = generalized_types | named_types | simple_types .
 \endverbatim
 * <B><I>Пример --- Следующие объявления показывают, как могут быть объявлены формальные
 * параметры.</I>
 *
 <PRE>
   FUNCTION dist(p1, p2 : point) : REAL ;
   ...
   PROCEDURE midpt(p1, p2 : point; VAR result : point) ;
 </PRE>
 * </B>
 * Обобщённые типы данных (\ref express::AGGREGATE "AGGREGATE", общий агрегированный тип данных,
 * \ref express::GENERIC "GENERIC" и \ref express::GENERIC_ENTITY "GENERIC_ENTITY") (см. \ref p11_s8_5 8.5)
 * используются для того, чтобы обеспечить обобщение типов данных, используемых для представления формальных
 * параметров функций и процедур. Тип данных \ref express::AGGREGATE "AGGREGATE", общий
 * агрегированный тип данных (см. \ref p11_s9_5_3_5 "9.5.3.5") и родовой объектный тип данных
 * (\ref express::GENERIC_ENTITY "GENERIC_ENTITY") могут, кроме
 * того, использоваться для объявления явных или вычисляемых атрибутов абстрактных объектных типов
 * данных. Общий агрегированный тип данных может также использоваться, чтобы обеспечить обобщение
 * базисных типов данных, разрешенное для конкретных агрегированных типов данных.
 *
 * \subsubsection p11_s9_5_3_1 9.5.3.1 Тип данных AGGREGATE
 *
 * Тип данных \ref express::AGGREGATE "AGGREGATE" является обобщением всех агрегированных типов данных.
 * При вызове процедуры или функции, формальный параметр которой определён типом данных
 * \ref express::AGGREGATE "AGGREGATE", передаваемый фактический параметр должен иметь тип данных
 * \ref express::ARRAY_GENERIC "ARRAY", \ref express::BAG_GENERIC "BAG", \ref express::LIST_GENERIC "LIST" или \ref express::SET_GENERIC "SET".
 * При этом операции, которые могут быть выполнены, должны зависеть от типа данных фактического параметра.
 * 
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Метки типов (см. \ref p11_s9_5_3_4 "9.5.3.4") могут использоваться для обеспечения того, чтобы при
 * вызове два или более параметров, представленных типом данных AGGREGATE, имели одинаковый тип
 * данных, или чтобы тип данных возвращаемого результата был таким же, как и у одного из переданных
 * параметров, независимо от переданных фактических типов данных.</SMALL>
 * 
 * Если явный или вычисляемый атрибут в объявлении типа данных ABSTRACT ENTITY представлен
 * типом данных  \ref express::AGGREGATE "AGGREGATE", то данный атрибут должен быть объявлен в подтипах данного абстрактного
 * объекта как  \ref express::ARRAY_GENERIC "ARRAY", \ref express::BAG_GENERIC "BAG", \ref express::LIST_GENERIC "LIST" или \ref express::SET_GENERIC "SET".
 \verbatim
   Синтаксис:
    171 aggregate_type = AGGREGATE [ ':' type_label ] OF parameter_type .
    329 type_label = type_label_id | type_label_ref .
    266 parameter_type = generalized_types | named_types | simple_types .
 \endverbatim
 * Правила и ограничения:
 * 
 * a) Тип данных AGGREGATE должен использоваться только в качестве типа формального
 * параметра функции или процедуры, либо типа результата функции, либо типа локальной переменной внутри
 * функции или процедуры, либо представления явного или вычисляемого атрибута в объявлении типа
 * данных ABSTRACT ENTITY.
 * 
 * b) Если тип данных AGGREGATE используется в качестве типа данных результата функции или типа
 * данных локальной переменной внутри функции или процедуры, то для такого применения требуются
 * ссылки меток типов. Ссылки меток типов должны ссылаться на метки типов, объявленные формальными
 * параметрами (см. \ref p11_s9_5_3_4 "9.5.3.4").
 * 
 * c) Если тип данных AGGREGATE используется в качестве представления явного или
 * вычисляемого атрибута в объявлении типа данных ABSTRACT ENTITY, то данный атрибут должен быть
 * повторно объявлен как  \ref express::ARRAY_GENERIC "ARRAY", \ref express::BAG_GENERIC "BAG", \ref express::LIST_GENERIC "LIST" или \ref express::SET_GENERIC "SET"
 * в неабстрактных подтипах данного объектного типа данных.
 * 
 * <B><I>Пример --- Данная функция получает агрегированную структуру чисел. Функция должна
 * возвращать результат того же типа, что и у переданной ей агрегированной структуры, содержащий
 * масштабированные числа.</I>
 <PRE>
   FUNCTION scale (input : AGGREGATE : intype OF REAL;
                   scalar : REAL) : AGGREGATE : intype OF REAL;
     LOCAL
       result : AGGREGATE : intype OF REAL := input;
     END_LOCAL;
     IF SIZEOF ( [ 'BAG, 'SET' ] * TYPEOF(input)) > 0 THEN
       REPEAT i := LOINDEX (input) TO HIINDEX (input);
         result := result – input[i];           \-- удалить исходный
         result := result + scalar * input[i];  \-- вставить масштабированный
       END_REPEAT;
     ELSE
       REPEAT i := LOINDEX(input) TO HIINDEX(input);
         result [i] := scalar * input[i];
       END_REPEAT;
     END_IF
     RETURN (result);
   END_FUNCTION
 </PRE>
 * </B>
 * 
 * \subsubsection p11_s9_5_3_2 9.5.3.2 Обобщённый тип данных
 *
 * Тип данных GENERIC является обобщением всех других типов данных.
 *
 * При вызове процедуры или функции с типом данных формального параметра GENERIC,
 * передаваемый фактический параметр может не иметь тип данных GENERIC. Операции, которые при этом могут быть
 * выполнены, зависят от типа данных фактического параметра.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Метки типов (см. \ref p11_s9_5_3_4 "9.5.3.4") могут быть использованы для обеспечения того, чтобы при
 * вызове два или более параметров, представленных типом данных GENERIC, имели одинаковый тип данных, или
 * чтобы тип данных возвращаемого результата был таким же, как и у одного из переданных параметров,
 * независимо от переданных фактических типов данных.</SMALL>
 \verbatim
   Синтаксис:
    231 generic_type = GENERIC [ ':' type_label ] .
    329 type_label = type_label_id | type_label_ref .
 \endverbatim
 * Правила и ограничения:
 *
 * a) Тип данных GENERIC должен использоваться только в качестве типа формального параметра
 * функции или процедуры, типа результата функции либо типа локальной переменной внутри функции или
 * процедуры.
 *
 * b) Если тип данных GENERIC используется в качестве типа данных результата функции или типа
 * данных локальной переменной внутри функции или процедуры, то для такого применения требуются
 * ссылки меток типов. Ссылки меток типов должны ссылаться на метки типов, объявленные
 * формальными параметрами (см. \ref p11_s9_5_3_4  "9.5.3.4").
 *
 * <B><I>Пример --- В данном примере показана универсальная функция, осуществляющая сложение чисел
 * или векторов:</I>
 <PRE>
   FUNCTION add (a,b: GENERIC : intype) : GENERIC : intype;
     LOCAL
       nr : NUMBER; -- целое или действительное число
       vr : vector;
     END_LOCAL;
     IF ( 'NUMBER' IN TYPEOF(a) ) AND ( 'NUMBER' IN TYPEOF(b) ) THEN
           nr := a+b;
           RETURN (nr);
     ELSE
       IF ( 'THIS_SCHEMA.VECTOR ' IN TYPEОF(a) ) AND
          ( 'THIS_SCHEMA.VECTOR ' IN TYPEOF(b) ) THEN
         vr := vector (a.i + b.i,
                       a.j + b.j,
                       a.k + b.k);
         RETURN (vr);
       END_IF;
     END IF;
     RETURN (?) ; -- если получен неправильный входной параметр, то
                  -- возвращается неопределённое значение
   END FUNCTION;
 </PRE> </B>
 *
 * \subsubsection p11_s9_5_3_3 9.5.3.3 Обобщённый объектный тип данных
 *
 * Тип данных GENERIC_ENTITY является обобщением всех объектных типов данных.
 *
 * При вызове процедуры или функции с формальным параметром, имеющим тип данных
 * GENERIC_ENTITY, передаваемый фактический параметр должен быть экземпляром объекта. Операции,
 * которые при этом могут быть выполнены, зависят от типа данных фактического параметра.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Метки типов (см. \ref p11_s9_5_3_4 "9.5.3.4") могут быть использованы для обеспечения того, чтобы
 * при вызове двух или более параметров, представленных типом данных GENERIC_ENTITY, имели одинаковый
 * тип данных или чтобы тип данных возвращаемого результата был таким же, как и у одного из переданных
 * параметров, независимо от переданных фактических типов данных.</SMALL>
 *
 * Если в объявлении типа данных ABSTRACT ENTITY явный или вычисляемый атрибут представлен
 * типом данных GENERIC_ENTITY, то данный атрибут должен быть объявлен в подтипах данного объекта
 * конкретным объектным типом данных.
 \verbatim
   Синтаксис:
    230 generic_entity_type = GENERIC_ENTITY [ ':' type_label ] .
    329 type_label = type_label_id | type_label_ref .
 \endverbatim
 * Правила и ограничения:
 *
 * a) Тип данных GENERIC_ENTITY должен использоваться только в качестве типа формального
 * параметра функции или процедуры либо типа результата функции, либо типа локальной переменной внутри
 * функции или процедуры, либо представления явного или вычисляемого атрибута в объявлении типа
 * данных ABSTRACT ENTITY.
 *
 * b) Если тип данных GENERIC_ENTITY используется в качестве типа данных результата функции или
 * типа данных локальной переменной внутри функции или процедуры, то для такого применения требуются
 * ссылки меток типов. Ссылки меток типов должны ссылаться на метки типов, объявленные формальными
 * параметрами (см. \ref p11_s9_5_3_4 "9.5.3.4").
 *
 * <B><I>Пример --- Приведенная ниже функция проверяет, имеется ли ссылка на конкретный экземпляр</I>
 * sample <I>от двух экземпляров</I> type1 <I>и</I> type2 <I>известных объектных типов данных. Объявление
 * формального параметра</I> sample, <I>как имеющего тип данных</I> GENERIC_ENTITY, <I>позволяет рассматривать
 * экземпляры любых объектных типов данных как допустимые входные параметры данной функции.</I>
 <PRE>
   FUNCTION check_relating (type1 : instance_of_type_1;
                            type2 : instance_of_type_2;
                            sample : GENERIC_ENTITY) : BOOLEAN ;
     RETURN ( ( type1 IN USEDIN (sample, ' ' ) )
            AND
              ( type2 IN USEDIN (sample, ' ' ) ) );
   END_FUNCTION;
 </PRE>
 * </B>
 *
 * \subsubsection p11_s9_5_3_4 9.5.3.4 Метки типов
 *
 * Метки типов должны использоваться для установления связи между типом данных атрибута или
 * фактического параметра в момент обращения с типами данных других атрибутов или фактических параметров,
 * локальных переменных или возвращаемого значения функции. Метки объявляются для следующих типов
 * данных:
 * - для типов данных <B>AGGREGATE</B>, <B>GENERIC_ENTITY</B> и <B>GENERIC</B> метки объявляются в
 * объявлении формальных параметров функции или процедуры. Впоследствии на них могут ссылаться типы
 * данных <B>AGGREGATE</B>, <B>GENERIC_ENTITY</B> и <B>GENERIC</B> в объявлении формальных параметров или
 * локальных переменных функции или процедуры либо в объявлении типа данных возвращаемого значения
 * функции;
 * - для типов данных <B>AGGREGATE</B> и <B>GENERIC_ENTITY</B> метки объявляются в объявлении явных
 * или вычисляемых атрибутов абстрактных объектов. Впоследствии на них могут ссылаться типы
 * данных <B>AGGREGATE</B> и <B>GENERIC_ENTITY</B> в оставшейся части объявления объектных типов данных.
 *
 \verbatim
   Синтаксис:
    329 type_label = type_label_id | type_label_ref .
 \endverbatim
 * Правила и ограничения:
 *
 * a) Первое появление метки типа в объявлении формального параметра либо явного или
 * вычисляемого атрибута объявляет метку данного типа; последующие случаи употребления данной метки типа
 * являются ссылками на её первое употребление.
 *
 * b) Параметры, переданные функции или процедуре, в которых используется ссылка на метку типа,
 * должны быть совместимы с типом данных переданного параметра, в котором объявлена данная метка типа.
 *
 * c) Типы данных локальных переменных и возвращаемых значений функций, которые ссылаются
 * посредством метки типа на тип данных параметра, должны быть идентичны типу данных параметра, в
 * котором объявлена данная метка типа.
 *
 * d) Типы данных атрибутов, которые ссылаются посредством метки типа на тип данных атрибута,
 * должны быть идентичны типу данных атрибута, в котором объявлена данная метка типа.
 *
 * <BR>
 *
 * <B><I>Пример --- В данном примере показано, как метки типов могут использоваться для проверки
 * совместимости типов данных при вызове функции.</I>
 <PRE>
     ENTITY a;
     ...
     END ENTITY;
     ENTITY b SUBTYPE OF (a);
     ...
     END_ENTITY;
     ENTITY с SUBTYPE OF (b);
     ...
     END_ENTITY;
     ...
     FUNCTION test ( pi: GENERIC:x; p2: GENERIC:x) : GENERIC:x;
     ...     --                  ^              ^            ^
     ...     --                  объявление     ссылка       ссылка
     END_FUNCTION;
     ...
     LOCAL
       v_a : a := a(...);
       v_b : b := a(...) || b(...); -- оператор || определён в \ref p11_s12_10 "12.10"
       v_c : с := a(...) || b(...) || c(...);
       v_x : b;
     END LOCAL;
     v_x := test(v_b, v_a); -- неверный v_a, не совместимый с типом b
     v_x := test(v_a, v_b); -- неверное присваивание, функция вернет тип а
 </PRE>
 * </B>
 *
 * Другие примеры использования меток типов приведены в разделе \ref p11_s15 "15".
 *
 * \subsubsection p11_s9_5_3_5 9.5.3.5 Общие агрегированные типы данных
 *
 * Общие агрегированные типы данных образуют часть класса типов данных, называемых
 * обобщенными типами данных. Общий агрегированный тип данных представляют обобщение
 * соответствующих агрегированных типов данных
 * (\ref express::ARRAY_GENERIC "ARRAY", \ref express::BAG_GENERIC "BAG", \ref express::LIST_GENERIC "LIST" и \ref express::SET_GENERIC "SET"),
 * позволяющее представлять тип
 * данных элемента схемы обобщенным типом данных. То есть элемент <B>general_list_type</B> в
 * приведенном ниже определении синтаксиса является обобщением элемента <B>list_type</B> так же, как и для типов
 * данных \ref express::ARRAY_GENERIC "ARRAY", \ref express::BAG_GENERIC "BAG" и \ref express::SET_GENERIC "SET".
 \verbatim
   Синтаксис:
    224 general_aggregation_types = general_array_type | general_bag_type |
                                    general_list_type | general_set_type .
    225 general_array_type = ARRAY [ bound_spec ] OF [ OPTIONAL ] [ UNIQUE ]
                             parameter_type .
    185 bound_spec = '[' bound_1 ':' bound_2 ']' .
    183 bound_1 = numeric_expression .
    184 bound_2 = numeric_expression .
    266 parameter_type = generalized_types | named_types | simple_types .
    226 general_bag_type = BAG [ bound_spec ] OF parameter_type .
    227 general_list_type = LIST [ bound_spec ] OF [ UNIQUE ] parameter_type .
    229 general_set_type = SET [ bound_spec ] OF parameter_type .
 \endverbatim
 * Общий агрегированный тип данных обобщает соответствующий агрегированный тип следующим
 * образом:
 * - обобщённый массив может быть определён без указания значений индексов. При этом в
 * спецификации формального параметра не указываются границы массива (элемент синтаксиса <B>bound_spec</B>).
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Для определения реальной системы индексирования массива в алгоритмической части
 * должны использоваться функции \ref express::HIINDEX() "HIINDEX" и \ref express::LOINDEX() "LOINDEX";</SMALL>
 *
 * - базисным типом данных может быть <B>GENERIC</B>, <B>GENERIC_ENTITY</B>, <B>AGGREGATE</B> или общий
 * агрегированный тип данных при использовании в качестве формального параметра функции или
 * процедуры либо <B>GENERIC_ENTITY</B>, <B>AGGREGATE</B> или общий агрегированный тип данных при использовании
 * в абстрактном объектном типе данных. Это определено в формализованной форме ниже.
 *
 * Пусть <B>G</B> является общим агрегированным типом данных, а <B>EG</B> — (обобщённым) типом данных
 * его элементов. Пусть для формального параметра функции или процедуры <B>A</B> является типом данных
 * соответствующего фактического параметра; пусть для атрибута абстрактного объектного типа данных
 * <B>A</B> является типом данных повторно объявленного атрибута неабстрактного подтипа и пусть для
 * любого случая <B>EA</B> является типом данных элементов <B>A</B>.
 *
 * Если <B>G</B> является обобщенным массивом, то <B>A</B> должно быть типом данных <B>ARRAY</B>. Если для <B>G</B> задан
 * диапазон индексов, то диапазон индексов <B>A</B> должен быть таким же.
 *
 * Если <B>G</B> является обобщенным пакетом, то <B>A</B> должно быть типом данных <B>BAG</B>. Если для <B>G</B> заданы
 * границы, то границы <B>A</B> должны быть такими же.
 *
 * Если <B>G</B> является обобщенным списком, то <B>A</B> должно быть типом данных <B>LIST</B>. Если для <B>G</B> заданы
 * границы, то границы <B>A</B> должны быть такими же.
 *
 * Если <B>G</B> является обобщенным набором, то <B>A</B> должно быть типом данных <B>SET</B>. Если для <B>G</B> заданы
 * границы, то границы <B>A</B> должны быть такими же.
 *
 * Если <B>G</B> является любым обобщенным типом данных, то <B>EA</B> должно соответствовать <B>EG</B>, как
 * определено в \ref p11_s9_5 "9.5".
 *
 * Если <B>EG</B> не является обобщённым типом данных, то <B>EA</B> должно быть присваиванием, совместимым
 * с <B>EG</B>, как определено в \ref p11_s13_3 "13.3".
 *
 * <BR>
 *
 * <B><I>Пример --- В данном примере показано, как набор (тип данных</I> SET<I>) может быть описан в
 * объявлении формального параметра. Он не может быть описан в объявлении атрибута, поскольку
 * базисный тип данных для</I> SET <I>не включает тип данных</I> GENERIC.</B>
 <PRE>
     FUNCTION dimensions(input: SET [2 : 3] OF GENERIC) : INTEGER
 </PRE>
 *
 * \subsubsection p11_s9_5_4 9.5.4 Локальные переменные
 *
 * Переменные, локальные по отношению к данному алгоритму, объявляются после ключевого слова
 * <B>LOCAL</B>. Локальная переменная видима только в области видимости алгоритма, в котором она объявлена.
 *
 * Локальным переменным могут быть присвоены значения, и они могут присутствовать в выражениях.
 \verbatim
   Синтаксис:
    252 local_decl = LOCAL local_variable { local_variable } END_LOCAL ';' .
    253 local_variable = variable_id { ',' variable_id } ':' parameter_type
                         [ ':= ' expression ] ';' .
    266 parameter_type = generalized_types | named_types | simple_types .
 \endverbatim
 *
 * Инициализация локальных переменных:
 *
 * Локальная переменная может появиться при инициализации другой зависимой локальной
 * переменной. Объявление зависимых локальных переменных должно быть ациклическим. Если никакого
 * начального значения не задано, то локальной переменной присваивается неопределённое (<B>?</B>) значение.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;я
 *
 * 1 Требование ацикличности объявлений локальных переменных необходимо, чтобы всегда
 * обеспечивать существование допустимого начального значения, присваиваемого в порядке следования объявления.
 *
 * 2 Поскольку неопределённое (<B>?</B>) значение совместимо со всеми типами данных, то допустима явная
 * инициализация с неопределённым (<B>?</B>) значением.</SMALL>
 *
 * <BR>
 *
 * <B><I>Пример --- Переменная</I> r_result <I>инициализируется со значением</I> 0.0:
 <PRE>
     LOCAL
       r_result : REAL := 0.0;
       i_result : INTEGER;
     END_LOCAL;
     ...
     EXISTS(r_result) -- TRUE
     EXISTS(i_result) -- FALSE поскольку никакого значения не присвоено
 </PRE> </B>
 *
 * \subsection p11_s9_6 9.6 Правило
 *
 * Правила позволяют определить ограничения, применяемые к одному или нескольким типам данных
 * в пределах области видимости схемы. Локальные правила (к которым относятся ограничения
 * уникальности и правила области видимости в объявлении объектов) объявляют ограничения, применяемые
 * индивидуально к каждому экземпляру объектного типа данных. Объявление <B>RULE</B> позволяет определить
 * ограничения, применяемые в совокупности ко всей области определения объектного типа данных или
 * к экземплярам нескольких объектных типов данных. Одним из применений объявления <B>RULE</B>
 * является скоординированное ограничение значений атрибутов разных объектов.
 *
 * В объявлении правила ему присваивается имя и указываются объекты, на которые оно
 * распространяется.
 *
 * Тело правила состоит из локальных объявлений, исполняемых операторов и правил области
 * определения. Конечное состояние правила показывает, удовлетворяется или нет некоторое глобальное
 * ограничение. Правило оценивается посредством выполнения операторов с последующей оценкой каждого
 * из правил области определения. Если правило нарушено для совокупности экземпляров объектных типов
 * данных, переданных в качестве параметров, то данные экземпляры не соответствуют EXPRESS-схеме.
 \verbatim
   Синтаксис:
    291 rule_decl = rule_head algorithm_head { stmt } where_clause END_RULE ';' .
    292 rule_head = RULE rule_id FOR '(' entity_ref { ',' entity_ref } ')' ';' .
    173 algorithm_head = { declaration } [ constant_decl ] [ local_decl ] .
    199 declaration = entity_decl | function_decl | procedure_decl |
                      subtype_constraint_decl | type_decl .
 \endverbatim 
 *
 * Правила и ограничения:
 *
 * a) Результатом оценки любого правила области определения должно быть логическое (\ref express::LOGICAL "LOGICAL") или
 * неопределённое (<B>?</B>) значение.
 *
 * b) Выражение принимается, если оценкой его значения является \ref express::TRUE "TRUE"; выражение отвергается, если
 * оценкой его значения является \ref express::FALSE "FALSE"; и выражение ни отвергается, ни принимается, если оценкой
 * выражения является неопределённое (<B>?</B>) значение или значение \ref express::UNKNOWN "UNKNOWN".
 *
 * c) Ни одно из правил области определения не должно быть отвергнуто для допустимой совокупности
 * экземпляров объектов объектных типов данных, указанных в заголовке правила.
 *
 * d) Для совокупности экземпляров, принадлежащих допустимой области определения, все
 * глобальные правила, заданные для данной области определения, должны быть приняты. Данное правило
 * относится и к принятию правил для объектных типов данных, для которых не существует экземпляров в
 * совокупности тестируемых экземпляров.
 *
 * <BR>
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Глобальное правило может быть задано для обеспечения существования, по крайней
 * мере, одного экземпляра указанного типа данных. Данное правило не проверяет отсутствие экземпляров
 * указанного объектного типа данных, поддерживающих необходимую семантику.</SMALL>
 *
 * <BR>
 *
 * <B><I>Примеры
 *
 * 1 Следующее правило устанавливает, что в первом и седьмом октантах должно быть
 * одинаковое число точек:</I>
 <PRE>
     RULE point_match FOR (point);
     LOCAL
       first_oct ,
       seventh_oct : SET OF POINT := [ ]; -- пустой набор точек (см. \ref p11_s12_9 "12.9")
     END LOCAL
       first_oct := QUERY(temp <* point | (temp.x > 0) AND
                                          (temp.y > 0) AND
                                          (temp.z > 0) );
       seventh_oct := QUERY(temp <* point | (temp.x < 0) AND
                                            (temp.y < 0) AND
                                            (temp.z < 0) );
     WHERE
       SIZEOF(first_oct) = SIZEOF(seventh_oct);
     END RULE;
 </PRE>
 * <I>2 Правило может быть использовано для задания совокупной уникальности значений атрибутов объекта:</I>
 <PRE>
     ENTITY b;
       a1 : с;
       а2 : d;
       аЗ : f;
     UNIQUE
       ur1 : a1, a2;
     END_ENTITY;
 </PRE>
 * <I>Ограничение совместной уникальности в</I> b <I>применяется к экземплярам</I> c <I>и</I> d<I>. Следующее
 * правило вводит дополнительное ограничение, что совокупная уникальность должна основываться на
 * значениях:</I>
 <PRE>
     RULE vu FOR (b);
       ENTITY temp;
         a1 : c;
         a2 : d;
       END ENTITY;

     LOCAL
       s : SET OF temp := [ ];
     END LOCAL;
     REPEAT i := 1 TO SIZEOF(b);
       s := s + temp(b[i].a1, b[i].a2);
     END REPEAT;
     WHERE
       wrl : VALUE_UNIQUE(s);
     END_RULE;
 </PRE>
 * </B>
 * Неявное объявление.
 *
 * В объявлении <B>RULE</B> каждый синтаксический элемент <B>population</B> неявно объявлен локальной
 * переменной, содержащей множество всех экземпляров именованного объектного типа данных из области
 * определения. Данное множество экземпляров объекта подчиняется данному правилу.
 \verbatim
   Синтаксис:
    267 population = entity_ref .
 \endverbatim
 * Правило: ссылки на конкретный элемент <B>population</B> могут быть сделаны только в глобальном
 * правиле, которое ссылается на соответствующий объектный тип данных в заголовке данного правила.
 *
 * <BR>
 *
 * <B><I>Пример --- При наличии следующего объявления:</I>
 <PRE>
     RULE coincident FOR (point);
 </PRE>
 * <I>неявно объявленная переменная может выглядеть следующим образом:</I>
 <PRE>
    LOCAL
      point : SET OF point;
    END_LOCAL;
 </PRE>
 * </B>
 *
 * \subsection p11_s9_7 9.7 Ограничения подтипов
 *
 * Понятия подтипа и супертипа определены в \ref p11_s9_2_3 "9.2.3". Понятие ограничений подтипов/супертипов
 * определено в \ref p11_s9_2_5 "9.2.5". Существует возможность определить ограничения, в соответствии с которыми графы
 * подтипов/супертипов могут быть реализованы вне объявления объекта. Данная возможность реализуется
 * посредством объявления <B>SUBTYPE_CONSTRAINT</B>.
 \verbatim
   Синтаксис:
    315 subtype_constraint_decl = subtype_constraint_head subtype_constraint_body
                                  END_SUBTYPE_CONSTRAINT ';' .
    316 subtype_constraint_head = SUBTYPE_CONSTRAINT subtype_constraint_ID FOR
                                  entity_ref ';' .
    314 subtype_constraint_body = [ abstract_supertype ] [total_over ]
                                  [ supertype_expression ';' .
    165 abstract_supertype = ABSTRACT SUPERTYPE ' ;' .
    326 total_over = TOTAL_OVER '(' entity_ref { ',' entity_ref } ')' ';' .
    320 supertype_expression = supertype_factor { ANDOR supertype_factor } .
    321 supertype_factor = supertype_term { AND supertype_term } .
    323 supertype_term – entity_ref | one_of | '(' supertype_expression ')' .
    263 one_of = ONEOF '(' supertype_expression { ',' supertype_expression } ')' .
 \endverbatim
 * Объявление <B>SUBTYPE_CONSTRAINT</B> используется для определения следующих ограничений на
 * возможную реализацию подтипов/супертипов:
 * - ограничение, что супертип является абстрактным и должен реализовываться только через свои
 * подтипы;
 * - ограничение, что совокупность подтипов данного супертипа обеспечивает полное покрытие; то есть
 * если полное покрытие задано, то экземпляр любого подтипа данного супертипа должен также быть
 * экземпляром, по крайней мере, одного из подтипов, определённых в спецификации <B>TOTAL_OVER</B>;
 * - ограничение взаимосвязи между некоторыми подтипами.
 *
 * Каждый из этих видов ограничений более детально рассмотрен в последующих пунктах.
 * Формальный подход к определению потенциальных комбинаций подтип/супертип, которые могут быть реализованы
 * при нескольких возможных ограничениях, описанных ниже, представлен в приложении B.
 *
 * \subsubsection p11_s9_7_1 9.7.1 Ограничение абстрактного супертипа
 *
 * Объявление <B>ABSTRACT SUPERTYPE</B>, определённое в \ref p11_s9_2_5_1 "9.2.5.1", может также присутствовать в
 * объявлении <B>SUBTYPE_CONSTRAINT</B>.
 *
 * Правило: абстрактный супертип определяется объявлением <B>SUBTYPE_CONSTRAINT</B> в супертипе
 * с использованием ключевых слов <B>ABSTRACT SUPERTYPE</B>.
 *
 * <B><I>Пример --- В общей классификационной модели может потребоваться идентифицировать
 * объект с именем</I> class<I>, который в данном контексте является реализуемым. В более специфичной
 * модели может потребоваться использовать объект</I> class<I>, но ограничить его так, чтобы он мог
 * быть реализован только через свои локально объявленные подтипы.</I>
 <PRE>
     SCHEMA general_classification_model;
     ENTITY class;
       name : class_name;
     END_ENTITY;
     END_SCHEMA;
     SCHEMA specific_classification_model;
     USE FROM general_classification_model;
     ENTITY class_of_facility;
       SUBTYPE OF (class);
     END_ENTITY;
     ENTITY class_of_organization
       SUBTYPE OF (class);
     END_ENTITY;
     SUBTYPE_CONSTRAINT independent_classification FOR class;
       ABSTRACT SUPERTYPE;
       ONEOF(class_of_facility, class_of_organization);
     END_SUBTYPE_CONSTRAINT;
     END_SCHEMA;
 </PRE>
 * </B>
 *
 * \subsubsection p11_s9_7_2 9.7.2 Подтипы полного покрытия
 *
 * Ограничение полного покрытия <B>TOTAL_OVER</B> устанавливает, что каждый экземпляр супертипа
 * должен быть экземпляром одного или нескольких заданных множеств подтипов. Другими словами, для
 * заданного контекста область определения супертипа в точности совпадает с объединением множеств областей
 * определения именованных подтипов.
 *
 * <B><I>Пример --- Понятие личность полностью покрывается понятиями мужчина и женщина. Могут
 * существовать и другие понятия, но любая личность является либо мужчиной, либо женщиной.
 * Поэтому можно сказать, что супертип person (личность) полностью покрывается подтипами</I>
 * male <I>(мужчина) и</I> female <I>(женщина).</I></B>
 *
 * Если в двух или более ограничениях подтипов заданы ограничения <B>TOTAL_OVER</B> для одного и того
 * же объектного типа данных, то такие ограничения <B>TOTAL_OVER</B> рассматриваются совместно. Это
 * означает, что оба ограничения <B>TOTAL_OVER (a,b)</B> и <B>TOTAL_OVER (c,d)</B> должны выполняться.
 *
 * Правила и ограничения:
 *
 * a) Все подтипы, указанные в одном или нескольких ограничениях <B>TOTAL_OVER</B> для заданного
 * супертипа, должны быть непосредственными подтипами данного супертипа.
 *
 * b) Экземпляры других подтипов, как бы эти подтипы ни были определены или ограничены, также
 * должны быть экземплярами одного или нескольких подтипов, указанных в спецификации <B>TOTAL_OVER</B>.
 *
 * c) Поскольку супертип может иметь несколько контекстов, то он также может иметь несколько
 * ограничений <B>TOTAL_OVER</B>.
 *
 * <B><I>Пример --- В данном примере определяется, что объект</I> person <I>может быть объектом</I> male
 * <I>либо объектом</I> female<I>. В примере ничего не говорится о взаимосвязи между объектами</I> male <I>и</I>
 * female<I>, поэтому можно создать экземпляр, который является одновременно как</I> male<I>, так и</I> female<I>.
 * Подтип</I> employee <I>всегда должен сочетаться с понятиями</I> male <I>и</I> female <I>и не может быть реализован
 * независимо от них.</I>
 <PRE>
     ENTITY person;
       name : personal_name;
     END_ENTITY;
     ENTITY male
       SUBTYPE OF (person);
       ...
     END_ENTITY;
     ENTITY female
       SUBTYPE OF (person);
       ...
     END_ENTITY;
     ENTITY employee
       SUBTYPE OF (person);
       ...
     END_ENTITY;
     SUBTYPE_CONSTRAINT person_sex FOR person;
       ABSTRACT SUPERTYPE;
       TOTAL_OVER (male, female);
     END_SUBTYPE_CONSTRAINT;
 </PRE>
 * </B>
 *
 * \subsubsection p11_s9_7_3 9.7.3 Перекрывающиеся подтипы и их спецификация
 *
 * Два или несколько непосредственных подтипов конкретного супертипа могут иметь
 * перекрывающиеся реализации для конкретного контекста. Спецификация <B>SUBTYPE_CONSTRAINT</B> может быть
 * использована для определения того, какие отношения установлены в конкретной группе непосредственных подтипов.
 *
 * \subsubsection p11_s9_7_3_1 9.7.3.1 ONEOF
 *
 * Ограничение ONEOF, определённое в \ref p11_s9_2_5_2 "9.2.5.2", может быть объявлено в ограничении
 * SUBTYPE_CONSTRAINT.
 *
 * <B><I>Пример --- Экземпляр супертипа может быть порожден посредством реализации только
 * одного из своих подтипов. Данное ограничение объявляется с использованием ограничений</I> ABSTRACT
 * <I>и</I> ONEOF<I>. Существует много видов животных (объект</I> pet<I>), но ни один объект</I> pet <I>не может быть
 * одновременно двумя или более видами животных.</I>
 <PRE>
  ENTITY pet
    name : pet_name;
    ...
  END_ENTITY;
  SUBTYPE_CONSTRAINT separate_species FOR pet;
    ABSTRACT SUPERTYPE;
    ONEOF(cat, rabbit, dog, ... );
  END_SUBTYPE_CONSTRAINT;
  ENTITY cat
    SUBTYPE OF (pet);
    ...
  END_ENTITY;
  ENTITY rabbit
    SUBTYPE OF (pet);
    ...
  END_ENTITY;
  ENTITY dog
    SUBTYPE OF (pet);
    ...
  END_ENTITY;
 </PRE>
 * </B>
 *
 * \subsubsection p11_s9_7_3_2 9.7.3.2 ANDOR
 *
 * Ограничение <B>ANDOR</B>, определённое в \ref p11_s9_2_5_3 "9.2.5.3", может быть объявлено в ограничении
 * <B>SUBTYPE_CONSTRAINT</B>.
 *
 * <B><I>Пример --- Личность (объект</I> person<I>) может быть работником (объект</I> employee<I>), посещающим
 * вечерние курсы, и поэтому может быть одновременно и работником и студентом (объект</I> student<I>).</I>
 <PRE>
     ENTITY person
     ...
     END_ENTITY;
     SUBTYPE_CONSTRAINT employee_may_be_student FOR person;
       employee ANDOR student;
     END_SUBTYPE_CONSTRAINT;
     ENTITY employee
       SUBTYPE OF (person);
       ...
     END_ENTITY;
     ENTITY student
       SUBTYPE OF (person);
       ...
     END_ENTITY;
 </PRE>
 * </B>
 *
 * \subsubsection p11_s9_7_3_3 9.7.3.3 AND
 *
 * Ограничение <B>AND</B>, определённое в \ref p11_s9_2_5_4 "9.2.5.4", может быть объявлено в ограничении
 * <B>SUBTYPE_CONSTRAINT</B>.
 *
 * <B><I>Пример --- Личность (объект</I> person<I>) может быть классифицирована как мужчина (объект</I>
 * male<I>) или как женщина (объект</I> female<I>), но также может быть классифицирована как гражданин
 * (объект</I> citizen<I>) или иностранец (объект</I> alien<I>).</I>
 <PRE>
     ENTITY person
     ...
     END_ENTITY;
     SUBTYPE_CONSTRAINT no_mixing FOR person;
       SUPERTYPE OF
         (ONEOF(male, female) AND
          ONEOF(citizen, alien));
     END_SUBTYPE_CONSTRAINT;
     ENTITY male
       SUBTYPE OF (person);
       ...
     END_ENTITY;
     ENTITY female
       SUBTYPE OF (person);
       ...
     END_ENTITY;
     ENTITY citizen
       SUBTYPE OF (person);
       ...
     END_ENTITY;
     ENTITY alien
       SUBTYPE OF (person);
       ...
     END_ENTITY;
 </PRE>
 * </B>
 *
 * \section p11_s10 10 Область видимости и видимость
 *
 * В языке EXPRESS объявление создаёт идентификатор, который может быть использован для ссылок
 * на объявленный элемент в других частях данной схемы (или в других схемах). В некоторых конструкциях
 * языка EXPRESS неявно объявляются элементы языка с присваиванием им идентификаторов. Считается,
 * что в тех местах, где может указываться ссылка на идентификатор объявленного элемента, данный
 * объявленный элемент является видимым. На элемент может быть дана ссылка только там, где его идентификатор
 * является видимым. Правила видимости определены в \ref p11_s10_2 "10.2". Более подробная информация о ссылках на
 * элементы с использованием их идентификаторов приведена в \ref p11_s12_7 "12.7".
 *
 * Совокупность элементов языка EXPRESS образует область (блок) текста, называемый областью
 * видимости данного элемента. Данная область видимости ограничивает видимость объявленных в ней
 * идентификаторов. Области видимости могут быть вложенными, то есть элемент языка EXPRESS, имеющий свою
 * область видимости, может быть включен в область видимости другого элемента. Существуют ограничения,
 * в соответствии с которыми элементы могут появляться в области видимости конкретного элемента языка
 * EXPRESS. Данные ограничения, как правило, определяются синтаксисом языка EXPRESS (см. приложение А).
 *
 * Для каждого из элементов языка, представленных в \ref p11_table9 "таблице 9", в последующих подразделах
 * установлены границы его области видимости (при её существовании) и видимость объявленного идентификатора
 * как в общих терминах, так и с конкретными деталями.
 *
 * \subsection p11_s10_1 10.1 Правила области видимости
 *
 * Ниже приведены общие правила, применимые ко всем формам определения области видимости,
 * допустимым в языке EXPRESS. Перечень элементов языка, определяющих области видимости, приведен
 * в \ref p11_table9 "таблице 9".
 *
 * Правила и ограничения:
 *
 * a) Все объявления должны существовать в области видимости.
 *
 * b) В одной области видимости идентификатор может быть объявлен или в явной форе включен (см.
 * раздел \ref p11_s11 "11") только один раз. Идентификатор объекта или типа данных, который был в явной форме включен
 * в данную схему по двум или более маршрутам, основанным на одном исходном объявлении, учитывается
 * только один раз.
 *
 * c) Области видимости должны быть вложены корректно, то есть области видимости не должны
 * перекрываться (это диктуется синтаксисом языка).
 *
 * Максимально допустимая глубина вложения не устанавливается настоящим стандартом, но в
 * реализациях синтаксических анализаторов языка EXPRESS может задаваться максимальная глубина вложения
 * областей видимости.
 *
 * \anchor p11_table9
 * Т&nbsp;а&nbsp;б&nbsp;л&nbsp;и&nbsp;ц&nbsp;а 9 --- Области действия и идентификаторы, определяющие элементы языка
 *
 * <TABLE border="1" cellpadding="4" cellspacing="0">
 * <tr><td>Элемент языка                </td><td><CENTER>Область видимости</CENTER></td><td><CENTER>Идентификатор</CENTER>            </td></tr>
 * <tr><td>Оператор альтернативных имен </td><td><CENTER>\f$ \bullet \f$</CENTER>   </td><td><CENTER>\f$ \bullet ^{1)} \f$</CENTER>   </td></tr>
 * <tr><td>Атрибут                      </td><td>                                   </td><td><CENTER>\f$ \bullet \f$</CENTER>         </td></tr>
 * <tr><td>Константа                    </td><td>                                   </td><td><CENTER>\f$ \bullet \f$</CENTER>         </td></tr>
 * <tr><td>Перечисление                 </td><td>                                   </td><td><CENTER>\f$ \bullet \f$</CENTER>         </td></tr>
 * <tr><td>Объект                       </td><td><CENTER>\f$ \bullet \f$</CENTER>   </td><td><CENTER>\f$ \bullet \f$</CENTER>         </td></tr>
 * <tr><td>Функция                      </td><td><CENTER>\f$ \bullet \f$</CENTER>   </td><td><CENTER>\f$ \bullet \f$</CENTER>         </td></tr>
 * <tr><td>Параметр                     </td><td>                                   </td><td><CENTER>\f$ \bullet \f$</CENTER>         </td></tr>
 * <tr><td>Процедура                    </td><td><CENTER>\f$ \bullet \f$</CENTER>   </td><td><CENTER>\f$ \bullet \f$</CENTER>         </td></tr>
 * <tr><td>Выражение <B>QUERY</B>       </td><td><CENTER>\f$ \bullet \f$</CENTER>   </td><td><CENTER>\f$ \bullet ^{1)} \f$</CENTER>   </td></tr>
 * <tr><td>Оператор цикла               </td><td><CENTER>\f$ \bullet \f$</CENTER>   </td><td><CENTER>\f$ \bullet ^{1),2)}\f$</CENTER> </td></tr>
 * <tr><td>Правило                      </td><td><CENTER>\f$ \bullet \f$</CENTER>   </td><td><CENTER>\f$ \bullet ^{3)} \f$</CENTER>   </td></tr>
 * <tr><td>Метка правила                </td><td>                                   </td><td><CENTER>\f$ \bullet \f$</CENTER>         </td></tr>
 * <tr><td>Схема                        </td><td><CENTER>\f$ \bullet \f$</CENTER>   </td><td><CENTER>\f$ \bullet \f$</CENTER>         </td></tr>
 * <tr><td>Ограничение подтипа          </td><td><CENTER>\f$ \bullet \f$</CENTER>   </td><td><CENTER>\f$ \bullet \f$</CENTER>         </td></tr>
 * <tr><td>Тип                          </td><td><CENTER>\f$ \bullet \f$</CENTER>   </td><td><CENTER>\f$ \bullet \f$</CENTER>         </td></tr>
 * <tr><td>Метка типа                   </td><td>                                   </td><td><CENTER>\f$ \bullet \f$</CENTER>         </td></tr>
 * <tr><td>Переменная                   </td><td>                                   </td><td><CENTER>\f$ \bullet \f$</CENTER>         </td></tr>
 * <tr><td colspan="3">
 * \f$ ^{1)} \f$ Идентификатором является неявно объявленная переменная в определённой области видимости объявления.
 *
 * \f$ ^{2)} \f$ Переменная объявляется неявно только тогда, когда установлен инкрементный контроль.
 *
 * \f$ ^{3)} \f$ Неявное объявление переменной осуществляется для всех объектов, ограниченных данным правилом.
 * </td></tr>
 * </TABLE>
 *
 * \subsection p11_s10_2 10.2 Правила видимости
 *
 * Ниже определены правила видимости для идентификаторов. Перечень элементов языка EXPRESS,
 * объявляющих идентификаторы, представлен в \ref p11_table9 "таблице 9".
 *
 * Правила и ограничения:
 *
 * a) Идентификатор виден в области видимости, в которой он объявлен. Эта область видимости
 * называется локальной областью видимости идентификатора.
 *
 * b) Если идентификатор виден в некоторой области видимости, то он также виден во всех областях
 * видимости, определённых внутри данной области, с учетом правила по перечислению d).
 *
 * c) Идентификатор не виден в любой области видимости вне его локальной области видимости, с
 * учётом правила по перечислению f).
 *
 * d) Если идентификатор <B><I>i</I></B>, видимый в области видимости <B><I>P</I></B>, повторно объявлен в некоторой внутренней
 * области видимости <B><I>Q</I></B>, вложенной в <B><I>P</I></B>, то:
 * - если <B><I>i</I></B>, объявленный в <B><I>P</I></B>, ссылается на именованный тип данных или на метку типа, а <B><I>i</I></B>, объявленный
 * в <B><I>Q</I></B>, не ссылается на именованный тип данных или на метку типа, то, как <B><I>i</I></B>, объявленный в <B><I>P</I></B>, так и <B><I>i</I></B>,
 * объявленный в <B><I>Q</I></B>, являются видимыми в <B><I>Q</I></B>;
 * - в противном случае, только <B><I>i</I></B>, объявленный в <B><I>Q</I></B>, является видимым в <B><I>Q</I></B> и в любых областях
 * видимости, объявленных в <B><I>Q</I></B>. Идентификатор <B><I>i</I></B>, объявленный в <B><I>P</I></B>, будет виден в <B><I>P</I></B> и во всех внутренних областях
 * видимости, в которых <B><I>i</I></B> не объявляется повторно.
 *
 * e) Встроенные константы, функции, процедуры и типы данных языка EXPRESS считаются
 * объявленными в виртуальной всеобщей области видимости. Все схемы являются вложенными в данную
 * область видимости. Идентификаторы, ссылающиеся на встроенные константы, функции, процедуры, типы
 * данных языка EXPRESS и схемы, являются видимыми во всех областях видимости, определённых в
 * языке EXPRESS.
 *
 * f) Идентификаторы элементов перечисления, объявленные в области видимости определённого типа
 * данных, являются видимыми там, где данный определённый тип данных является видимым, за
 * исключением случая, когда внешняя область видимости содержит объявление того же идентификатора для
 * какоголибо другого элемента.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Если следующая внешняя область видимости содержит объявление того же
 * идентификатора, то элементы перечисления остаются доступными, но к ним должен быть добавлен в качестве префикса
 * идентификатор определённого типа данных (см. \ref p11_s12_7_2 "12.7.2").</SMALL>
 *
 * g) Объявления из одной схемы становятся видимыми для элементов другой схемы посредством
 * спецификации интерфейса (см. \ref p11_s11 "раздел 11").
 *
 * <B><I>Пример --- В следующей схеме показаны примеры идентификаторов и ссылок, являющихся
 * допустимыми в соответствии с приведенными выше правилами.</I>
 <PRE>
     SCHEMA example;
       CONSTANT
         b : INTEGER := 1 ;
         с : BOOLEAN := TRUE ;
       END_CONSTANT;
       TYPE enum = ENUMERATION OF ( e, f, g );
       END_TYPE;
       ENTITY entity1;
         a : INTEGER;
       WHERE
         wr1: a > 0 ;  -- "entity1.wr1" подчиняется правилу по перечислению а):
                       -- идентификатор "а" виден в локальной области видимости
         wr2: a <> b ; -- "entity1.wr2" подчиняется правилу по перечислению b):
                       -- идентификатор "b" виден из внешней области видимости
       END_ENTITY;
       ENTITY entity2;
       с : REAL;       -- "entity2.c" подчиняется правилу по перечислению c):
                       -- константа "с" не видима здесь
       END_ENTITY;
       ENTITY d;
         attr1 : INTEGER;
         attr2 : enum;
       WHERE
         wr1: ODD(attr1); -- "d.wr1" подчиняется правилу по перечислению d):
                          -- функция ODD видима везде
         wr2: attr2 <> e; -- "d.wr2" подчиняется правилу по перечислению e):
                          -- идентификатор "e" виден вне области видимости,
                          -- определённой типом данных enum
       END_ENTITY;
     END SCHEMA
 </PRE>
 * </B>
 *
 * \subsection p11_s10_3 10.3 Правила для явных элементов
 *
 * В данном разделе более подробно определено, как общие правила областей действия и видимости
 * применяются к разным элементам языка EXPRESS.
 *
 * \subsubsection p11_s10_3_1 10.3.1 Оператор альтернативных имен ALIAS
 *
 * Определение оператора <B>ALIAS</B> дано в \ref p11_s13_2 "13.2".
 *
 * Видимость: идентификатор, неявно объявленный в операторе <B>ALIAS</B>, является видимым в области
 * видимости, определённой данным оператором.
 *
 * Область видимости: оператор <B>ALIAS</B> определяет новую область видимости. Данная область
 * видимости размещается от ключевого слова <B>ALIAS</B> до ключевого слова <B>END_ALIAS</B>, которым завершается
 * данный оператор альтернативных имен.
 *
 * \subsubsection p11_s10_3_2 10.3.2 Атрибут
 *
 * Видимость: идентификатор атрибута является видимым в областях видимости объекта, в которой он
 * объявлен, и всех подтипов данного объекта.
 *
 * \subsubsection p11_s10_3_3 10.3.3 Константа
 *
 * Видимость: идентификатор константы является видимым в области видимости функции, процедуры,
 * правила или схемы, в которой он объявлен.
 *
 * \subsubsection p11_s10_3_4 10.3.4 Элемент перечисления
 *
 * Видимость: идентификатор элемента перечисления является видимым во всех областях видимости,
 * в которых является видимым определённый тип данных, в котором объявлен данный элемент
 * перечисления, за исключением случая, когда такая внешняя область видимости содержит объявление такого же
 * идентификатора для какого-либо другого элемента.
 *
 * \subsubsection p11_s10_3_5 10.3.5 Объект
 *
 * Видимость: идентификатор объекта является видимым в области видимости функции, процедуры,
 * правила или схемы, в которой он объявлен. Идентификатор объекта остаётся видимым при условиях,
 * определённых в \ref p11_s10_2 "10.2", во внутренних областях видимости, в которых данный идентификатор объявлен
 * повторно.
 *
 * Область видимости: объявление объекта определяет новую область видимости. Данная область
 * видимости размещается от ключевого слова <B>ENTITY</B> до ключевого слова <B>END_ENTITY</B>, которым завершается
 * объявление данного объекта. Атрибуты, объявленные в супертипе объекта, являются видимыми в объекте
 * подтипа по принципу наследования.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Область видимости объекта подтипа не считается вложенной в область видимости
 * супертипа.</SMALL>
 *
 * Объявления: следующие элементы языка EXPRESS могут объявлять идентификаторы, видимые в
 * области видимости объявления объекта:
 * - атрибут (явный, вычисляемый и инверсный);
 * - метка правила (правил уникальности и области определения).
 *
 * <B><I>Примеры
 *
 * 1 Идентификаторы атрибута</I> batt <I>в двух объектах не конфликтуют, поскольку они объявлены
 * в двух разных областях видимости.</I>
 <PRE>
     ENTITY entity1;
       aatt : INTEGER;
       batt : INTEGER;
     END_ENTITY;
     ENTITY entity2;
       a : entity1;
       batt : INTEGER;
     END_ENTITY;
 </PRE>
 * <I>2 Приведенная ниже спецификация недопустима, поскольку идентификатор атрибута</I> aatt
 * <I>одновременно и наследуется, и объявляется в области видимости объекта</I> illegal (см. \ref p11_s9_2_3_3 "9.2.3.3"). <I>Метки
 * правила</I> lab <I>в двух объектах не конфликтуют, поскольку они объявлены в разных областях
 * видимости; допустимый экземпляр объекта</I> illegal<I>, игнорирующий ошибку с атрибутом</I> aatt<I>, подчиняется
 * обоим правилам области определения.</I>
 <PRE>
     ENTITY may_be_ok;
       quantity : REAL;
       aatt : REAL;
     WHERE
       lab : quantity >= 0.0;
     END_ENTITY;
     ENTITY illegal
       SUBTYPE OF (may_be_ok);
       aatt : INTEGER;
       batt : INTEGER;
     WHERE
       lab : batt < 0;
     END_ENTITY;
 </PRE>
 * </B>
 *
 * \subsubsection p11_s10_3_6 10.3.6 Функция
 *
 * Видимость: идентификатор функции является видимым в области видимости функции, процедуры,
 * правила или схемы, в которой он объявлен.
 *
 * Область видимости: объявление функции определяет новую область видимости. Данная область
 * видимости размещается от ключевого слова <B>FUNCTION</B> до ключевого слова <B>END_FUNCTION</B>,
 * которым завершается объявление данной функции.
 *
 * Объявления: следующие элементы языка EXPRESS могут объявлять идентификаторы, видимые в
 * области видимости объявления функции:
 * - константа;
 * - объект;
 * - перечисление;
 * - функция;
 * - параметр;
 * - процедура;
 * - тип;
 * - метка типа;
 * - переменная.
 *
 * <B><I>Пример --- Приведённый ниже фрагмент некорректен, поскольку идентификатор формального
 * параметра</I> parm <I>используется одновременно и как идентификатор локальной переменной.</I>
 <PRE>
     FUNCTION illegal(parm : REAL) : LOGICAL;
     LOCAL
       parm : STRING;
     END_LOCAL;
        ...
     END_FUNCTION
 </PRE>
 * </B>
 *
 * \subsubsection p11_s10_3_7 10.3.7 Параметр
 *
 * Видимость: идентификатор формального параметра является видимым в области видимости функции
 * или процедуры, в которой он объявлен.
 *
 * \subsubsection p11_s10_3_8 10.3.8 Процедура
 *
 * Видимость: идентификатор процедуры является видимым в области видимости функции, процедуры,
 * правила или схемы, в которой он объявлен.
 *
 * Область видимости: объявление процедуры определяет новую область видимости. Данная
 * область видимости размещается от ключевого слова <B>PROCEDURE</B> до ключевого слова <B>END_PROCEDURE</B>,
 * которым завершается объявление процедуры.
 *
 * Объявления: следующие элементы языка EXPRESS могут объявлять идентификаторы в области
 * видимости объявления процедуры:
 * - константа;
 * - объект;
 * - перечисление;
 * - функция;
 * - параметр;
 * - процедура;
 * - тип;
 * - метка типа;
 * - переменная.
 *
 * \subsubsection p11_s10_3_9 10.3.9 Выражение QUERY
 *
 * Выражение \ref express::QUERY() "QUERY" определено в \ref express::QUERY() "12.6.7".
 *
 * Видимость: идентификатор, неявно объявленный в выражении \ref express::QUERY() "QUERY", является видимым в области
 * видимости, определённой данным выражением.
 *
 * Область видимости: выражение \ref express::QUERY() "QUERY" определяет новую область видимости.
 * Данная область видимости размещается от открывающей круглой скобки '<B>(</B>', следующей за ключевым словом
 * \ref express::QUERY() "QUERY", до закрывающей круглой скобки '<B>)</B>', которой завершается данное выражение
 * \ref express::QUERY() "QUERY".
 *
 * \subsubsection p11_s10_3_10 10.3.10 Оператор цикла
 *
 * Оператор цикла <B>REPEAT</B> определён в \ref p11_s13_9 "13.9".
 *
 * Видимость: идентификатор, неявно объявленный в инкрементно управляемом операторе цикла,
 * является видимым в области видимости данного оператора цикла.
 *
 * Область видимости: оператор цикла определяет новую область видимости. Данная область
 * видимости размещается от ключевого слова <B>REPEAT</B> до ключевого слова <B>END_REPEAT</B>,
 * которым завершается оператор цикла.
 *
 * \subsubsection p11_s10_3_11 10.3.11 Правило
 *
 * Видимость: идентификатор правила является видимым в области видимости схемы, в которой он
 * объявлен.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Идентификатор правила может использоваться в реализациях или в метке
 * комментария (см. \ref p11_s7_1_6_3 "7.1.6.3").</SMALL>
 *
 * Область видимости: объявление правила определяет новую область видимости. Данная область
 * видимости размещается от ключевого слова <B>RULE</B> до ключевого слова <B>END_RULE</B>, которым завершается
 * объявление данного правила.
 *
 * Объявления: следующие элементы языка EXPRESS могут объявлять идентификаторы в области
 * видимости объявления правила:
 * - константа;
 * - объект;
 * - перечисление;
 * - функция;
 * - процедура;
 * - метка правила;
 * - тип;
 * - переменная.
 *
 * <B><I>Пример --- Приведённый ниже фрагмент некорректен, поскольку идентификатор</I> point<I>,
 * относящийся к объекту, на который распространяется правило, неявно объявлен как переменная в данном
 * правиле и, кроме того, явно объявлен как локальная переменная.</I>
 <PRE>
     RULE illegal FOR (point);
     LOCAL
       point : STRING;
     END_LOCAL;
     ...
     END_RULE;
 </PRE>
 * </B>
 *
 * \subsubsection p11_s10_3_12 10.3.12 Метка правила
 *
 * Видимость: метка правила является видимой в области видимости объекта, правила или типа, в
 * которой она объявлена.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Метка правила может использоваться в реализациях и в метке комментария
 * (см. \ref p11_s7_1_6_3 "7.1.6.3").</SMALL>
 *
 * \subsubsection p11_s10_3_13 10.3.13 Схема
 *
 * Видимость: идентификатор схемы является видимым для всех других схем.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Совместимая реализация может обеспечивать механизм обобщения областей
 * видимости, позволяющий рассматривать совокупность схем как область видимости.</SMALL>
 *
 * Область видимости: объявление схемы определяет новую область видимости. Данная область
 * видимости размещается от ключевого слова <B>SCHEMA</B> до ключевого слова <B>END_SCHEMA</B>, которым
 * завершается объявление данной схемы.
 *
 * Объявления: следующие элементы языка EXPRESS могут объявлять идентификаторы в области
 * видимости объявления схемы:
 * - константа;
 * - объект;
 * - перечисление;
 * - функция;
 * - процедура;
 * - правило;
 * - ограничение подтипа;
 * - тип.
 *
 * <B><I>Пример --- Приведенный ниже фрагмент некорректен по двум причинам. Во-первых,
 * идентификатор</I> adef <I>импортирован в схему посредством оператора</I> USE<I>, но повторно объявлен как имя типа.
 * Во-вторых, имя</I> fdef <I>использовано как идентификатор в двух объявлениях (относящихся к объекту и
 * к функции, хотя тип элемента является несущественным).</I>
 <PRE>
     SCHEMA incorrect;
     USE FROM another_schema (adef);
       FUNCTION fdef(parm : NUMBER) : INTEGER;
       ...
       END_FUNCTION;
       TYPE adef = STRING;
       END_TYPE;
       ENTITY fdef;
       ...
       END_ENTITY;
     END_SCHEMA;
 </PRE>
 * </B>
 *
 * \subsubsection p11_s10_3_14 10.3.14 Ограничение подтипа
 *
 * Видимость: идентификатор ограничения подтипа является видимым в области видимости схемы, в
 * которой он объявлен.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Идентификатор ограничения подтипа может использоваться в реализациях и в
 * метке комментария (см. \ref p11_s7_1_6_3 "7.1.6.3").</SMALL>
 *
 * Область видимости: ограничение подтипа расширяет область видимости объекта, для которого он
 * объявлен. Данное расширение области видимости размещается от ключевого слова <B>SUBTYPE_CONSTRAINT</B>
 * до ключевого слова <B>END_SUBTYPE_CONSTRAINT</B>, которым завершается объявление данного ограничения подтипа.
 *
 * \subsubsection p11_s10_3_15 10.3.15 Тип
 *
 * Видимость: идентификатор типа является видимым в области видимости функции, процедуры,
 * правила или схемы, в которой он объявлен. Идентификатор типа остаётся видимым при условиях,
 * определённых в \ref p11_s10_2 "10.2", во внутренних областях видимости, в которых данный идентификатор объявляется
 * повторно.
 *
 * Область видимости: объявление типа создаёт новую область видимости. Данная область видимости
 * размещается от ключевого слова <B>TYPE</B> до ключевого слова <B>END_TYPE</B>, которым завершается объявление
 * данного типа.
 *
 * Объявления: следующие элементы языка EXPRESS могут объявлять идентификаторы, видимые в
 * области видимости объявления типа:
 * - перечисление;
 * - метка правила (правило области определения).
 *
 * \subsubsection p11_s10_3_16 10.3.16 Метка типа
 *
 * Видимость: метка типа является видимой в области видимости объекта и всех подтипов данного
 * объекта, функции или процедуры, в которой она объявлена. Метка типа неявно объявляется при первом её
 * появлении в области видимости. В функциях и процедурах первое появление метки типа должно иметь
 * место в спецификации формального параметра. На объявленную таким образом метку типа можно
 * ссылаться где-либо в другом месте в спецификации формального параметра или в локальных объявлениях
 * функции или процедуры. Если метка типа объявлена в функции, то на метку типа можно ссылаться в
 * спецификации типа результата функции.
 *
 * \subsubsection p11_s10_3_17 10.3.17 Переменная 
 *
 * Видимость: идентификатор переменной является видимым в области видимости функции, процедуры
 * или правила, в которой он объявлен.
 *
 * \section p11_s11 11 Спецификация интерфейсов
 *
 * В данном разделе определены конструкции, позволяющие элементам, объявленным в одной схеме,
 * быть видимыми в другой схеме. Существуют две спецификации интерфейсов (<B>USE</B> и <B>REFERENCE</B>),
 * обеспечивающие видимость элементов. Спецификация интерфейса <B>USE</B> позволяет элементам, объявленным в
 * одной схеме, получить независимую реализацию в схеме, в которой определена конструкция <B>USE</B>.
 *
 * Экземпляр объекта считается независимым, если он не играет роль, предписанную атрибутом любого
 * другого экземпляра объекта, то есть функция \ref express::ROLESOF() "ROLESOF" (см. \ref express::ROLESOF() "15.20"),
 * примененная к независимому экземпляру объекта,
 * выдаст в качестве результата пустое множество. Тип данных объекта, объявленного в схеме
 * локально или с использованием интерфейса USE, может быть реализован независимо или играть роль,
 * предписанную атрибутом объекта в данной схеме.
 *
 * Объект, объявленный посредством интерфейса <B>REFERENCE</B> или неявного интерфейса, должен быть
 * реализован только для выполнения роли, предписанной атрибутом реализации объекта в схеме.
 \verbatim
   Синтаксис:
    242 interface_specification = reference_clause | use_clause .
 \endverbatim
 * Внешним объявлением является любое объявление (например, объекта), присутствующее во
 * внешней схеме (в любой схеме, отличной от данной схемы).
 *
 * Другое различие между двумя формами интерфейса состоит в том, что интерфейс <B>USE</B> применим
 * только к именованным типам данных (объектным типам данных и определённым типам данных), а
 * интерфейс <B>REFERENCE</B> применим ко всем объявлениям, за исключением правил и схем.
 *
 * Внешнему элементу языка EXPRESS в данной схеме может быть присвоено новое имя. На внешний
 * элемент языка EXPRESS в данной схеме следует ссылаться по его новому имени, если оно задано
 * после ключевого слова <B>AS</B>.
 *
 * \subsection p11_s11_1 11.1 Спецификация интерфейса USE
 *
 * Объектный или определённый тип данных, объявленный во внешней схеме, может быть сделан
 * доступным в данной схеме посредством интерфейса <B>USE</B>. Спецификация интерфейса <B>USE</B> задаёт имя
 * внешней схемы и, факультативно, объявленные в ней имена объектных или определённых типов данных. Если
 * не указан элемент <B>named_types</B>, то все именованные типы данных, объявленные явно или посредством
 * интерфейса <B>USE</B> во внешней схеме, трактуются как объявленные локально в данной схеме.
 \verbatim
   Синтаксис:
    336 use_clause = USE FROM schema_ref [ '(' named_type_or_rename
                     { ',' named_type_or_rename } ')' ] ';' .
    259 named_type_or_rename = named_types [ AS ( entity_id | type_id ) ] 
 \endverbatim
 *
 * \subsection p11_s11_2 11.2 Спецификация интерфейса REFERENCE
 *
 * Спецификация интерфейса <B>REFERENCE</B> позволяет сделать видимыми в данной схеме следующие
 * элементы языка EXPRESS, объявленные во внешней схеме:
 * - константа;
 * - объект;
 * - функция;
 * - процедура;
 * - тип.
 *
 * Спецификация интерфейса <B>REFERENCE</B> задаёт имя внешней схемы и, факультативно,
 * объявленные в ней имена элементов языка EXPRESS. Если имена не заданы, то все элементы языка EXPRESS,
 * объявленные явно или посредством интерфейса <B>USE</B> во внешней схеме, являются видимыми в данной
 * схеме.
 \verbatim
   Синтаксис:
    281 reference_clause = REFERENCE FROM schema_ref [ '(' resource_or_rename
                           { ',' resource_or_rename } ')' ] ';' .
    288 resource_or_rename = resource_ref [ AS rename_id ] .
    289 resource_ref = constant_ref | entity_ref | function_ref | procedure_ref | type_ref .
    284 rename_id = constant_id | entity_id | function_id | procedure_id | type_id .
 \endverbatim
 * Внешние объявления, введенные посредством интерфейса <B>REFERENCE</B>, не считаются локальными
 * объявлениями и поэтому не могут быть реализованы независимо, но могут быть реализованы для
 * выполнения роли, предписанной атрибутом объекта в данной схеме.
 *
 * \subsection p11_s11_3 11.3 Взаимодействие интерфейсов USE и REFERENCE
 *
 * Если объектный или определённый тип данных в данной схеме одновременно указан в
 * спецификациях интерфейсов <B>USE</B> и <B>REFERENCE</B>, то спецификация интерфейса <B>USE</B> имеет приоритет.
 *
 * <B><I>Пример --- В следующем фрагменте</I> a1 <I>трактуется как локальное объявление:</I>
 <PRE>
     USE FROM s1 (a1);
     REFERENCE FROM s1 (a1);
 </PRE>
 * </B>
 * Если именованный тип данных импортирован в данную схему посредством интерфейса <B>USE</B>, то
 * данный именованный тип данных может быть импортирован другой схемой из данной схемы посредством
 * интерфейсов <B>USE</B> или <B>REFERENCE</B> (это означает, что спецификации интерфейсов <B>USE</B> могут связывать
 * схемы в цепочки).
 *
 * <B><I>Пример --- Пусть заданы следующие объявления двух схем:</I>
 <PRE>
     SCHEMA s1;
       ENTITY e1;
       END_ENTITY;
     END SCHEMA;
     SCHEMA s2;
     USE FROM s1 (e1 AS e2);
     END_SCHEMA;
 </PRE>
 * <I>тогда следующие спецификации эквивалентны:</I>
 <PRE>
     SCHEMA s3;                      SCHEMA s3;
     USE FROM s1 (e1 AS e2);         USE FROM s2 (e2);
     END_SCHEMA;                     END_SCHEMA;
 </PRE>
 * </B>
 * Поскольку элементы языка EXPRESS, импортированные посредством интерфейса <B>REFERENCE</B>,
 * не трактуются как локально объявленные элементы, то связывание схем в цепочки посредством
 * интерфейсов <B>REFERENCE</B> невозможно.
 *
 * \subsection p11_s11_4 11.4 Импорт объектов посредством неявных интерфейсов
 *
 * Внешнее объявление может ссылаться на идентификаторы, которые не являются видимыми в
 * данной схеме. Такие элементы языка EXPRESS, на которые даны неявные ссылки, требуются для полного
 * понимания данной схемы, но они не видимы для элементов языка EXPRESS, объявленных в данной
 * схеме. Каждый импортированный неявно элемент может в свою очередь ссылаться на другие элементы
 * языка EXPRESS, которые не являются видимыми в данной схеме; такие элементы языка EXPRESS
 * также требуются для полного понимания данной схемы.
 *
 * <B><I>Пример --- Неявно импортированные элементы и связывание неявных интерфейсов в цепочки.</I>
 <PRE>
     SCHEMA s1;
       TYPE t1 = REAL;
       END_TYPE;
       ENTITY e1;
         a : t1;
       END_ENTITY;
       ENTITY e2;
         a1 : e1;
       END_ENTITY;
     END_SCHEMA;
     SCHEMA s2;
       REFERENCE FROM s1 (e2);
       ENTITY е3;
         а3 : е2;
       END_ENTITY;
     END_SCHEMA;
 </PRE>
 * <I>Объект</I> е2 <I>используется как тип данных атрибута</I> а3<I>. Поскольку в определении объекта</I> е2
 * <I>требуется</I> e1<I>, то объект</I> e1 <I>неявно импортируется схемой</I> s2<I>. Однако поскольку</I> e1 <I>не был
 * импортирован в схему</I> s2 <I>в явной форме, то</I> e1 <I>не может использоваться в схеме</I> s2<I>. Аналогично, в определении
 * объекта</I> e1 <I>требуется</I> t1<I>; поэтому</I> t1 <I>неявно импортируется схемой</I> s2<I>.</I></B>
 *
 * В последующих пунктах термин «импортирован» используется для обозначения понятий
 * «импортирован посредством интерфейса <B>USE</B>», «импортирован посредством интерфейса <B>REFERENCE</B>» или «неявно
 * импортирован».
 *
 * \subsubsection p11_s11_4_1 11.4.1 Импорт констант
 *
 * При импорте константы неявно импортируются:
 * - любые определённые типы данных, использованные в объявлении импортируемой константы;
 * - любые объектные типы данных, использованные в объявлении импортируемой константы;
 * - любые константы, использованные в объявлении импортируемой константы;
 * - любые функции, использованные в объявлении импортируемой константы.
 *
 * \subsubsection p11_s11_4_2 11.4.2 Импорт определённых типов данных
 *
 * При импорте определённого типа данных неявно импортируются:
 * - любые определённые типы данных, использованные в объявлении импортируемого типа, включая
 * наращиваемые определённые типы данных, которые данный импортируемый тип может расширять,
 * используя ключевое слово <B>BASED_ON</B>, но исключая любой из выбираемых элементов, если импортируемым
 * типом является тип данных \ref express::SELECT "SELECT", а также исключая те выбираемые элементы выбираемых типов
 * данных, на которых может основываться данный импортируемый тип;
 * - любые константы или функции, использованные в объявлении представления импортируемого
 * определённого типа данных;
 * - любые константы или функции, использованные в правилах области определения импортируемого
 * определённого типа данных;
 * - любые определённые типы данных, представленные типом данных \ref express::SELECT "SELECT",
 * список выбора которого содержит импортируемый определённый тип данных.
 *
 * <B><I>Пример --- Неявный импорт определённого типа данных через тип данных</I> \ref express::SELECT "SELECT"<I>.</I>
 <PRE>
     SCHEMA s1;
       TYPE sel1 = SELECT (e1, t1);
       END_TYPE;
       TYPE t1 = INTEGER;
       END_TYPE;
       ENTITY e1;
       ...
       END_ENTITY;
     END_SCHEMA;
     SCHEMA s2;
     REFERENCE FROM s1 (t1);
     END_SCHEMA;
 </PRE>
 * <I>Схема</I> s2 <I>содержит явную ссылку на</I> t1<I>, а поскольку</I> sel1 <I>представлен типом данных</I> SELECT,
 * <I>содержащим</I> t1<I>, то на</I> sel1 <I>делается неявная ссылка.</I></B>
 *
 * \subsubsection p11_s11_4_3 11.4.3 Импорт объектных типов данных
 *
 * При импорте объектного типа данных неявно импортируются:
 * - все объектные типы данных, являющиеся супертипами данного импортируемого объектного типа
 * данных.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Подтипы импортируемого объектного типа данных, независимо от того, присутствуют
 * ли они в выражении <B>SUPERTYPE OF</B>, не будут импортированы неявно в результате установления данного
 * интерфейса для импорта;</SMALL>
 *
 * - все правила, ссылающиеся на импортируемый объектный тип данных и, возможно, на другие
 * объектные типы данных, которые все явно или неявно импортированы в данную схему;
 * - все ограничения подтипов для импортируемого объектного типа данных;
 * - любые константы, определённые типы данных, объектные типы данных или функции,
 * использованные в объявлении атрибутов импортируемого объектного типа данных;
 * - любые константы, определённые типы данных, объектные типы данных или функции,
 * использованные в правилах области определения импортируемого объектного типа данных;
 * - любые определённые типы данных, представленные типом данных \ref express::SELECT "SELECT", содержащем
 * импортируемый объектный тип данных в своём списке выбора.
 *
 * В графах подтипов/супертипов могут быть отсечены ветви только в результате следования по связям,
 * задаваемым ключевым словом <B>SUBTYPE OF</B>, при группировке неявных интерфейсов импортируемого
 * объектного типа данных. Алгоритм, используемый для вычисления допустимых реализаций усечённого
 * графа подтипов/супертипов, приведен в приложении С.
 *
 * \subsubsection p11_s11_4_4 11.4.4 Импорт функций
 *
 * При импорте функций неявно импортируются:
 * - любые определённые типы данных или объектные типы данных, использованные в объявлении
 * параметров для импортируемой функции;
 * - любые определённые типы данных или объектные типы данных, использованные в определении
 * возвращаемого типа данных для импортируемой функции;
 * - любые определённые типы данных или объектные типы данных, использованные в объявлении
 * локальных переменных в импортируемой функции;
 * - любые константы, функции или процедуры, использованные в импортируемой функции.
 *
 * \subsubsection p11_s11_4_5 11.4.5 Импорт процедур
 *
 * При импорте процедуры неявно импортируются:
 * - любые определённые типы данных или объектные типы данных, использованные в объявлении
 * параметров для импортируемой процедуры;
 * - любые определённые типы данных или объектные типы данных, использованные в объявлении
 * локальных переменных в импортируемой процедуре;
 * - все константы, функции или процедуры, использованные в импортируемой процедуре.
 *
 * \subsubsection p11_s11_4_6 11.4.6 Импорт правил
 *
 * При импорте правила неявно импортируются:
 * - любые определённые типы данных или объектные типы данных, использованные в объявлении
 * локальных переменных в импортируемом правиле;
 * - все константы, функции или процедуры, использованные в импортируемом правиле.
 *
 * \subsubsection p11_s11_4_7 11.4.7 Импорт ограничений подтипов
 *
 * При импорте ограничения подтипов объекты не импортируются неявным образом.
 *
 * Ограничения, заданные в импортируемом ограничении подтипов, преобразовываются после
 * импортирования так, чтобы не допустить реализацию в данной схеме какого-либо сложного объектного типа
 * данных, который не был разрешен в исходной внешней схеме (см. приложение C).
 *
 * \section p11_s12 12 Выражения
 *
 * Выражения являются комбинациями операторов, операндов и вызовов функций, которые
 * вычисляются для получения некоторого значения.
 \verbatim
   Синтаксис:
    216 expression = simple_expression [ rel_op_extended simple_expression ] .
    283 rel_op_extended = rel_op | IN | LIKE .
    282 rel_op = '<' | '>' | '<=' | '>=' | '<>' | '=' | ':<>:' | ':= :' .
    305 simple_expression = term { add_like_op term } .
    325 term = factor { multiplication_like_op factor } .
    217 factor = simple_factor [ '**' simple_factor ] .
    306 simple_factor = aggregate_initializer | entity_constructor |
                        enumeration_reference | interval | query_expression |
                        ( [ unary_op ] ( '( ' expression ')' | primary ) ) .
    331 unary_op = '+' | '-' | NOT .
    269 primary = literal | ( qualifiable_factor { qualifier } ) .
    257 multiplication_like_op = '*' | '/ ' | DIV | MOD | AND | '||' .
    168 add_like_op = '+' | '-' | OR | XOR .
 \endverbatim
 * Некоторым операторам требуется один операнд, а другим --- два операнда. Оператор, которому
 * требуется только один операнд, должен располагаться перед своим операндом. Оператор, которому
 * требуются два операнда, должен располагаться между своими операндами. В данном разделе
 * определены операторы и установлены типы данных операндов, которые могут использоваться каждым оператором.
 *
 * Существует семь классов операторов:
 *
 * a) Арифметические операторы принимают числовые операнды и выдают числовые результаты. Тип
 * данных значения результата арифметического оператора зависит от оператора и типов данных
 * операндов (см. \ref p11_s12_1 "12.1").
 *
 * b) Операторы отношения принимают в качестве операндов разные типы данных и выдают результаты,
 * имеющие тип данных \ref express::LOGICAL "LOGICAL"
 * (\ref express::TRUE "TRUE", \ref express::FALSE "FALSE" или \ref express::UNKNOWN "UNKNOWN").
 *
 * c) Двоичные операторы принимают операнды типа данных \ref express::BINARY "BINARY" и выдают результаты, имеющие
 * тоже тип данных \ref express::BINARY "BINARY".
 *
 * d) Логические операторы принимают операнды типа данных \ref express::LOGICAL "LOGICAL" и
 * выдают результаты, имеющие тоже тип данных \ref express::LOGICAL "LOGICAL".
 *
 * e) Строковые операторы принимают операнды типа данных \ref express::STRING "STRING" и
 * выдают результаты, имеющие тоже тип данных \ref express::STRING "STRING".
 *
 * f) Агрегированные операторы комбинируют агрегированные значения с другими агрегированными
 * значениями или с отдельными элементами разными способами и выдают результаты агрегированного типа.
 *
 * g) Ссылочные и индексные операторы извлекают компоненты из экземпляров объектов и
 * агрегированных значений.
 *
 * Вычисление выражений осуществляется в соответствии с приоритетом входящих в выражение операторов.
 *
 * Значение выражения, заключенного в круглые скобки, вычисляется до того, как оно будет
 * трактоваться как единый операнд.
 *
 * Процесс вычисления осуществляется слева направо, при этом операторы с более высоким
 * приоритетом вычисляются первыми. Правила приоритетов для всех операторов языка EXPRESS установлены в
 * \ref p11_table10 "таблице 10". Операторы в одной строке имеют одинаковый приоритет, а строки упорядочены по уменьшению
 * приоритета.
 *
 * Операнд, расположенный между двумя операторами, имеющими разные приоритеты, относится к
 * оператору, имеющему более высокий приоритет. Операнд, расположенный между двумя операторами с
 * одинаковым приоритетом, относится к оператору, расположенному слева.
 *
 * \anchor p11_table10
 * Т&nbsp;а&nbsp;б&nbsp;л&nbsp;и&nbsp;ц&nbsp;а 10 --- Приоритет операторов
 *
 * <TABLE border="1" cellspacing="0">
 * <tr><td><CENTER>Приоритет</CENTER></td><td><CENTER>Описание</CENTER> </td><td><CENTER>Операторы</CENTER>             </td></tr>
 * <tr><td></td><td></td><td></td></tr>
 * <tr><td><CENTER>1</CENTER>        </td><td> Ссылки на элементы       </td><td><B> [ ]</B> . \\                       </td></tr>
 * <tr><td><CENTER>2</CENTER>        </td><td> Унарные операторы        </td><td><B> + - NOT</B>                        </td></tr>
 * <tr><td><CENTER>3</CENTER>        </td><td> Возведение в степень     </td><td><B> ** </B>                            </td></tr>
 * <tr><td><CENTER>4</CENTER>        </td><td> Умножение/деление        </td><td><B> * / DIV MOD AND || </B>            </td></tr>
 * <tr><td><CENTER>5</CENTER>        </td><td> Сложение/вычитание       </td><td><B> - + OR XOR </B>                    </td></tr>
 * <tr><td><CENTER>6</CENTER>        </td><td> Отношение                </td><td><B> = <> <= >= < > :=: :<>: IN LIKE</B></td></tr>
 * <tr><td colspan="3">
 * Примечание --- <B>||</B> является оператором построения сложного объекта.</td></tr>
 * </TABLE>
 *
 * <B><I>Пример --- Выражение</I> –10**2 <I>вычисляется как</I> (–10)**2<I>, давая в результате значение</I> 100.
 * <I>Выражение</I> 10/20*30 <I>вычисляется как</I> (10/20)*30<I>, давая в результат значение</I> 15.0.</B>
 *
 * \subsection p11_s12_1 12.1 Арифметические операторы
 *
 * Арифметическими операторами, которым требуется один операнд, являются тождество (<B>+</B>) и
 * отрицание (<B>-</B>). Операнд должен иметь числовой тип
 * (\ref express::NUMBER "NUMBER", \ref express::INTEGER "INTEGER" или \ref express::REAL "REAL"). Результат оператора (<B>+</B>) равен
 * операнду, результат оператора (<B>-</B>) имеет знак, противоположный знаку операнда. Если операнд имеет
 * неопределённое (<B>?</B>) значение, то результат также будет иметь неопределённое (<B>?</B>) значение для обоих
 * операторов.
 *
 * Арифметическими операторами, которым требуются два операнда, являются сложение (<B>+</B>), вычитание
 * (<B>-</B>), умножение (<B>*</B>), деление (<B>/</B>), возведение в степень (<B>**</B>), целочисленное деление (<B>DIV</B>) и деление по
 * модулю (<B>MOD</B>). Операнды должны иметь числовой тип
 * (\ref express::NUMBER "NUMBER", \ref express::INTEGER "INTEGER" или \ref express::REAL "REAL").
 *
 * Операторы сложения, вычитания, умножения, деления и возведения в степень выполняют одноименные
 * математические операции. За исключением деления, они выдают целочисленный результат, если оба
 * операнда имеют тип данных \ref express::INTEGER "INTEGER", и результат типа \ref express::REAL "REAL"
 * --- в остальных случаях [если при этом ни
 * один из операндов не имеет неопределённого (<B>?</B>) значения]. Результатом оператора деления (<B>/</B>) является
 * действительное число [если при этом ни один из операндов не имеет неопределённого (<B>?</B>) значения].
 *
 * Деление по модулю (<B>MOD</B>) и целочисленное деление (<B>DIV</B>) дают целочисленный результат [если при
 * этом ни один из операндов не имеет неопределённого (<B>?</B>) значения]. Если какой-либо операнд имеет тип
 * данных \ref express::REAL "REAL", то перед выполнением данного оператора его значение преобразуется в значение типа
 * \ref express::INTEGER "INTEGER" усечением, то есть его дробная часть отбрасывается. Для любых целых чисел <B>а</B> и <B>b</B> всегда
 * справедливо равенство <B>(a DIV b) *b + c *(a MOD b) = а</B>, где <B>c = 1</B> для <B>b >= 0</B> и <B>c = –1</B> для <B>b < 0</B>.
 * Абсолютное значение выражения <B>a MOD b</B> должно быть меньше, чем абсолютное значение <B>b</B>, а знак
 * выражения <B>a MOD b</B> должен совпадать со знаком <B>b</B>.
 *
 * Если какой-либо из операндов арифметического оператора имеет неопределённое (<B>?</B>) значение, то
 * результат оператора должен иметь неопределённое (<B>?</B>) значение.
 *
 * Округление действительных чисел.
 *
 * Когда требуется округление, оно осуществляется с точностью <I>р</I> (либо заданной в явном виде для
 * типа данных \ref express::REAL "REAL", либо определяемой ограничением для конкретной реализации, устанавливаемым в
 * соответствии с приложением Е) по следующему алгоритму:
 *
 * a) преобразовать представление числа в экспоненциальный формат с удалением всех предшествующих нулей;
 *
 * b) установить указатель разряда <I>k</I> на <I>р</I>-ю позицию справа от десятичной точки;
 *
 * c) если действительное число является положительным, то выполняются следующие действия:
 * - если цифра, расположенная на позиции <I>k</I>, принадлежит к диапазону от 5 до 9, то добавить 1
 * к цифре, расположенной на позиции <I>k</I>-1, а цифры, начиная с позиции <I>k</I> и далее, отбросить. Перейти к шагу
 * по перечислению e);
 * - если цифра, расположенная на позиции <I>k</I>, принадлежит к диапазону от 0 до 4, то цифры, начиная
 * с позиции <I>k</I> и далее, отбросить. Перейти к шагу по перечислению h);
 *
 * d) если действительное число является отрицательным, то выполняются следующие действия:
 * - если цифра, расположенная на позиции <I>k</I>, принадлежит к диапазону от 6 до 9, то добавить 1 к
 * цифре, расположенной на позиции <I>k</I>–1, а цифры, начиная с позиции <I>k</I> и далее, отбросить. Перейти к шагу
 * по перечислению e);
 * - если цифра, расположенная на позиции <I>k</I>, принадлежит к диапазону от 0 до 5, то цифры, начиная
 * с позиции <I>k</I> и далее, отбросить. Перейти к шагу по перечислению h);
 *
 * e) присвоить указателю разряда <I>k</I> значение <I>k</I>–1;
 *
 * f) если цифра, расположенная на позиции <I>k</I>, принадлежит к диапазону от 0 до 9, то перейти к шагу по
 * перечислению h);
 *
 * g) если цифра, расположенная на позиции k, имеет значение 10, то добавить 1 к цифре, расположенной
 * на позиции <I>k</I>–1, и установить цифру, расположенную на позиции <I>k</I>, в 0. Перейти к шагу по
 * перечислению e);
 *
 * h) округление действительного числа завершено.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * В результате действия данного алгоритма число 0,5 округляется до 1, а число –0,5
 * округляется до 0.</SMALL>
 *
 * <B><I>Пример --- Данный пример показывает результат задания числа значащих цифр в дробной части
 * действительного числа, то есть его точности.</I>
 <PRE>
     LOCAL
       distance : REAL(6);
       x1, y1, z1 : REAL;
       x2, y2, z2 : REAL;
     END_LOCAL;
     ...
     x1 := 0.; y1 := 0.; z1 := 0.;
     x2 := 10.; y2 := 11.; z2 := 12.;
     ...
     distance := SQRT( (x2–x1)**2 + (y2–y1)**2 + (z2–z1)**2);
 </PRE>
 * <I>Вычисленное значение объекта distance равно</I> 1.9104973...e+1<I>, но, его реальным значением
 * будет</I> 1.91050е+1<I>, поскольку в спецификации данного объекта задана точность, равная шести
 * значащим цифрам, поэтому будут оставлены только шесть значащих цифр.</I></B>
 *
 * \subsection p11_s12_2 12.2 Операторы отношений
 *
 * К операторам отношений относятся операторы сравнения значений, сравнения экземпляров,
 * принадлежности (<B>IN</B>) и сопоставления строк (<B>LIKE</B>). Результатом вычисления выражения отношения является
 * значение типа \ref express::LOGICAL "LOGICAL"
 * (\ref express::TRUE "TRUE", \ref express::FALSE "FALSE" или \ref express::UNKNOWN "UNKNOWN"). Если хотя бы один из
 * операндов имеет неопределённое (<B>?</B>) значение, то выражению присваивается значение \ref express::UNKNOWN "UNKNOWN".
 *
 * \subsubsection p11_s12_2_1 12.2.1 Операторы сравнения значений
 *
 * К операторам сравнения значений относятся:
 * - равно (<B>=</B>);
 * - не равно (<B><></B>);
 * - больше чем (<B>></B>);
 * - меньше чем (<B><</B>);
 * - больше или равно (<B>>=</B>);
 * - меньше или равно (<B><=</B>).
 *
 * Данные операторы могут применяться к числовым, логическим, строковым и двоичным операндам.
 * Кроме того, данные операторы могут применяться к элементам перечислений, объявленным в
 * перечислениях, не являющихся наращиваемыми перечислениями и не основанными на наращиваемых
 * перечислениях. Помимо этого, операторы <B>=</B> и <B><></B> могут применяться к значениям агрегированного и объектного типов
 * данных и к элементам перечислений, объявленным в наращиваемых перечислениях или в перечислениях,
 * основанных на наращиваемых перечислениях (см. \ref p11_s12_11 "12.11").
 *
 * Для двух заданных значений <B>a</B> и <B>b</B> выражения <B>a <> b</B> и <B>NOT (а = b)</B> эквивалентны для всех типов
 * данных. Кроме того, если <B>a</B> и <B>b</B> не являются агрегированными или объектными типами данных, то
 * справедливы следующие утверждения:
 * - одно из следующих выражений имеет значение \ref express::TRUE "TRUE": <B>a < b</B>, <B>a = b</B> или <B>а > b</B>;
 * - выражение <B>a <= b</B> эквивалентно выражению <B>(а < b) OR (a = b)</B>;
 * - выражение <B>а >= b</B> эквивалентно выражению <B>(а > b) OR (a = b)</B>.
 *
 * \subsubsection p11_s12_2_1_1 12.2.1.1 Сравнение чисел
 *
 * Операторы сравнения значений, примененные к числовым операндам, должны соответствовать
 * математическому упорядочению действительных чисел.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * При сравнении двух действительных чисел спецификация их точности не
 * учитывается.</SMALL>
 *
 * <B><I>Пример</I> --- <I>Пусть задано:</I>
 <PRE>
     а : REAL(3) := 1.23
     b : REAL(5) := 1.2300;
 </PRE>
 * <I>тогда значением выражения</I> а = b <I>будет</I> TRUE.</B>
 *
 * \subsubsection p11_s12_2_1_2 12.2.1.2 Сравнение двоичных чисел
 *
 * При сравнении двух двоичных чисел сравниваются биты, расположенные в одинаковых позициях
 * каждого числа, начиная с первой (самой левой) пары битов, затем — биты во второй позиции и так далее до
 * тех пор, пока не встретится пара несовпадающих битов или не будут проверены все пары. Если
 * встретилась пара несовпадающих битов, то меньшим считается двоичное число, бит которого равен 0. Никакого
 * дополнительного сравнения не требуется. Если пара несовпадающих битов не встретилась, то меньшим
 * считается более короткое двоичное число (длина двоичного числа определяется с помощью функции
 * \ref express::BLENGTH() "BLENGTH"). Если сравниваемые двоичные числа имеют одинаковую длину и все пары их битов совпадают,
 * то данные двоичные числа равны.
 *
 * \subsubsection p11_s12_2_1_3 12.2.1.3 Сравнение логических значений
 *
 * При сравнении двух значений типа \ref express::LOGICAL "LOGICAL" (или \ref express::BOOLEAN "BOOLEAN")
 * должен соблюдаться следующий порядок значений:
 *
 * <B>FALSE < UNKNOWN < TRUE</B>
 *
 * \subsubsection p11_s12_2_1_4 12.2.1.4 Сравнение строковых значений
 *
 * При сравнении двух строковых значений сравниваются символы, расположенные в одинаковых
 * позициях каждого строкового значения, начиная с первой (самой левой) пары символов, затем --- символы,
 * расположенные во второй позиции, и так далее до тех пор, пока не встретится пара несовпадающих
 * символов или не будут проверены все пары символов. Если встретилась пара несовпадающих символов, то
 * меньшим считается строковое значение, содержащее символ с меньшим значением кода (в соответствии
 * с определением значений октетов для символов по ИСО/МЭК 10646). Никакого дополнительного сравнения
 * не требуется. Если пара несовпадающих символов не встретилась, то меньшим считается более короткое
 * строковое значение (длина строкового значения определяется с помощью функции \ref express::LENGTH() "LENGTH"). Если
 * сравниваемые строковые значения имеют одинаковую длину, и все пары их символов совпадают, то данные
 * строковые значения равны.
 *
 * \subsubsection p11_s12_2_1_5 12.2.1.5 Сравнение элементов перечисления
 *
 * Сравнение значений элементов перечисления, которое не является наращиваемым и не основано на
 * наращиваемом перечислении, основано на их относительных позициях в объявлении перечисляемого типа
 * данных. См. правило по перечислению d) в \ref express::ENUMERATION "8.4.1".
 *
 * Для значений, тип данных которых является наращиваемым перечисляемым типом или перечисляемым
 * типом, основанном на наращиваемом перечисляемом типе, определено только сравнение на
 * равенство или неравенство. Два таких значения равны, если они представляют один и тот же элемент
 * перечисления, и не равны --- в противном случае.
 *
 * \subsubsection p11_s12_2_1_6 12.2.1.6 Сравнение агрегированных значений
 *
 * Операторами сравнения значений, установленными для агрегированных значений, являются
 * операторы «равно» (<B>=</B>) и «не равно» (<B><></B>). Два агрегированных значения могут
 * сравниваться только в том случае, если их типы данных совместимы (см. \ref p11_s12_11 "12.11").
 *
 * При сравнении агрегированных структур должно проверяться число элементов в каждом из
 * операндов: если справедливо выражение <B>SIZEOF (а) <> SIZEOF (b)</B>, то агрегированные структуры не равны. При
 * сравнении агрегированных структур сравниваются элементы агрегированного значения путём сравнения
 * значений. Если результатом какого-либо сравнения элементов является \ref express::FALSE "FALSE", то результатом сравнения
 * агрегированных структур является также \ref express::FALSE "FALSE". Если результатом одного или нескольких сравнений
 * элементов при сравнении агрегированных структур является \ref express::UNKNOWN "UNKNOWN", а результатом остальных сравнений
 * является \ref express::TRUE "TRUE", то результатом сравнения агрегированных структур является \ref express::UNKNOWN "UNKNOWN". Во всех других
 * случаях результатом сравнения агрегированных структур является \ref express::TRUE "TRUE".
 *
 * Определение равенства агрегированных структур зависит от их агрегированных типов данных:
 * - два массива <B>а</B> и <B>b</B> равны тогда и только тогда, когда значение каждого элемента из <B>а</B> равно
 * значению элемента из <B>b</B>, расположенного в той же позиции, то есть <B>a[ i ] = b[ i ]</B> (см. \ref p11_s12_6_1 "12.6.1");
 * - два списка <B>а</B> и <B>b</B> равны тогда и только тогда, когда значение каждого элемента из <B>а</B> равно значению
 * элемента из <B>b</B>, расположенного в той же позиции;
 * - два пакета или набора <B>а</B> и <B>b</B> равны тогда и только тогда, когда каждый элемент <B>VALUE_IN а</B>
 * встречается в <B>VALUE_IN b</B> равное число раз, а каждый элемент <B>VALUE_IN b</B> также встречается в <B>VALUE_IN а</B>
 * равное число раз.
 *
 * \subsubsection p11_s12_2_1_7 12.2.1.7 Сравнение значений объектных типов данных
 *
 * Значения двух экземпляров объектного типа данных являются равными, если равны значения их
 * соответствующих атрибутов. Поскольку экземпляры объектного типа данных могут иметь атрибуты,
 * представленные также объектными типами данных, для таких экземпляров существует возможность ссылаться
 * на самих себя. При этом значения экземпляров объектного типа данных являются равными, если все
 * атрибуты, представленные простыми типами данных, имеют одинаковые значения, и одни и те же атрибуты
 * в обоих экземплярах объектного типа данных ссылаются сами на себя.
 *
 * Для более точного определения предположим, что необходимо сравнить два экземпляра <B>l</B> и <B>r</B>.
 * Если <B>l :=: r</B>, то <B>l = r</B>. Иначе вводят следующие определения:
 * - определют упорядочение на совокупности рассматриваемых экземпляров. На практике такая
 * совокупность конечна, поэтому упорядочение может быть осуществлено;
 * - для целей данного рассмотрения определяют оператор индексирования агрегированной
 * структуры, соблюдающий данное упорядочение так, чтобы для любой агрегированной структуры <B>agg</B> и для
 * любых индексов <B>i</B> и <B>j</B> условие <B>i < j</B> было эквивалентно условию <B>agg[ i ] < agg[ j ]</B>;
 * - определяют ссылочный путь как последовательность одной или нескольких ссылок на атрибуты или
 * индексы. Применение ссылочного пути <B>s</B> к экземпляру <B>i</B> будет записано как <B>s(i)</B>. Тогда <B>s(i)</B> является
 * вычисляемым, если ни одна из ссылок, за исключением последней, не приводит к неопределённости (<B>?</B>).
 *
 * Тогда значение выражения <B>l = r</B> определяют по первому выполненному из следующих условий:
 *
 * a) если <B>TYPEOF(l)<>TYPEOF(r)</B>, то <B>l = r</B> имеет значение \ref express::FALSE "FALSE";
 *
 * b) если существует такой ссылочный путь <B>s</B>, что только один из <B>s(l)</B> и <B>s(r)</B> является вычисляемым, то
 * <B>l = r</B> имеет значение \ref express::FALSE "FALSE";
 *
 * c) если существует такой ссылочный путь <B>s</B>, что результатами как <B>s(l)</B>, так и <B>s(r)</B> являются значения
 * простого типа данных, и если <B>s(l) <> s(r)</B>, то <B>l = r</B> имеет значение \ref express::FALSE "FALSE";
 *
 * d) если существует такой ссылочный путь <B>s</B>, что результатами как <B>s(l)</B>, так и <B>s(r)</B> являются либо
 * значения объектного типа данных, либо объявляется, что они должны быть выбираемого типа данных, и если
 * <B>TYPEOF(s(l)) <> TYPEOF(s(r))</B>, то <B>l = r</B> имеет значение \ref express::FALSE "FALSE";
 *
 * e) если существует такой ссылочный путь <B>s</B>, что <B>NOT EXISTS(s(l))</B> или <B>NOT EXISTS(s(r))</B>, то
 * <B>l = r</B> имеет значение \ref express::UNKNOWN "UNKNOWN";
 *
 * f) в ином случае <B>l = r</B> имеет значение \ref express::TRUE "TRUE".
 *
 * <B><I>Примеры
 *
 * 1 Представленный ниже алгоритм является одной из возможных реализаций описанной выше
 * проверки сравнения значений. Данный алгоритм приведен для иллюстрации и не предназначен для
 * представления какой-либо конкретной реализации.
 *
 * Пусть в данном алгоритме</I> l <I>и</I> r <I>являются переменными типа</I> GENERIC<I>:
 *
 * а) инициализируем</I> l <I>в качестве экземпляра объекта левой части, а</I> r <I>в качестве экземпляра
 * объекта правой части;
 *
 * b) если</I> l <I>и</I> r <I>представляют один и тот же экземпляр, то есть</I> l :=: r<I>, то выражение имеет
 * значение</I> TRUE<I>;
 *
 * c) инициализируем пустой список</I> plist<I>, который будет содержать упорядоченные пары
 * идентификаторов экземпляров объектного типа данных.</I></B>
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Представление идентификаторов экземпляров определяется реализацией;</SMALL>
 *
 * <B><I>d) сравним</I> l <I>и</I> r<I>, используя определённый ниже алгоритм глубинного равенства;
 *
 * e) выражение будет иметь значение, возвращаемое алгоритмом глубинного равенства,
 *
 * Алгоритм глубинного равенства:
 *
 * a) если</I> l, r <I>или оба экземпляра имеют неопределённое (</I>?<I>) значение, то алгоритм возвращает
 * значение</I> UNKNOWN;
 *
 * <I>b) если</I> TYPEOF(l)<>TYPEOF(r)<I>, то алгоритм возвращает значение</I> FALSE<I>;
 *
 * c) если</I> l <I>и</I> r <I>не являются экземплярами объектного типа данных, то алгоритм возвращает
 * результат выражения</I> l = r<I>, используя соответствующую проверку равенства;
 *
 * d) если</I> l <I>и</I> r <I>представляют один и тот же экземпляр объектного типа данных, то есть</I>
 * l :=: r<I>, то алгоритм возвращает значение</I> TRUE;
 *
 * <I>e) если пара экземпляров</I> (l, r) <I>присутствует в списке</I> plist<I>, то алгоритм возвращает значение</I>
 * TRUE;
 *
 * <I>f) если пара экземпляров</I> (l, r) <I>не присутствует в списке</I> plist<I>, то выполняются следующие действия:
 *
 *  1) в список</I> plist <I>добавляется пара</I> (l, r)<I>,
 *
 *  2) для каждого атрибута</I> а<I>, определённого для</I> l <I>и</I> r<I>, сравниваются</I> l.а <I>и</I> r.а <I>с использованием
 * алгоритма глубинного равенства, полагая, что</I> l = l.а <I>и</I> r=r.а.</B>
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * При этом используется рекурсивный вызов,</SMALL>
 *
 * <B><I>3) если результатом алгоритма глубинного равенства для какого-либо из атрибутов на шаге по
 * пункту 2) перечисления е) будет</I> \ref express::FALSE "FALSE"<I>,
 * то в целом алгоритм также возвращает значение</I> \ref express::FALSE "FALSE"<I>.
 * В противном случае, если алгоритм возвращает значение</I> \ref express::UNKNOWN "UNKNOWN" <I>для какого-либо из атрибутов, то
 * общим результатом также будет значение</I> \ref express::UNKNOWN "UNKNOWN". <I>Иначе, алгоритм возвращает значение</I> \ref express::TRUE "TRUE"<I>.</I></B>
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Данный алгоритм обеспечивает, что если хотя бы один из результатов сравнения имеет
 * значение FALSE, то общий результат имеет значение FALSE. Если все результаты сравнения имеют значение
 * TRUE, то общий результат также имеет значение TRUE. Если результат какого-либо сравнения имеет значение
 * UNKNOWN, а все другие результаты имеют значение TRUE, то общий результат имеет значение UNKNOWN.</SMALL>
 *
 * <B><I>2 Локальные переменные</I> i1 <I>и</I> i2 <I>имеют тип</I> loop_of_integer<I>; при выполнении указанных в данном
 * примере операторов присваивания, значения данных переменных не равны.</I>
 <PRE>
     ENTITY loop_of_integer;
       int : INTEGER;
       next : loop_of_integer ;
     END ENTITY;
     ...
     LOCAL
       i1, i2 : loop_of_integer ;
     END LOCAL;
     ...
     i1 := loop_of_integer(5,loop_of_integer(3,SELF));
     i2 := loop_of_integer(3,loop_of_integer(5,SELF));
     IF i1 = i2 THEN -- результатом сравнения является FALSE
 </PRE>
 * </B>
 *
 * Сравнение значений объектов может быть применено к экземплярам объектов и экземплярам
 * сгруппированных объектов (см. \ref p11_s12_7_4 "12.7.4"). Для экземпляров объектов должны сравниваться атрибуты всех
 * подтипов и супертипов сравниваемых экземпляров. Для экземпляров сгруппированных объектов должны
 * сравниваться только атрибуты, объявленные как атрибуты в объявлении объектного типа данных,
 * указанного в квалификаторе группы (это не относится к унаследованным атрибутам, которые повторно объявлены в
 * указанном объектном типе данных).
 *
 * \subsubsection p11_s12_2_2 12.2.2 Операторы сравнения экземпляров
 *
 * Операторами сравнения экземпляров являются:
 *
 * - равенство экземпляров (<B>:=:</B>);
 * - неравенство экземпляров (<B>:<>:</B>).
 *
 * Данные операторы могут применяться к операндам числового, логического, строкового, двоичного,
 * перечисляемого, агрегированного и объектного типов данных. Оба операнда оператора сравнения
 * экземпляров должны быть совместимы по типу данных (см. \ref p11_s12_11 "12.11").
 *
 * Для двух заданных операндов <B>а</B> и <B>b</B>, выражение <B>(а:<>:b)</B> эквивалентно выражению
 * <B>NOT (a:=:b)</B> для всех типов данных.
 *
 * Применение операторов сравнения экземпляров к числовым, логическим, строковым, двоичным и
 * перечисляемым типам данных эквивалентно применению соответствующих операторов сравнения
 * значений. То есть <B>(а:=:b)</B> эквивалентно <B>(а=b)</B>, а <B>(а:<>:b)</B> эквивалентно
 * <B>(а<>b)</B> для указанных типов данных.
 *
 * \subsubsection p11_s12_2_2_1 12.2.2.1 Сравнение экземпляров агрегированных структур
 *
 * Операторами сравнения экземпляров, определёнными для значений агрегированных структур,
 * являются операторы равенства (<B>:=:</B>) и неравенства (<B>:<>:</B>). Два значения агрегированных
 * структур могут сравниваться только в том случае, если совместимы их типы данных (см. \ref p11_s12_11 "12.11").
 *
 * Все сравнения агрегированных структур должны проверять число элементов в каждом из операндов:
 * если <B>SIZEOF(a)<>SIZEOF(b)</B>, то агрегированные структуры не равны. При сравнении агрегированных структур
 * проводится сравнение элементов значений агрегированных структур посредством сравнения
 * экземпляров. Если результатом сравнения каких-либо элементов является значение \ref express::FALSE "FALSE", то результат сравнения
 * агрегированных структур также будет иметь значение \ref express::FALSE "FALSE". Если результатом одного или нескольких
 * сравнений элементов для данного сравнения агрегированных структур является значение \ref express::UNKNOWN "UNKNOWN", а
 * результатом всех остальных сравнений является значение \ref express::TRUE "TRUE", то результатом сравнения
 * агрегированных структур будет значение \ref express::UNKNOWN "UNKNOWN". В противном случае результат сравнения
 * агрегированных структур будет иметь значение \ref express::TRUE "TRUE".
 *
 * Определение равенства экземпляров агрегированных структур зависит от сравниваемых агрегированных типов данных:
 * - два массива <B>a</B> и <B>b</B> равны тогда и только тогда, когда каждый элемент массива <B>a</B> представлен тем же
 * экземпляром, что и элемент массива <B>b</B>, расположенный на той же позиции, то есть <B>a[i] :=: b[i]</B>
 * (см. \ref p11_s12_6_1 "12.6.1");
 * - два списка <B>a</B> и <B>b</B> равны тогда и только тогда, когда каждый элемент списка <B>a</B> представлен тем же
 * экземпляром, что и элемент списка <B>b</B>, расположенный на той же позиции;
 * - экземпляры двух пакетов <B>a</B> и <B>b</B> равны тогда и только тогда, когда каждый элемент из пакета <B>a</B>
 * присутствует такое же число раз в пакете <B>b</B>, а каждый элемент из пакета <B>b</B> также присутствует такое же
 * число раз в пакете <B>a</B>;
 * - экземпляры двух наборов <B>a</B> и <B>b</B> равны тогда и только тогда, когда каждый элемент из набора <B>a</B>
 * присутствует в наборе <B>b</B>, а каждый элемент из набора <B>b</B> присутствует в наборе <B>a</B>;
 * - экземпляр пакета равен экземпляру набора тогда и только тогда, когда каждый элемент из набора
 * присутствует в пакете только один раз, а пакет не содержит элементов, которых нет в наборе.
 *
 * <B><I>Пример --- Сравнение экземпляров двух массивов:</I>
 <PRE>
     LOCAL
       a1, a2 : ARRAY [1 : 10] OF b;
     END LOCAL;
     ...
     IF (a1 :=: a2) THEN ...
 </PRE>
 * </B>
 *
 * \subsubsection p11_s12_2_2_2 12.2.2.2 Сравнение экземпляров объектного типа данных
 *
 * Операторы равенства (<B>:=:</B>) и неравенства (<B>:<>:</B>) экземпляров объектного типа данных сравнивают
 * два совместимых экземпляра объектного типа данных и выдают результат типа \ref express::LOGICAL "LOGICAL".
 *
 * Результатом сравнения <B>a :=: b</B> является значение \ref express::TRUE "TRUE", если <B>a</B> представлен тем же экземпляром
 * объектного типа данных, что и <B>b</B>, то есть их зависящие от реализации идентификаторы одинаковы.
 * Результат сравнения будет иметь значение \ref express::FALSE "FALSE", если <B>a</B> представлен другим экземпляром объектного типа
 * данных, чем <B>b</B>. Результат сравнения будет иметь значение \ref express::UNKNOWN "UNKNOWN", если хотя бы один
 * из операндов имеет неопределённое (<B>?</B>) значение.
 *
 * Если не оговорено иное, то сравнение экземпляров объектного типа данных должно использоваться
 * для сравнения двух экземпляров объектного типа данных, например, при сравнении агрегированных структур
 * и проверке правила уникальности <B>UNIQUE</B>.
 *
 * <B><I>Пример --- Все дети имеют матерей, но некоторые дети могут иметь братьев или сестер.
 * Это моделируется следующим образом:</I>
 <PRE>
     ENTITY child
     SUBTYPE OF (person);
       mother : female; –– мы не рассматриваем более одного поколения
       father : male;
     END ENTITY;

     ENTITY sibling
     SUBTYPE OF (child);
       siblings : SET [1:?] sibling;
     WHERE
                  -- установим, что текущий экземпляр не является
                  -- одним из своих братьев или сестер
     not_identical : SIZEOF ( QUERY ( i <* siblings | i :=: SELF ) ) = 0;
                  -- установим, что каждый из братьев или сестер
                  -- имеет общего отца или мать с текущим экземпляром
     same_parent   : SIZEOF ( QUERY ( i <* siblings |
                                    ( i.mother :=: SELF.mother ) OR
                                    ( i.father :=: SELF.father ) ) =
                   SIZEOF ( siblings ) );
     END_ENTITY;
 </PRE>
 * </B>
 *
 * \copydetails express::IN()
 *
 * \subsubsection p11_s12_2_4 12.2.4 Интервальные выражения
 *
 * Интервальное выражение проверяет, находится ли значение в заданном интервале. Выражение
 * содержит три операнда, которые должны быть совместимыми (см. \ref p11_s12_11 "12.11"). Операнды должны принадлежать к
 * типу данных, имеющему установленное упорядочение, то есть к простым типам (см. \ref p11_s8_1 "8.1") и определённым
 * типам данных, базисными типами которых являются простые либо перечисляемые типы данных.
 \verbatim
   Синтаксис:
    243 interval = '{' interval_low interval_op interval_item interval_op interval_high '}' .
    246 interval_low = simple_expression .
    247 interval_op = '<' | '<=' .
    245 interval_item = simple_expression .
    244 interval_high = simple_expression .
 \endverbatim
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Интервальное выражение:
 *
 * { interval_low interval_op interval_item interval_op interval_high }
 *
 * семантически эквивалентно следующему:
 *
 * (interval_low interval_op interval_item) AND
 *
 * (interval_item interval_op interval_high)
 *
 * Предполагается, что во втором выражении <B>interval_item</B> вычисляется только один раз.</SMALL>
 *
 * Результатом интервального выражения является значение типа \ref express::LOGICAL "LOGICAL", которое имеет
 * значение \ref express::TRUE "TRUE", если результатом обоих операторов отношения является \ref express::TRUE "TRUE".
 * Интервальное выражение имеет значение \ref express::FALSE "FALSE", если результатом любого из операторов отношения
 * является \ref express::FALSE "FALSE", и значение \ref express::UNKNOWN "UNKNOWN", если какой-либо из операндов имеет
 * неопределённое (<B>?</B>) значение.
 *
 * <B><I>Пример --- В данном примере проверяется, имеет ли</I> b <I>значение большeе, чем 5.0, и меньшее или
 * равное</I> 100.0<I>:</I>
 <PRE>
     LOCAL
       b : REAL := 20.0;
     END_LOCAL;
     ...
     IF { 5.0 < b <= 100.0 } THEN -- результатом является TRUE
     ...
 </PRE>
 * </B>
 *
 * \subsubsection p11_s12_2_5 12.2.5 Оператор сопоставления строк
 *
 * Оператор сопоставления строк <B>LIKE</B> сравнивает два строковых значения, используя описанный
 * ниже алгоритм сопоставления с образцом. Результатом оператора <B>LIKE</B> является значение типа
 * \ref express::LOGICAL "LOGICAL". Операнд, расположенный слева от оператора, представляет исследуемую строку.
 * Операнд, расположенный справа от оператора, является эталонной строкой.
 *
 * Алгоритм сопоставления с образцом определяется следующим образом. Каждый символ
 * эталонной строки сравнивается с соответствующим символом (символами) исследуемой строки. Если любая
 * пара соответствующих символов не совпадает, то сопоставление дало отрицательный результат и
 * результатом выражения является значение \ref express::FALSE "FALSE".
 *
 * Некоторые специальные символы в эталонной строке могут сопоставляться с несколькими
 * символами в исследуемой строке. Данные символы определены в \ref p11_table11 "таблице 11". Для того, чтобы результатом
 * выражения было значение \ref express::TRUE "TRUE", все соответствующие символы должны быть идентичными или
 * совпадать (в соответствии с \ref p11_table11 "таблицей 11"). Если какой-либо из операндов имеет неопределённое (<B>?</B>)
 * значение, то выражение имеет значение \ref express::UNKNOWN "UNKNOWN".
 *
 * Если какой-либо из специальных символов сопоставления с образцом сам подлежит сопоставлению,
 * то образец должен содержать эталонную управляющую последовательность. Эталонная управляющая
 * последовательность должна содержать символ начала управляющей последовательности (<B>\\</B>), за которым
 * следует специальный символ, подлежащий сравнению.
 *
 * <B><I>Пример --- Для сопоставления с символом</I> @ <I>используется управляющая последовательность</I> \\@@<I>.</I></B>
 *
 * В приведённых ниже примерах показаны разные символы, сравниваемые с образцом.
 *
 * <B><I>Примеры
 *
 * 1 Если</I> а := '\\АААА'<I>, то справедливо следующее:</I>
 <PRE>
     a LIKE '\\\\AAAA'         --> TRUE
     a LIKE '\\AAAA'          --> FALSE
     a LIKE '\\\\A?AA'         --> TRUE
     a LIKE '\\\\!\\\\AAA'       --> TRUE
     a LIKE '\\\\&'            --> TRUE
     a LIKE '\\$'             --> FALSE
 </PRE>
 * <I>2 Если</I> а := 'The quick red fox';<I>, то справедливо следующее:</I>
 <PRE>
     a LIKE '$$$$'           --> TRUE
 </PRE>
 * <I>3 Если</I> а := 'Page 407 ';<I>, то справедливо следующее:</I>
 <PRE>
     a LIKE '$*'             --> TRUE
 </PRE>
 * </B>
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Символ отрицания (<B>!</B>) может использоваться перед любым символом, а не только
 * перед символами сопоставления с образцом, чтобы сопоставить любой символ, отличающийся от данного
 * символа.</SMALL>
 *
 * \anchor p11_table11
 * Т&nbsp;а&nbsp;б&nbsp;л&nbsp;и&nbsp;ц&nbsp;а 11 --- Символы сопоставления с образцом
 *
 * <TABLE border="1" cellspacing="0">
 * <tr><td><CENTER>Символ   </CENTER></td><td><CENTER>Значение</CENTER>                                                  </td></tr>
 * <tr><td></td><td></td></tr>
 * <tr><td><CENTER><B>@@</B></CENTER></td><td> Сопоставляет любую букву                                                  </td></tr>
 * <tr><td><CENTER><B>^ </B></CENTER></td><td> Сопоставляет любую букву на верхнем регистре                              </td></tr>
 * <tr><td><CENTER><B>? </B></CENTER></td><td> Сопоставляет любой символ                                                 </td></tr>
 * <tr><td><CENTER><B>& </B></CENTER></td><td> Сопоставляет остальную часть строки                                       </td></tr>
 * <tr><td><CENTER><B># </B></CENTER></td><td> Сопоставляет любую цифру                                                  </td></tr>
 * <tr><td><CENTER><B>$ </B></CENTER></td><td> Сопоставляет подстроку, заканчивающуюся символом пробела или конца строки </td></tr>
 * <tr><td><CENTER><B>* </B></CENTER></td><td> Сопоставляет любое число символов                                         </td></tr>
 * <tr><td><CENTER><B>\\</B></CENTER></td><td> Начинает эталонную управляющую последовательность                         </td></tr>
 * <tr><td><CENTER><B>! </B></CENTER></td><td> Символ отрицания (используется с другими символами)                       </td></tr>
 * </TABLE>
 *
 * \subsection p11_s12_3 12.3 Двоичные операторы
 *
 * Помимо операторов отношений, определённых в \ref p11_s12_2_1_2 "12.2.1.2", для типа данных
 * \ref express::BINARY "BINARY" определены ещё два оператора --- индексирования (<B>[ ]</B>) и конкатенации (<B>+</B>).
 *
 * \subsubsection p11_s12_3_1 12.3.1 Индексирование двоичных чисел
 *
 * Оператор индексирования двоичных чисел принимает два операнда --- индексируемое двоичное число
 * и спецификацию индексов, а его результатом является двоичное число длиной, определяемой
 * выражением <B>(index_2 - index_1 + 1)</B>. Полученное в качестве результата двоичное число эквивалентно
 * последовательности битов, расположенных в индексируемом двоичном числе на позициях от <B>index_1</B> до <B>index_2</B>
 * включительно. Если требуется двоичное число единичной длины, то необходимо указать только <B>index_1</B>.
 * Значение индекса, равное 1, указывает на самый левый бит индексируемого двоичного числа.
 \verbatim
   Синтаксис:
    239 index_qualifier = '[' index_1 ':' index_2 ] ']' .
    237 index_1 = index .
    236 index = numeric_expression .
    238 index_2 = index .
 \endverbatim
 * Правила и ограничения:
 *
 * a) Параметр <B>index_1</B> должен быть представлен положительным целым числом или неопределённым
 * (<B>?</B>) значением.
 *
 * b) Должно выполняться условие <B>1 &le; index_1 &le; BLENGTH(двоичное число)</B>, в противном случае,
 * будет возвращено неопределённое (<B>?</B>) значение.
 *
 * c) Если параметр <B>index_2</B> задан, то он должен быть представлен положительным целым числом или
 * неопределённым (<B>?</B>) значением.
 *
 * d) Должно выполняться условие <B>index_1 &le; index_2 &le; BLENGTH(двоичное число)</B>, в противном
 * случае будет возвращено неопределённое (<B>?</B>) значение.
 *
 * e) Если <B>index_1</B> или <B>index_2</B> имеет неопределённое (<B>?</B>) значение, то результатом также будет
 * неопределённое (<B>?</B>) значение.
 *
 * f) Если индексируемое выражение имеет неопределённое (<B>?</B>) значение, то результатом также будет
 * неопределённое (<B>?</B>) значение.
 *
 * <B><I>Примеры
 *
 * 1 Четвёртый бит двоичной переменной</I> image <I>может быть проверен следующим образом:</I>
 <PRE>
     image := %01010101
     IF image [4] = % 1 THEN ... -- результатом является TRUE
     IF image [4 : 4] = %1 THEN ... -- эквивалентное выражение
 </PRE>
 * <I>2 Биты с четвёртого по десятый двоичной переменной</I> image <I>могут быть проверены
 * следующим образом:</I>
 <PRE>
     IF image[4:10] = % 1011110 THEN ...
 </PRE>
 * </B>
 *
 * \subsubsection p11_s12_3_2 12.3.2 Оператор двоичной конкатенации
 *
 * Оператор двоичной конкатенации (<B>+</B>) является двоичным оператором, который последовательно
 * соединяет два двоичных числа. Оба операнда должны быть двоичными числами, а результатом
 * выполнения оператора является двоичное число, содержащее конкатенацию двух операндов, при этом первый
 * операнд расположен слева. Если какой-либо из операндов имеет неопределённое (<B>?</B>) значение, то
 * результатом будет также иметь неопределённое (<B>?</B>) значение.
 *
 * <B><I>Пример --- Двоичные числа могут быть соединены следующим образом:</I>
 <PRE>
     image := %101000101 + %101001;
     (* переменная image теперь содержит двоичное число %101000101101001 *)
 </PRE>
 * </B>
 *
 * \subsection p11_s12_4 12.4 Логические операторы
 *
 * К логическими операторами относятся \ref p11_s12_4_1 "NOT", \ref p11_s12_4_2 "AND", \ref p11_s12_4_3 "OR" и
 * \ref p11_s12_4_4 "XOR". Результатом каждого из данных операторов является логическое значение.
 * Операторам \ref p11_s12_4_2 "AND", \ref p11_s12_4_3 "OR" и \ref p11_s12_4_4 "XOR" требуются два логических
 * операнда, а оператору \ref p11_s12_4_1 "NOT" --- один логический операнд. Если какой-либо из операндов имеет неопределённое
 * (<B>?</B>) значение, то этот операнд рассматривается как имеющий логическое значение \ref express::LOGICAL.UNKNOWN "UNKNOWN".
 *
 * \subsubsection p11_s12_4_1 12.4.1 Оператор NOT
 *
 * Оператору \ref express::LOGICAL::operator!() "NOT" требуется один логический операнд,
 * помещаемый справа от оператора \ref express::LOGICAL::operator!() "NOT".
 * Результатом является логическое значение, формируемое в соответствии с \ref p11_table12 "таблицей 12".
 *
 * <BR>
 *
 * \anchor p11_table12
 * Т&nbsp;а&nbsp;б&nbsp;л&nbsp;и&nbsp;ц&nbsp;а 12 --- Оператор \ref express::LOGICAL::operator!() "NOT"
 *
 * <TABLE border="1" cellspacing="0">
 * <tr><td><CENTER>Операнд</CENTER>       </td><td><CENTER>Результат</CENTER>     </td></tr>
 * <tr><td></td><td></td></tr>
 * <tr><td><CENTER><B>TRUE</B></CENTER>   </td><td><CENTER><B>FALSE</B></CENTER>  </td></tr>
 * <tr><td><CENTER><B>UNKNOWN</B></CENTER></td><td><CENTER><B>UNKNOWN</B></CENTER></td></tr>
 * <tr><td><CENTER><B>FALSE</B></CENTER>  </td><td><CENTER><B>TRUE</B></CENTER>   </td></tr>
 * </TABLE>
 *
 * <BR>
 *
 * \anchor p11_s12_4_2
 * \copydetails express::LOGICAL::operator&&()
 *
 * <BR>
 *
 * \anchor p11_s12_4_3
 * \copydetails express::LOGICAL::operator||()
 *
 * <BR>
 *
 * \anchor p11_s12_4_4
 * \copydetails express::LOGICAL::operator^()
 *
 * <BR>
 *
 * \subsection p11_s12_5 12.5 Строковые операторы
 *
 * Помимо операторов отношений, определённых в \ref p11_s12_2_1_4 "12.2.1.4" и \ref p11_s12_2_5 "12.2.5", для строкового типа данных
 * определены ещё два оператора --- индексирования (<B>[ ]</B>) и конкатенации (<B>+</B>).
 *
 * \subsubsection p11_s12_5_1 12.5.1 Индексирование строк
 *
 * Оператор индексирования строк принимает два операнда --- индексируемую строку и спецификацию
 * индексов, а его результатом является строка с длиной, определяемой выражением <B>(index_2–index_1+1)</B>.
 * Поученная в качестве результата строка эквивалентна последовательности символов, расположенных
 * в индексируемой строке на позициях от <B>index_1</B> до <B>index_2</B> включительно. Если требуется строка
 * единичной длины, то необходимо указать только <B>index_1</B>. Значение индекса, равное 1, указывает на самый
 * левый символ индексируемой строки.
 \verbatim
   Синтаксис:
    239 index_qualifier = '[' index_1 [ ':' index_2 ] ']' .
    237 index_1 = index .
    236 index = numeric_expression .
    238 index_2 = index .
 \endverbatim
 * Правила и ограничения:
 *
 * a) Параметр <B>index_1</B> должен быть представлен положительным целым числом или
 * неопределённым (<B>?</B>) значением.
 *
 * b) Должно выполняться условие <B>1 &le; index_1 &le; LENGTH(строковое значение)</B>, в противном
 * случае будет возвращено неопределённое (<B>?</B>) значение.
 *
 * c) Если параметр <B>index_2</B> задан, то он должен быть представлен положительным целым числом
 * или неопределённым (<B>?</B>) значением.
 *
 * d) Должно выполняться условие <B>index_1 &le; index_2 &le; LENGTH(строковое значение)</B>, в противном
 * случае будет возвращено неопределённое (<B>?</B>) значение.
 *
 * e) Если <B>index_1</B> или <B>index_2</B> имеет неопределённое (<B>?</B>) значение, то результатом также будет
 * неопределённое (<B>?</B>) значение.
 *
 * f) Если индексируемое выражение имеет неопределённое (<B>?</B>) значение, то результатом также
 * будет неопределённое (<B>?</B>) значение.
 *
 * <B><I>Примеры
 *
 * 1 Седьмой символ строковой переменной name может быть проверен следующим образом:</I>
 <PRE>
     IF name[ 7 ] = "00125FE1" THEN ... -- используется кодировка по ИСО 10646
     IF name[ 7:7 ] = "00125FE1" THEN ... -- эквивалентное выражение
 </PRE>
 * <I>2 Символы с седьмого по десятый строковой переменной name могут быть проверены
 * следующим образом:</I>
 <PRE>
     IF name[ 7:10 ] = 'Some' THEN ...
 </PRE>
 * </B>
 *
 * \subsubsection p11_s12_5_2 12.5.2 Оператор конкатенации строк
 *
 * Оператор конкатенации строк (<B>+</B>) является строковым оператором, соединяющим две строки вместе.
 * Оба операнда должны иметь строковое значение, а результатом является строковое значение,
 * содержащее конкатенацию двух операндов, при этом содержимое первого операнда расположено слева. Если
 * какой-либо из операндов имеет неопределённое (<B>?</B>) значение, то результат будет также иметь
 * неопределённое (<B>?</B>) значение.
 *
 * <B><I>Пример --- Строковые значения могут быть соединены следующим образом:</I>
 <PRE>
      name := 'ABC' + ' ' + 'DEF' ;
      (* переменная name теперь содержит строку 'ABC DEF' *)
 </PRE>
 * </B>
 *
 * \subsection p11_s12_6 12.6 Операторы агрегированных структур
 *
 * К операторам агрегированных структур относятся операторы индексирования (<B>[ ]</B>),
 * пересечения (<B>*</B>), объединения (<B>+</B>), различия (<B>-</B>), подмножества (<B><=</B>), супермножества (<B>>=</B>) и запроса (\ref express::QUERY() "QUERY").
 * Определения данных операторов установлены ниже. Ко всем агрегированным значениям применимы
 * также определённые в \ref p11_s12_2 "12.2" операторы отношений --- «равно» (<B>=</B>), «не равно» (<B><></B>), «равенство
 * экземпляров» (<B>:=:</B>), «неравенство экземпляров» (<B>:<>:</B>) и <B>IN</B>.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 *  Для некоторых операций над агрегированными структурами требуются неявные
 * сравнения элементов агрегированных структур; при этом используется сравнение экземпляров.</SMALL>
 *
 * \subsubsection p11_s12_6_1 12.6.1 Индексирование агрегированных структур
 *
 * Оператор индексирования агрегированных структур принимает два операнда --- индексируемую
 * агрегированную структуру и спецификацию индексов, а результатом является единственный элемент из
 * агрегированной структуры. Типом данных выбранного элемента является базисный тип данных индексируемой
 * агрегированной структуры.
 \verbatim
   Синтаксис:
    239 index_qualifier = '[' index_1 [ ':' index_2 ] ']' .
    237 index 1 = index .
    236 index = numeric_expression .
    238 index_2 = index .
 \endverbatim
 * Правила и ограничения:
 *
 * a) Параметр <B>index_2</B> не должен присутствовать; можно проиндексировать только
 * единственный элемент из агрегированной структуры.
 *
 * b) Параметр <B>index_1</B> должен быть представлен целым числом.
 *
 * c) Должно выполняться условие <B>LOINDEX(агрегированное значение) &le; index_1 &le; HIINDEX(агрегированное значение)</B>,
 * в противном случае будет возвращено неопределённое (<B>?</B>) значение.
 *
 * d) Если типом агрегированной структуры является \ref express::ARRAY_GENERIC "ARRAY" или \ref express::LIST_GENERIC "LIST",
 * то результатом будет элемент
 * агрегированной структуры, расположенный на позиции, указанной параметром <B>index_1</B>.
 *
 * e) Если типом агрегированной структуры является \ref express::BAG_GENERIC "BAG" или \ref express::SET_GENERIC "SET",
 * то для каждого значения параметра <B>index_1</B>, находящегося в диапазоне от <B>LOINDEX(агрегированное значение)</B> до
 * <B>HIINDEX(агрегированное значение)</B>, результатом должны быть разные элементы агрегированной
 * структуры.
 *
 * f) При повторном применении данного оператора к той же агрегированной структуре с тем же
 * значением <B>index_1</B> результатом должен стать тот же элемент, если только агрегированная структура не была
 * модифицирована. Если агрегированная структура была модифицирована, то для агрегированных типов
 * данных \ref express::BAG_GENERIC "BAG" или \ref express::SET_GENERIC "SET" результат повторного применения данного
 * оператора к модифицированной агрегированной структуре непредсказуем.
 *
 * g) Если <B>index_1</B> или <B>index_2</B> имеет неопределённое (<B>?</B>) значение, то результатом также будет
 * неопределённое (<B>?</B>) значение.
 *
 * h) Если индексируемое выражение имеет неопределённое (<B>?</B>) значение, то результатом также
 * будет неопределённое (<B>?</B>) значение.
 *
 * <B><I>Пример --- Применение оператора индексирования к пакетам и наборам может быть
 * использовано для итерационного обращения ко всем значениям в данной агрегированной структуре.</I>
 <PRE>
     FUNCTION set_product (a_set : SET OF INTEGER) : INTEGER;
     LOCAL
       result : INTEGER := 1;
     END_LOCAL;
       REPEAT index := LOINDEX(a_set) TO HIINDEX(a_set);
         result := result * a_set[index];
       END_REPEAT;
       RETURN (result);
     END_FUNCTION;
 </PRE>
 * <I> После выхода из оператора</I> REPEAT <I>переменная</I> result <I>будет содержать произведение всех целых
 * чисел из агрегированной структуры</I> a_set<I>.</I></B>
 *
 * \subsubsection p11_s12_6_2 12.6.2 Оператор пересечения
 *
 * Оператор пересечения (<B>*</B>) принимает два операнда агрегированного типа данных и выдает результат
 * также агрегированного типа данных. Допустимые типы данных операндов и соответствующие им типы
 * данных результата приведены в \ref p11_table16 "таблице 16". Результирующая агрегированная структура является неявно
 * объявленной агрегированной структурой с типом данных, соответствующим \ref p11_table16 "таблице 16", и с границами
 * <B>[0 ... ?]</B>. Базисные типы данных операндов должны быть совместимыми (см. \ref p11_s12_11 "12.11"). Если пересечение двух
 * операндов не содержит элементов, то размер значения результирующей агрегированной структуры
 * должен быть нулевым.
 *
 * Если одним из операндов является набор, то результат должен быть набором, содержащим все элементы,
 * присутствующие в обоих операндах.
 *
 * Если оба операнда являются пакетами и некоторый элемент <B>е</B> присутствует в одном пакете <B>m</B> раз,
 * а в другом пакете --- <B>n</B> раз (где <B>m</B> меньше или равно <B>n</B>), то результат должен <B>m</B> раз содержать элемент <B>е</B>.
 * Если какой-либо из операндов имеет неопределённое (<B>?</B>) значение, то результат будет также иметь
 * неопределённое (?) значение.
 *
 * <BR>
 *
 * \anchor p11_table16
 * Т&nbsp;а&nbsp;б&nbsp;л&nbsp;и&nbsp;ц&nbsp;а 16 --- Оператор пересечения: типы данных операндов и результата
 *
 * <TABLE border="1" cellspacing="0">
 * <tr><td><CENTER>Первый операнд</CENTER></td><td><CENTER>Второй операнд</CENTER></td><td><CENTER>Результат</CENTER> </td></tr>
 * <tr><td></td><td></td><td></td></tr>
 * <tr><td><CENTER><B>BAG</B></CENTER>    </td><td><CENTER><B>BAG</B></CENTER>    </td><td><CENTER><B>BAG</B></CENTER></td></tr>
 * <tr><td><CENTER><B>BAG</B></CENTER>    </td><td><CENTER><B>SET</B></CENTER>    </td><td><CENTER><B>SET</B></CENTER></td></tr>
 * <tr><td><CENTER><B>SET</B></CENTER>    </td><td><CENTER><B>SET</B></CENTER>    </td><td><CENTER><B>SET</B></CENTER></td></tr>
 * <tr><td><CENTER><B>SET</B></CENTER>    </td><td><CENTER><B>BAG</B></CENTER>    </td><td><CENTER><B>SET</B></CENTER></td></tr>
 * </TABLE>
 *
 * \subsubsection p11_s12_6_3 12.6.3 Оператор объединения
 *
 * Оператор объединения (<B>+</B>) принимает два операнда, один из которых должен быть агрегированной
 * структурой, и выдает результат агрегированного типа данных. Допустимые типы данных операндов и
 * соответствующие им типы данных результата приведены в \ref p11_table17 "таблице 17". Результат оператора объединения
 * определяется по первому выполненному из следующих условий:
 *
 * a) Если левый операнд является пакетом, а правый операнд --- пакетом, списком или набором,
 * элементы которого совместимы с базисным типом данных левого операнда, то результатом является левый
 * операнд плюс все элементы правого операнда.
 *
 * b) Если левый операнд является набором, а правый операнд --- пакетом, списком или набором,
 * элементы которого совместимы с базисным типом данных левого операнда, то результат формируется
 * следующим образом: сначала результату присваивается значение левого операнда, затем по очереди
 * рассматриваются элементы правого операнда и, если очередного элемента нет в результирующем наборе, то
 * данный элемент добавляется в результирующий набор.
 *
 * c) Если оба операнда являются совместимыми списками, то результирующий список представляет
 * собой левый операнд с добавленным к его концу правым операндом.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Результирующий список может содержать повторяющиеся элементы даже если оба
 * операнда были объявлены как <B>LIST OF UNIQUE</B>.</SMALL>
 *
 * d) Если тип данных одного из операндов (<B>Е</B>) совместим с базисным типом данных другого операнда
 * (<B>А</B>), то операнд <B>Е</B> добавляется к <B>А</B> следующим образом:
 * - если <B>А</B> является набором, то результирующим набором является <B>А</B>, к которому добавлен набор <B>Е</B>,
 * если только <B>Е</B> уже не содержится в <B>А</B>;
 * - если <B>А</B> является списком, то результирующим списком является <B>А</B> со списком <B>Е</B>, вставленным на
 * позицию 1, если <B>Е</B> был левым операндом, или на позицию <B>SIZEOF(A+1)</B>, если <B>Е</B> был правым операндом.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Результирующий список может содержать повторяющиеся элементы, даже если
 * операнд, являющийся списком, был объявлен как LIST OF UNIQUE;</SMALL>
 *
 * - если <B>А</B> является пакетом, то результат будет пакетом, содержащим <B>А</B> и <B>Е</B>.
 *
 * e) Если какой-либо из операндов имеет неопределённое (<B>?</B>) значение, то результат будет также иметь
 * неопределённое (<B>?</B>) значение.
 *
 * <BR>
 *
 * \anchor p11_table17
 * Т&nbsp;а&nbsp;б&nbsp;л&nbsp;и&nbsp;ц&nbsp;а 17 --- Оператор объединения: типы данных операндов и результата
 *
 * <TABLE border="1" cellspacing="0">
 * <tr><td><CENTER>Первый операнд</CENTER></td><td><CENTER>Второй операнд</CENTER></td><td><CENTER>Результат</CENTER> </td></tr>
 * <tr><td></td><td></td><td></td></tr>
 * <tr><td><CENTER><B>BAG</B></CENTER>    </td><td><CENTER><B>BAG</B></CENTER>    </td><td><CENTER><B>BAG</B></CENTER></td></tr>
 * <tr><td><CENTER><B>BAG</B></CENTER>    </td><td><CENTER>Элемент</CENTER>       </td><td><CENTER><B>BAG</B></CENTER></td></tr>
 * <tr><td><CENTER>Элемент</CENTER>       </td><td><CENTER><B>BAG</B></CENTER>    </td><td><CENTER><B>BAG</B></CENTER></td></tr>
 * <tr><td><CENTER><B>BAG</B></CENTER>    </td><td><CENTER><B>SET</B></CENTER>    </td><td><CENTER><B>BAG</B></CENTER></td></tr>
 * <tr><td><CENTER><B>BAG</B></CENTER>    </td><td><CENTER><B>LIST</B></CENTER>   </td><td><CENTER><B>BAG</B></CENTER></td></tr>
 * <tr><td><CENTER><B>SET</B></CENTER>    </td><td><CENTER><B>SET</B></CENTER>    </td><td><CENTER><B>SET</B></CENTER></td></tr>
 * <tr><td><CENTER><B>SET</B></CENTER>    </td><td><CENTER>Элемент</CENTER>       </td><td><CENTER><B>SET</B></CENTER></td></tr>
 * <tr><td><CENTER>Элемент</CENTER>       </td><td><CENTER><B>SET</B></CENTER>    </td><td><CENTER><B>SET</B></CENTER></td></tr>
 * <tr><td><CENTER><B>SET</B></CENTER>    </td><td><CENTER><B>BAG</B></CENTER>    </td><td><CENTER><B>SET</B></CENTER></td></tr>
 * <tr><td><CENTER><B>SET</B></CENTER>    </td><td><CENTER><B>LIST</B></CENTER>   </td><td><CENTER><B>SET</B></CENTER></td></tr>
 * <tr><td><CENTER><B>LIST</B></CENTER>   </td><td><CENTER><B>LIST</B></CENTER>   </td><td><CENTER><B>LIST\f$^{1)}\f$</B></CENTER></td></tr>
 * <tr><td><CENTER>Элемент</CENTER>       </td><td><CENTER><B>LIST</B></CENTER>   </td><td><CENTER><B>LIST\f$^{2)}\f$</B></CENTER></td></tr>
 * <tr><td><CENTER><B>LIST</B></CENTER>   </td><td><CENTER>Элемент</CENTER>       </td><td><CENTER><B>LIST\f$^{3)}\f$</B></CENTER></td></tr>
 * <tr><td colspan="3">
 * \f$^{1)}\f$ Первый элемент второго списка следует за последним элементом первого списка.
 *
 * \f$^{2)}\f$ Новый элемент становится первым в результирующем списке.
 *
 * \f$^{3)}\f$ Новый элемент становится последним в результирующем списке.
 * </td></tr>
 * </TABLE>
 *
 * \subsubsection p11_s12_6_4 12.6.4 Оператор различия
 *
 * Оператор различия (<B>-</B>) принимает два операнда, левый из которых должен быть агрегированной
 * структурой, и выдает результат агрегированного типа данных. Допустимые типы данных операндов и
 * соответствующие им типы данных результата приведены в \ref p11_table18 "таблице 18". Результирующая агрегированная структура
 * содержит элементы первого операнда за исключением элементов, совпадающих с элементами второго
 * операнда. Другими словами, каждый элемент второго операнда, который присутствует и в первом
 * операнде, удаляется из первого операнда. Результирующая агрегированная структура является неявно
 * объявленной агрегированной структурой с типом данных, соответствующим \ref p11_table18 "таблице 18", и границами <B>[0..?]</B>.
 * Базисные типы операндов должны быть совместимы (см. \ref p11_s12_11 "12.11"). Тип данных возвращаемой
 * агрегированной структуры должен совпадать с типом данных первого операнда. Если оба операнда являются
 * пакетами, и некоторый элемент <B>е</B> присутствует <B>m</B> раз в первом операнде и <B>n</B> раз во втором операнде, то элемент
 * <B>е</B> должен присутствовать в результирующей агрегированной структуре <B>m-n</B> раз, если <B>m</B> больше <B>n</B>, и ни
 * одного раза, если <B>m</B> меньше или равно <B>n</B>. Если второй операнд содержит элементы, которых нет в первом
 * операнде, то такие элементы игнорируются и не включаются в результирующую агрегированную
 * структуру. Если какой-либо из операндов имеет неопределённое (<B>?</B>) значение, то результат будет также иметь
 * неопределённое (<B>?</B>) значение.
 *
 * <BR>
 *
 * \anchor p11_table18
 * Т&nbsp;а&nbsp;б&nbsp;л&nbsp;и&nbsp;ц&nbsp;а 18 --- Оператор различия: типы данных операндов и результата
 *
 * <TABLE border="1" cellspacing="0">
 * <tr><td><CENTER>&nbsp;&nbsp;Первый операнд&nbsp;&nbsp;</CENTER></td>
 *     <td><CENTER>&nbsp;&nbsp;Второй операнд&nbsp;&nbsp;</CENTER></td>
 *     <td><CENTER>&nbsp;&nbsp;Результат&nbsp;&nbsp;</CENTER></td></tr>
 * <tr><td></td><td></td><td></td></tr>
 * <tr><td><CENTER><B>BAG</B></CENTER>    </td><td><CENTER><B>BAG</B></CENTER>    </td><td><CENTER><B>BAG</B></CENTER></td></tr>
 * <tr><td><CENTER><B>BAG</B></CENTER>    </td><td><CENTER><B>SET</B></CENTER>    </td><td><CENTER><B>BAG</B></CENTER></td></tr>
 * <tr><td><CENTER><B>BAG</B></CENTER>    </td><td><CENTER>Элемент</CENTER>       </td><td><CENTER><B>BAG</B></CENTER></td></tr>
 * <tr><td><CENTER><B>SET</B></CENTER>    </td><td><CENTER><B>SET</B></CENTER>    </td><td><CENTER><B>SET</B></CENTER></td></tr>
 * <tr><td><CENTER><B>SET</B></CENTER>    </td><td><CENTER><B>BAG</B></CENTER>    </td><td><CENTER><B>SET</B></CENTER></td></tr>
 * <tr><td><CENTER><B>SET</B></CENTER>    </td><td><CENTER>Элемент</CENTER>       </td><td><CENTER><B>SET</B></CENTER></td></tr>
 * </TABLE>
 *
 * <B><I>Пример --- Если</I> А <I>является пакетом целых чисел</I> [1,2,1,3]<I>, то выражение</I> А – 1
 * <I>имеет значение</I> [1,2,3]<I>, которое эквивалентно значению</I> [2,1,3]<I>.</I></B>
 *
 * \subsubsection p11_s12_6_5 12.6.5 Оператор подмножества
 *
 * Оператор подмножества (<B><=</B>) принимает два операнда, определённых в \ref p11_table19 "таблице 19", и выдаёт
 * результат типа \ref express::LOGICAL "LOGICAL". Результат принимает значение \ref express::TRUE "TRUE" тогда и только
 * тогда, когда какой-либо элемент <B>е</B>, присутствующий <B>n</B> раз в первом операнде, присутствует
 * не менее <B>n</B> раз во втором операнде. Результат принимает значение \ref express::UNKNOWN "UNKNOWN", если какой-либо
 * из операндов имеет неопределённое (<B>?</B>) значение. В противном случае результат принимает значение \ref express::FALSE "FALSE".
 *
 * Типы данных операндов должны быть совместимы (см. \ref p11_s12_11 "12.11").
 *
 * <BR>
 *
 * \anchor p11_table19
 * Т&nbsp;а&nbsp;б&nbsp;л&nbsp;и&nbsp;ц&nbsp;а 19 --- Операторы подмножества и супермножества: типы данных операндов
 *
 * <TABLE border="1" cellspacing="0">
 * <tr><td><CENTER>&nbsp;&nbsp;Первый операнд&nbsp;&nbsp;</CENTER></td>
 *     <td><CENTER>&nbsp;&nbsp;Второй операнд&nbsp;&nbsp;</CENTER></td></tr>
 * <tr><td></td><td></td></tr>
 * <tr><td><CENTER><B>BAG</B></CENTER></td><td><CENTER><B>BAG</B></CENTER></tr>
 * <tr><td><CENTER><B>BAG</B></CENTER></td><td><CENTER><B>SET</B></CENTER></tr>
 * <tr><td><CENTER><B>SET</B></CENTER></td><td><CENTER><B>BAG</B></CENTER></tr>
 * <tr><td><CENTER><B>SET</B></CENTER></td><td><CENTER><B>SET</B></CENTER></tr>
 * </TABLE>
 *
 * \subsubsection p11_s12_6_6 12.6.6 Оператор супермножества
 *
 * Оператор супермножества (<B>>=</B>) принимает два операнда, определённых в \ref p11_table19 "таблице 19", и выдает
 * результат типа \ref express::LOGICAL "LOGICAL". Результат принимает значение \ref express::TRUE "TRUE"
 * тогда и только тогда, когда какой-либо
 * элемент <B>е</B>, присутствующий <B>n</B> раз во втором операнде, присутствует не менее <B>n</B> раз в первом операнде.
 * Результат принимает значение \ref express::UNKNOWN "UNKNOWN", если какой-либо из операндов имеет
 * неопределённое (<B>?</B>) значение. В противном случае результат принимает значение \ref express::FALSE "FALSE".
 *
 * Типы данных операндов должны быть совместимы (см. \ref p11_s12_11 "12.11").
 *
 * Выражение <B>b >= а</B> должно быть полностью эквивалентно выражению <B>а <= b</B>
 *
 * <BR>
 *
 * \anchor p11_s12_6_7
 * \copydetails express::QUERY()
 *
 * \subsection p11_s12_7 12.7 Ссылки
 *
 * Когда элемент, видимый в локальной области видимости, должен использоваться локально, ссылки
 * на данный элемент должны осуществляться по идентификатору, объявленному для данного элемента.
 *
 * \subsubsection p11_s12_7_1 12.7.1 Простые ссылки
 *
 * Простая ссылка представляет собой просто имя (идентификатор), присвоенное элементу в текущей
 * области видимости.
 *
 * Данным способом можно ссылаться на следующие элементы, причем на элементы, помеченные
 * одной звездочкой (<SUP>*</SUP>), данным способом можно ссылаться внутри выражения, а на объекты, помеченные
 * двумя звездочками (<SUP>**</SUP>), можно ссылаться как на конструктор (см. \ref p11_s9_2_6 "9.2.6") или как на локальную переменную
 * в глобальном правиле (см. \ref p11_s9_6 "9.6"):
 * - атрибуты в объявлении объекта<SUP>*</SUP>;
 * - константы<SUP>*</SUP>;
 * - элементы из перечисляемого типа данных<SUP>*</SUP>;
 * - объекты<SUP>**</SUP>;
 * - функции<SUP>*</SUP>;
 * - локальные переменные в теле алгоритма<SUP>*</SUP>;
 * - параметры в теле алгоритма<SUP>*</SUP>;
 * - процедуры;
 * - правила;
 * - схемы в спецификации интерфейсов;
 * - типы данных.
 *
 * <B><I>Пример --- Допустимые простые ссылки:</I>
 *
 * line (* объектный тип данных *)
 *
 * Circle (* объектный тип данных *)
 *
 * RED (* элемент перечисления *)
 *
 * z_depth (* атрибут *)</B>
 *
 *
 * \subsubsection p11_s12_7_2 12.7.2 Префиксные ссылки
 *
 * В случае, когда одно и то же имя элемента перечисления объявлено в нескольких определённых
 * типах данных, видимых в одной и той же области видимости (см. раздел \ref p11_s10 "10"), для обеспечения
 * однозначной идентификации элемента перечисления его имя должно иметь префикс, представляющий
 * собой идентификатор определённого типа данных, соответствующего данному элементу. Префиксная ссылка
 * представляет собой имя определённого типа данных, за которым следует точка (<B>.</B>), за которой следует имя
 * элемента перечисления.
 *
 * <B><I>Пример --- В данном примере показано, как элемент перечисления red может быть однозначно
 * идентифицирован для использования в объекте</I> stop_signal<I>.</I>
 <PRE>
     TYPE traffic_light = ENUMERATION OF (red, amber, green);
     END_TYPE;
     TYPE rainbow = ENUMERATION OF
                    (red, orange, yellow, green, blue, indigo, violet);
     END_TYPE;
     stop_signal : traffic light := traffic light.red;
     ink_colour : rainbow := blue;
 </PRE>
 * </B>
 *
 * \subsubsection p11_s12_7_3 12.7.3 Ссылки на атрибуты
 *
 * Ссылка на атрибут (<B>.</B>) является ссылкой на отдельный атрибут экземпляра объекта. Выражение,
 * расположенное слева от ссылки на атрибут, должно представлять экземпляр объекта или значение частичного
 * сложного объекта. Идентификатор атрибута, на который дается ссылка, указывают после точки (<B>.</B>).
 \verbatim
   Синтаксис:
    179 attribute_qualifier = '.' attribute_ref .
 \endverbatim
 * Ссылка на атрибут, используемая в выражении, возвращает значение указанного атрибута
 * экземпляра объекта или частичного сложного объекта. Если выражение, расположенное слева от ссылки на атрибут,
 * имеет неопределённое (<B>?</B>) значение, то выражение, в котором использована ссылка на атрибут, также
 * имеет неопределённое (<B>?</B>) значение. Если выражение, расположенное слева от ссылки на атрибут,
 * представляет значение частичного сложного объекта, то имя атрибута, указанное справа от ссылки на атрибут, должно
 * присутствовать в объявлении объекта для данного частичного сложного объектного типа данных. Если
 * объявленный тип данных выражения, расположенного слева от ссылки на атрибут, является объектным
 * типом данных, то имя атрибута, указанное справа от ссылки на атрибут, должно быть объявлено в данном
 * объектном типе данных либо в супертипе или подтипе данного объектного типа данных. Если объявленный
 * тип данных выражения, расположенного слева от ссылки на атрибут, является выбираемым типом данных,
 * то имя атрибута, указанное справа, должно быть объявлено в объекте, присутствующем в списке выбора в
 * супертипе или подтипе объекта, присутствующего в списке выбора. Если указанного атрибута нет в
 * экземпляре объекта или в значении частичного сложного объекта, то возвращается неопределённое (<B>?</B>)
 * значение. Если два или более атрибутов имеют одно и то же имя, то данная ссылка является неоднозначной, и
 * возвращается неопределённое (<B>?</B>) значение.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * В ситуации, когда возможно возникновение неоднозначности, рекомендуется
 * использовать спецификатор групповой ссылки, чтобы ограничить область видимости ссылки.</SMALL>
 *
 * <B><I>Пример --- Данный пример демонстрирует использование ссылки на атрибут.</I>
 <PRE>
     ENTITY point;
       х, у, z, : REAL;
     END_ENTITY;
     ENTITY coloured_point
     SUBTYPE OF (point);
       colour : colour;
     END_ENTITY;
     ...
     PROCEDURE foo;
     LOCAL
       first : point := point(1.0, 2.0, 3.0);
       second : coloured_point := point(1.0,2.0,3.0) || coloured_point (red);
       x_coord : REAL;
     END_LOCAL;
     ...
     x_coord := first.x; -- "foo" имеет значение 1.0
     IF first.colour = red THEN (* colour в "foo" является допустимой ссылкой, так как данный атрибут
                                   присутствует в подтипе coloured_point, однако, в данном случае ссылка на
                                   атрибут вернет неопределённое (?) значение, поскольку он не присутствует
                                   в данном экземпляре. *)
     IF second.colour = red THEN -- Значением "foo" является TRUE, так как
                                 -- colour является допустимой ссылкой
 </PRE>
 * </B>
 *
 * \subsubsection p11_s12_7_4 12.7.4 Групповые ссылки
 *
 * Групповая ссылка (<B>\\</B>) обеспечивает ссылку на значение частичного сложного объекта в экземпляре
 * сложного объекта. Выражение, расположенное слева от групповой ссылки, должно представлять
 * экземпляр сложного объекта. Объектный тип данных значения частичного сложного объекта, на который делается
 * ссылка, указывается после обратной косой черты (<B>\\</B>).
 \verbatim
   Синтаксис:
    232 group_qualifier = '\' entity_ref .
 \endverbatim
 * Групповая ссылка, используемая в выражении, возвращает значение частичного сложного объекта,
 * соответствующее именованному объектному типу данных в экземпляре сложного объекта, на который
 * делается ссылка. Если выражение, расположенное слева от групповой ссылки, имеет неопределённое (<B>?</B>)
 * значение, то выражение, содержащее групповую ссылку, также имеет неопределённое (<B>?</B>) значение. Если
 * объявленный тип данных выражения, расположенного слева от групповой ссылки, является объектным
 * типом данных, то имя объекта, указанное справа от групповой ссылки, должно соответствовать объекту из
 * того же графа подтипов/супертипов, что и данный объектный тип данных. Если объявленный тип данных
 * выражения, расположенного слева от групповой ссылки, является выбираемым типом данных, то имя объекта,
 * указанное справа, должно присутствовать в списке выбора или соответствовать объекту из того же графа
 * подтипов/супертипов объектного типа данных, представленного в списке выбора. Если указанный
 * объектный тип данных не представлен в экземпляре сложного объекта, на который делается ссылка, то
 * возвращается неопределённое (<B>?</B>) значение. Групповая ссылка может быть далее уточнена посредством ссылки
 * на атрибут. В этом случае групповая ссылка определяет область видимости ссылки на атрибут.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Данное использование групповой ссылки требуется тогда, когда тип данных экземпляра
 * сложного объекта имеет несколько атрибутов с одинаковым именем или когда выбираемый тип данных
 * содержит несколько объектов с атрибутами, имеющими одинаковое имя.</SMALL>
 *
 * Ограничение: групповая ссылка, которая не уточнена ссылкой на атрибут, должна присутствовать
 * в качестве операнда либо оператора сравнения значений объектов (<B>=</B>), либо конструктора экземпляра
 * сложного объекта (<B>||</B>).
 *
 * <B><I>Примеры
 *
 * 1 В данном примере показано использование групповой ссылки при сравнении значений.</I>
 <PRE>
     ENTITY E1
     ABSTRACT SUPERTYPE;
       attrib1 : REAL;
       attrib2 : REAL;
       attrib3 : REAL;
     END_ENTITY
     ENTITY E2
     SUBTYPE OF (E1);
       attribA : INTEGER;
       attribB : INTEGER;
       attribC : INTEGER;
     END_ENTITY;
     LOCAL
       a : E1;
       b : E2;
     END_LOCAL;
       -- построим экземпляры сложных объектов а и b,
       -- используя оператор конструирования экземпляра сложного объекта
     а := Е1 (0.0,1.0,2.0) || Е2(1,2,3);
     b := Е1 (0.0,1.0,2.0) || Е2(3,2,1);
       -- проверим значения в а и b атрибутов,
       -- объявленных в Е1
     а\\Е1 = b\\E1 -- TRUE
     (*
         это эквивалентно следующему:
              (a.attrib1 = b.attrib1) AND
              (a.attrib2 = b.attrib2) AND
              (a.attrib3 = b.attrib3)
     *)
 </PRE>
 * <I>2 В данном примере показано использование групповой ссылки для указания конкретного
 * объектного типа данных, который может быть использован для имени атрибута.</I>
 <PRE>
     ENTITY foo1;
       attr : REAL;
     END_ENTITY;
     ENTITY foo2
       SUBTYPE OF (foo1);
       attr2 : BOOLEAN;
     END_ENTITY;
     ENTITY t;
       attr : BINARY;
     END_ENTITY;
     TYPE crazy=SELECT(foo2,t);
     END_TYPE;
     ...
     LOCAL
       v : crazy;
     END_LOCAL;
     ...
     IF 'THIS.foo2' IN TYPEOF(v) THEN -- этим обеспечивается отсутствие
                                      -- непредсказуемых результатов
                                      -- (иногда это называется «защита»).
     v\\foo1.attr := 1.5;             -- присваивает 1,5 атрибуту v attr,
                     -- так как attr определён в foo1, в групповой ссылке
                     -- должен использоваться foo1.
    END_IF;
 </PRE>
 * </B>
 *
 * \subsection p11_s12_8 12.8 Вызов функции
 *
 * Вызов функции активизирует данную функцию. Вызов функции состоит из идентификатора функции,
 * за которым может следовать список фактических параметров. Число, тип и порядок следования
 * фактических параметров должны соответствовать формальным параметрам, определённым для данной функции.
 * Вызов функции возвращает значение функции при подстановке в объявлении функции фактических
 * параметров вместо формальных параметров.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Фактические параметры функции могут иметь неопределённое (<B>?</B>) значение. Функция
 * должна корректно обрабатывать такие значения и может сама возвращать неопределённое значение.</SMALL>
 *
 * Активизация функции расширяет пространство экземпляров. Любые экземпляры, созданные в
 * процессе выполнения функции, должны быть однозначно идентифицируемыми во всей совокупности
 * известных экземпляров. Как правило, созданный таким образом экземпляр недоступен вне создающей его
 * функции и, в частности, не является частью рассматриваемой совокупности экземпляров. Исключением
 * является случай, когда такой экземпляр возвращается в качестве результата или в составе результата вызова
 * функции. В данном случае экземпляр остаётся доступным в точке вызова функции. Если экземпляр
 * возвращается подобным образом на уровень схемы (то есть как значение вычисляемого атрибута или
 * константы), он рассматривается как часть общей совокупности экземпляров.
 \verbatim
   Синтаксис:
    219 function_call = ( built_in_function | function_ref )
                          [ actual_parameter_list ] .
    167 actual_parameter_list = '(' parameter { ',' parameter } ')' .
    264 parameter = expression .
 \endverbatim
 * Ограничение: передаваемые фактические параметры должны быть совместимы по назначению с
 * формальными параметрами.
 *
 * <B><I>Пример --- Пример использования вызова функции:</I>
 <PRE>
     ENTITY point;
       х, у, z : number;
     END_ENTITY;
     FUNCTION midpoint_of_line(l:line):point;
     ...
     END_FUNCTION;
     IF midpoint_of_line(L506).x = 9.0 THEN ...
                          -- применяя оператор ссылки на атрибут
                          -- непосредственно к результату функции
     END_IF;
 </PRE>
 * </B>
 *
 * \subsection p11_s12_9 12.9 Инициализатор агрегированных структур
 *
 * Инициализатор агрегированных структур используется, чтобы установить значение типа
 * <B>AGGREGATE OF GENERIC</B>, которое может быть задано массиву, пакету, списку или набору.
 * В квадратных скобках может быть не заключено ни одного или заключено несколько выражений,
 * представляющих значения, принадлежащие к типу данных, совместимому с базисным типом данных
 * агрегированной структуры. При наличии двух или более значений, они должны разделяться запятыми. Разреженный
 * массив может быть инициализирован посредством использования неопределённости (<B>?</B>) вместо
 * отсутствующих символов. Результатом выражения инициализатора агрегированной структуры является
 * агрегированное значение, содержащее значения, определённые как его элементы. Число инициализированных
 * элементов должно соответствовать границам, заданным для данного агрегированного типа данных.
 *
 * Инициализатор агрегированной структуры, не содержащий ни одного элемента, устанавливает
 * пустой пакет, список или набор (данная конструкция не может быть использована для инициализации пустых
 * массивов).
 \verbatim
   Синтаксис:
    169 aggregate_initializer = '[' [ element { ',' element } ] ']' .
    203 element = expression [ ':' repetition ] .
    287 repetition = numeric_expression .
 \endverbatim
 * <B><I>Пример --- Задано объявление:</I>
 <PRE>
     a : SET OF INTEGER;
 </PRE>
 * <I>его значение может быть задано следующим образом:</I>
 <PRE>
     а := [ 1, 3, 6, 9*8, –12 ]; -- 9*8 является выражением со значением 72
 </PRE> </B>
 * Если несколько последовательных значений является одинаковыми, то может быть использовано
 * выражение повторения, которое представляется двумя выражениями, разделенными символом
 * двоеточия (<B>:</B>). Выражение слева от двоеточия представляет значение, которое должно повторяться. Выражение
 * справа от двоеточия задаёт число повторений левого значение. Данное выражение вычисляется один раз,
 * перед инициализацией, и должно иметь неотрицательное целочисленное значение.
 *
 * <B><I>Пример --- Задано следующее объявление:</I>
 <PRE>
     а : BAG OF BOOLEAN;
 </PRE>
 * <I>Следующие два оператора эквивалентны:</I>
 <PRE>
     а : = [ TRUE : 5 ];
     а : = [ TRUE, TRUE, TRUE, TRUE, TRUE ];
 </PRE>
 * </B>
 *
 * \subsection p11_s12_10 12.10 Оператор построения экземпляра сложного объекта
 *
 * Оператор построения экземпляра сложного объекта (<B>||</B>) создаёт экземпляр сложного объекта
 * посредством объединения частичных значений сложного объекта. Частичные значения сложного объекта
 * могут объединяться в произвольном порядке. Результатом выражения оператора построения экземпляра
 * сложного объекта является частичное значение сложного объекта либо экземпляр сложного объекта.
 * Частичный сложный объектный тип данных может присутствовать только один раз на одном уровне выражения
 * оператора построения экземпляра сложного объекта. Частичное значение сложного объекта может
 * присутствовать на разных уровнях, если они являются вложенными, то есть если частичное значение сложного
 * объекта используется для построения экземпляра сложного объекта, являющегося атрибутом частичного
 * значения сложного объекта, объединяемого с другими элементами при построении экземпляра сложного
 * объекта. Если какой-либо из операндов имеет неопределённое (<B>?</B>) значение, то результатом выражения
 * будет также неопределённое (<B>?</B>) значение. Дополнительная информация об экземплярах сложных объектов
 * представлена в приложении B.
 *
 * <B><I>Пример --- Задано:</I>
 <PRE>
     ENTITY a
     ABSTRACT SUPERTYPE;
       a1 : INTEGER;
     END_ENTITY;
     ENTITY b SUBTYPE OF (a);
       b1 : STRING;
     END_ENTITY;
     ENTITY с SUBTYPE OF (a);
       c1 : REAL;
     END_ENTITY;
 </PRE>
 * <I>Тогда могут быть простроены следующие экземпляры сложных объектов:</I>
 <PRE>
     LOCAL
       v1 = a ;
       v2 = с ;
     END_LOCAL;
       v2 := а(2) || с(7.998е-5); -- это экземпляр типа а&с
       v1 := v2 || b('abc');      -- это экземпляр типа а&b&с
       v1 := v2\\a || b("00002639"); -- это экземпляр типа а&b
       v1 := v1 || v2;            -- недопустимо, т.к. тип был бы а&b&а&с
 </PRE>
 * </B>
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Назначение <B>v1</B> копирует экземпляр, созданный оператором построения экземпляра
 * сложного объекта; данный экземпляр содержит значение <B>v2</B>, но не экземпляр <B>v2</B>.</SMALL>
 *
 * \subsection p11_s12_11 12.11 Совместимость типов
 *
 * Операнды оператора должны быть совместимы с типом (типами) данных, необходимых оператору.
 * Типы данных обоих операндов некоторых операторов также должны быть совместимы друг с другом, что
 * было определено выше в данном разделе. Типы данных могут быть совместимыми, не будучи
 * идентичными. Типы данных являются совместимыми при выполнении одно из следующих условий:
 * - типы данных совпадают;
 * - один тип данных является подтипом или конкретизацией другого (включая определённые типы
 * данных, использующие определённый тип данных в качестве базисного типа данных, и конструкционные типы
 * данных, основанные на наращиваемых типах данных);
 * - оба типа данных являются типами данных \ref express::ARRAY_GENERIC "ARRAY" с совместимыми базисными типами данных и
 * одинаковыми границами;
 * - оба типа данных являются типами данных \ref express::LIST_GENERIC "LIST" с совместимыми базисными типами данных;
 * - оба типа данных являются типами данных \ref express::BAG_GENERIC "BAG" или \ref express::SET_GENERIC "SET" с совместимыми базисными типами
 * данных.
 *
 * <B><I>Пример --- Заданы следующие определения:</I>
 <PRE>
     TYPE natural = REAL;
     WHERE SELF >= 0.0;
     END_TYPE;
     TYPE positive = natural;
     WHERE SELF > 0.0;
     END_TYPE;
     TYPE bag_of_natural = BAG OF natural;
     END_TYPE;
     TYPE set_of_up_to_five_positive = SET [0 : 5] OF positive;
     END_TYPE;
 </PRE>
 * <I> При этом совместимыми являются следующие типы данных:</I></B>
 *
 * <TABLE border="1" cellspacing="0">
 * <tr><td><CENTER>&nbsp;&nbsp;<B>Тип данных</B>&nbsp;&nbsp;</CENTER></td>
 *     <td><CENTER>&nbsp;&nbsp;<B>Совместим с типами данных</B>&nbsp;&nbsp;</CENTER></td></tr>
 * <tr><td></td><td></td><td></td></tr>
 * <tr><td><B>REAL</B></td>                      <td><B>INTEGER, REAL, NUMBER, natural, positive</B></td></tr>
 * <tr><td><B>natural</B></td>                   <td><B>REAL, NUMBER, natural, positive</B></td></tr>
 * <tr><td><B>positive</B></td>                  <td><B>REAL, NUMBER, natural, positive</B></td></tr>
 * <tr><td><B>bag_of_natural</B></td>            <td><B>BAG OF REAL, BAG OF NUMBER, BAG OF natural,<BR>
 *                                                      BAG OF positive, SET OF REAL, SET OF NUMBER,<BR>
 *                                                      SET OF natural, SET OF positive, bag_of_natural,<BR>
 *                                                      set_of_up_to_five_positive</B></td></tr>
 * <tr><td><B>set_of_up_to_five_positive</B></td><td><B>BAG OF REAL, BAG OF NUMBER, BAG OF natural,<BR>
 *                                                      BAG OF positive, SET OF REAL, SET OF NUMBER,<BR>
 *                                                      SET OF natural, SET OF positive, bag_of_natural
 *                                                                                          </B></td></tr>
 * </TABLE>
 *
 * \subsection p11_s12_12 12.12 Выбираемые типы данных в выражениях
 *
 * При проверке схемы парсер уровня 2 должен идентифицировать совместимость типов операндов и
 * операторов в выражениях. Выражение, содержащее тип данных \ref express::SELECT "SELECT", может быть допустимым только
 * для некоторых типов данных из списка выбора и не допустимым для остальных типов данных из списка
 * выбора. Ранее в данном разделе были определены допустимые типы данных в выражениях, кроме типов
 * данных \ref express::SELECT "SELECT"; установленные ниже правила относятся конкретно к данным типам данных.
 *
 * Тип данных, возвращаемый выражением, содержащим операнды, объявленный тип данных которых
 * является выбираемым типом данных, является выбираемым типом данных, содержащим все возможные
 * типы данных, возвращенные допустимыми выражениями из указанных операндов.
 *
 * Невыбираемые типы данных в выбираемом типе данных – это невыбираемые типы данных каждого
 * типа данных из списка выбора выбираемого типа данных; невыбираемым типом данных в типе данных,
 * который не является выбираемым, является сам данный тип данных.
 *
 * \subsubsection p11_s12_12_1 12.12.1 Выбираемые типы данных в унарных выражениях
 *
 * В данном пункте определена обработка выбираемых типов данных в выражениях с одним
 * операндом, к которым относятся операторы: <B>-</B>, <B>+</B>, <B>NOT</B> и <B>QUERY</B>:
 *
 * a) Если все невыбираемые типы данных в списке выбора объявленного типа операнда допустимы в
 * контексте данного выражения, то выражение является допустимым и должно возвращать допустимый результат.
 *
 * b) Если некоторые, но не все невыбираемые типы данных в списке выбора объявленного типа
 * операнда допустимы в контексте данного выражения, то выражение является допустимым, но может выдать ошибку,
 * если в выражении вычисляются значения типов данных, являющихся недопустимыми.
 *
 * c) Если ни один из невыбираемых типов данных в списке выбора объявленного типа операнда не
 * является допустимым в контексте данного выражения, то выражение является недопустимым и всегда
 * будет возвращать недопустимый результат.
 *
 * \subsubsection p11_s12_12_2 12.12.2 Выбираемые типы данных в бинарных выражениях
 *
 * В данном пункте определена обработка выбираемых типов данных в выражениях с двумя
 * операндами:
 *
 * a) Если для каждого невыбираемого типа данных в списке выбора объявленного типа левого
 * операнда существует допустимое выражение с каждым невыбираемым типом данных в списке выбора
 * объявленного типа правого операнда, то данное выражение является допустимым и должно возвращать
 * допустимый результат.
 *
 * b) Если некоторые, но не все невыбираемые типы данных в списке выбора объявленного типа левого
 * операнда и, по крайней мере, один невыбираемый тип данных правого операнда допустимы в контексте
 * данного выражения, то выражение является допустимым, но может выдать ошибку, если в выражении
 * вычисляются значения типов данных, являющихся недопустимыми.
 *
 * \subsubsection p11_s12_12_3 12.12.3 Выбираемые типы данных в тернарных выражениях
 *
 * В данном пункте определена обработка выбираемых типов данных в выражениях с тремя
 * операндами.
 *
 * Единственным выражением в языке EXPRESS, содержащим три операнда, является интервальное
 * выражение. Оно рассматривается в контексте выбираемых типов данных, как если бы существовало два
 * отдельных выражения, связанных оператором <B>AND</B>.
 *
 * \section p11_s13 13 Исполняемые операторы
 *
 * Исполняемые операторы определяют действия функций, процедур и правил. Данные операторы
 * воздействуют только на переменные, локальные по отношению к <B>FUNCTION</B>, <B>PROCEDURE</B> или <B>RULE</B>.
 * Данные операторы используются для определения логики действий, необходимых для поддержки
 * определения ограничений, которые задаются условиями <B>WHERE</B> и правилами <B>RULE</B>. Данные операторы не
 * оказывают влияния на экземпляры объектов в области определения, как установлено в разделе \ref p11_s5 "5". К
 * исполняемым операторам относятся: пустой оператор, <B>ALIAS</B>, оператор присваивания, <B>CASE</B>, составной оператор,
 * <B>ESCAPE</B>, <B>IF</B>, вызов процедуры, <B>REPEAT</B>, <B>RETURN</B> и <B>SKIP</B>.
 *
 * Исполняемые операторы могут присутствовать только внутри <B>FUNCTION</B>, <B>PROCEDURE</B> или <B>RULE</B>.
 \verbatim
   Синтаксис:
    309 stmt = alias_stmt | assignment_stmt | case_stmt | compound_stmt |
               escape_stmt | if_stmt | null_stmt | procedure_call_stmt |
               repeat_stmt | return_stmt | skip_stmt 
 \endverbatim
 *
 * \subsection p11_s13_1 13.1 Пустой оператор
 *
 * Исполняемый оператор, состоящий только из точки с запятой (<B>;</B>), называется пустым оператором.
 * Никаких действий пустой оператор не выполняет.
 \verbatim
   Синтаксис:
    260 null_stmt = ';' .
 \endverbatim
 * <B><I>Пример --- В данном примере показано возможное использование пустого оператора.</I>
 <PRE>
     IF a = 13 THEN
       ; -- это пустой оператор.
     ELSE
       b := 5;
     END_IF;
 </PRE> </B>
 *
 * \subsection p11_s13_2 13.2 Оператор ALIAS
 *
 * Оператор ALIAS обеспечивает возможность локального переименования уточненных
 * переменных и параметров.
 \verbatim
   Синтаксис:
    174 alias_stmt = ALIAS variable_id FOR general_ref { qualifier } ';' stmt { stmt }
                     END_ALIAS ';' .
    228 general_ref = parameter_ref | variable_ref .
 \endverbatim
 * В области видимости оператора ALIAS переменная variable_id неявно объявлена имеющей
 * надлежащий тип данных и содержит значение, на которое ссылается уточняющий идентификатор,
 * следующий за ключевым словом <B>FOR</B>.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Правила видимости для <B>variable_id</B> описаны в \ref p11_s10_3_1 "10.3.1".</SMALL>
 *
 * <B><I>Пример — Предположим, что существует объектный тип данных point с атрибутами</I> x,y,z<I>;
 * тогда оператор</I> ALIAS <I>может быть использован в функции</I> calculate_length <I>для сокращения длины
 * возвращаемого выражения.</I>
 <PRE>
     ENTITY line;
       start_point,
       end_point : point;
     END_ENTITY;
     FUNCTION calculate_length (the_line : line) : real;
     ALIAS s FOR the_line.start_point;
       ALIAS e FOR the_line.end_point;
         RETURN (SQRT( (s.x – e.x)**2 + (s.y – e.y)**2 + (s.z – e.z)**2) );
       END_ALIAS;
     END_ALIAS;
     END_FUNCTION
 </PRE> </B>
 *
 * \subsection p11_s13_3 13.3 Присваивание
 *
 * \subsubsection p11_s13_3_1 13.3.1 Оператор присваивания
 *
 * Оператор присваивания используется для задания экземпляра локальной переменной или
 * параметру. Если выражение, расположенное справа от оператора присваивания, является экземпляром объекта,
 * то оператор присваивания задаёт локальной переменной или параметру ссылку на данный экземпляр объекта.
 * После исполнения оператора присваивания изменения локальной переменной или параметра отражаются в
 * исходном экземпляре. Оператор присваивания может также использоваться для копирования значений в
 * локальную переменную или экземпляр, когда они объявляются принадлежащими к необъектным типам
 * данных. Тип данных значения, присвоенного переменной, должен быть совместим по присваиванию с
 * переменной или параметром.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Оператор присваивания не может использоваться для создания копии значения
 * экземпляра в локальной переменной или параметре.</SMALL>
 \verbatim
   Синтаксис:
    176 assignment_stmt = general_ref { qualifier } ':=' expression ';' .
    228 general_ref = parameter_ref | variable_ref .
 \endverbatim
 * <B><I> Пример --- Следующие фрагменты демонстрируют допустимые присваивания:</I>
 <PRE>
     LOCAL
       а, b : REAL ;
       р : point;
     END LOCAL;
     ...
       а : = 1.1 ;
       b : = 2.5 * а;
       р.х : = b ;
 </PRE> </B>
 *
 * \subsubsection p11_s13_3_2 13.3.2 Совместимость по присваиванию
 *
 * Для значения, присваиваемого вычисляемому атрибуту, локальной переменной или параметру,
 * должны выполняться два условия.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * В приведенном ниже тексте термин «переменная» использован для обозначения
 * вычисляемого атрибута, локальной переменной или параметра.</SMALL>
 *
 * a) результирующий тип данных присваиваемого выражения должен быть совместимым с типом
 * данных переменной;
 *
 * b) результирующее значение, полученное при вычислении выражения, должно удовлетворять всем
 * ограничениям, установленным для данного типа данных переменной.
 *
 * Считается, что тип данных присваиваемого выражения и тип данных переменной являются
 * совместимыми, если выполняется одно из следующих условий:
 *
 * a) типы данных являются одинаковыми;
 *
 * b) результат выражения принадлежит к типу данных, который является подтипом или конкретизацией
 * типа данных, объявленного для переменной, которой он присваивается;
 *
 * c) объявленный тип данных переменной, которой присваивается значение, является определённым
 * типом данных, основным типом данных которого является выбираемый тип данных, а результат выражения
 * принадлежит к типу данных, совместимому по присваиванию с одним или более типами данных,
 * установленными в области определения выбираемого типа данных (включая элементы, добавленные к данной
 * области определения другими выбираемыми типами данных, основанными на данном выбираемом типе
 * данных).
 *
 * Основным типом определённого типа данных является основный тип базисного типа данных, а
 * основным типом типа данных, не являющегося определённым типом данных, является сам данный тип
 * данных;
 *
 * d) переменная представлена определённым типом данных, основным типом которого является
 * простой тип данных, а результатом выражения — значение данного простого типа данных;
 *
 * e) переменная представлена агрегированным типом данных, а выражение является инициализатором
 * агрегированной структуры, элементы которой, при их наличии, совместимы по присваиванию с базисным
 * типом данного агрегированного типа данных;
 *
 * f) если присваиваемый объект является уточненным, то следующие условия должны выполняться
 * для разных видов уточнения:
 *
 *  1) уточнение атрибутом:
 * - объявленный тип выражения, расположенного слева от ссылки на атрибут, должен быть
 * объектным типом данных или выбираемым типом данных, определённым с использованием, по
 * крайней мере, одного объектного типа данных. Атрибут, имя которого указано справа от ссылки на
 * атрибут, должен присутствовать в объектном типе данных или в объекте, присутствующем в том
 * же графе подтипов/супертипов, что и объектный тип данных,
 * - если результатом выражения, расположенного слева от ссылки на атрибут, является
 * экземпляр, содержащий указанный атрибут, имеющий некоторое значение, то исходное значение
 * заменяется выражением, расположенным справа от оператора присваивания, если только уточнение
 * объекта, которому присваивается значение, не продолжается дальше; в последнем случае
 * используется данное дальнейшее уточнение,
 * - если результатом выражения, расположенного слева от ссылки на атрибут, является
 * экземпляр, содержащий указанный атрибут, а данный атрибут имеет неопределённое (<B>?</B>) значение
 * (если он является необязательным или ещё не инициализирован), то выражение, расположенное
 * справа от оператора присваивания, назначается данному атрибуту, если только уточнение
 * объекта, которому присваивается значение, не продолжается дальше; в последнем случае
 * фиксируется ошибка;
 *
 * 2) уточнение группой:
 * - объявленный тип выражения, расположенного слева от ссылки на группу, должен быть
 * объектным типом данных или выбираемым типом данных, определённым с использованием, по
 * крайней мере, одного объектного типа данных. Объект, имя которого указано справа от ссылки на
 * группу, должен присутствовать в том же графе подтипов/супертипов, что и объектный тип данных,
 * - если результатом выражения, расположенного слева от ссылки на группу, является
 * экземпляр, содержащий имя объекта, указанное справа от ссылки на группу, то исходное частичное
 * значение сложного объекта заменяется выражением, расположенным справа от оператора
 * присваивания, если только уточнение объекта, которому присваивается значение, не продолжается
 * дальше; в последнем случае используется данное дальнейшее уточнение;
 *
 * 3) уточнение элементом:
 * - объявленный тип выражения, расположенного слева от квалификатора элемента, должен
 * быть одним из
 * (\ref express::ARRAY_GENERIC "ARRAY", \ref express::BINARY "BINARY", \ref express::LIST_GENERIC "LIST" или \ref express::STRING "STRING"),
 * либо выбираемым типом данных,
 * определённым с использованием одного из указанных типов данных. Параметр <B>index_1</B> должен иметь
 * целочисленное значение,
 * - выражение, расположенное слева от квалификатора элемента, должно быть
 * инициализировано, то есть иметь значение до того, как его элементам могут быть присвоены значения,
 * - если результат выражения, расположенного слева от квалификатора элемента,
 * принадлежит к типу данных \ref express::ARRAY_GENERIC "ARRAY" и выполняется
 * <B>{ LOINDEX (left) <= index_1 <= HIINDEX (left) }</B>, то:
 * если в массиве уже имеется элемент на данной позиции, то выражение, расположенное
 * справа от оператора присваивания, замещает исходное значение, расположенное в массиве
 * на данной позиции, если только уточнение объекта, которому присваивается значение, не про-
 * должается дальше; в последнем случае для исходного элемента используется данное
 * дальнейшее уточнение,
 * если в массиве на данной позиции присутствует неопределённое (<B>?</B>) значение, которое
 * далее не уточняется, то выражение, расположенное справа от оператора присваивания
 * вставляется в массив на данную позицию,
 * - если результат выражения, расположенного слева от квалификатора элемента,
 * принадлежит к типу данных \ref express::BINARY "BINARY" и выполняется
 * <B>{ 1 <= index_1 <= BLENGTH (left) }</B>, то выражение,
 * расположенное справа от оператора присваивания, заменяет в двоичном числе бит, расположенный на
 * данной позиции,
 * - если результат выражения, расположенного слева от квалификатора элемента,
 * принадлежит к типу данных \ref express::LIST_GENERIC "LIST" и выполняется <B>{ 1 <= index_1 <= SIZEOF(left) }</B>, то выражение,
 * расположенное справа от оператора присваивания, заменяет в списке элемент, расположенный на данной
 * позиции, если только объект, которому присваивается значение, не уточняется; в последнем
 * случае используется данное дальнейшее уточнение,
 * - если результат выражения, расположенного слева от квалификатора элемента,
 * принадлежит к типу данных \ref express::STRING "STRING" и выполняется
 * <B>{ 1 <= index_1 <= LENGTH(left) }</B>, то выражение,
 * расположенное справа от оператора присваивания, заменяет в строке символ, расположенный на данной
 * позиции;
 *
 * 4) уточнение диапазоном:
 * - объявленный тип выражения, расположенного слева от квалификатора диапазона, должен
 * быть \ref express::BINARY "BINARY" или \ref express::STRING "STRING" либо выбираемым типом данных,
 * определённым с использованием
 * одного из указанных типов данных. Параметры <B>index_1</B> и <B>index_2</B> должны иметь целочисленное
 * значение,
 * - выражение, расположенное слева от квалификатора диапазона, должно быть
 * инициализировано, то есть иметь значение до того, как его элементам могут быть присвоены значения,
 * - если результат выражения, расположенного слева от квалификатора диапазона,
 * принадлежит к типу данных \ref express::BINARY "BINARY" и выполняется
 * <B>{ 1 <= index_1 <= index_2 } AND (index_2 <= BLENGTH (left))</B>,
 * то выражение, расположенное справа от оператора присваивания замещает элементы,
 * расположенные в исходном двоичном числе между позициями <B>index_1</B> и <B>index_2</B>.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Если <B>BLENGTH(right)<>(index_2–index_1+1)</B>, то данным присваиванием
 * будет изменена длина расположенного слева выражения <B>BLENGTH(left)</B>,</SMALL>
 *
 * - если результат выражения, расположенного слева от квалификатора диапазона,
 * принадлежит к типу данных \ref express::STRING "STRING" и выполняется
 * <B>{ 1 <= index_1 <= index_2 } AND (index_2 <= LENGTH(left))</B>,
 * то выражение, расположенное справа от оператора присваивания, замещает элементы,
 * расположенные в исходной строке между позициями <B>index_1</B> и <B>index_2</B>.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Если <B>LENGTH(right) <> (index_2– index_1+1)</B>, то данным присваиванием
 * будет изменена длина расположенного слева выражения <B>LENGTH(left)</B>;</SMALL>
 *
 * g) если объект, которому присваивается значение уточнен, но не соответствует ни одному из
 * перечисленных выше случаев, то фиксируется ошибка.
 * Если синтаксический анализатор, обеспечивающий проверку уровня 4 (см. \ref p11_s4_1_1 "4.1.1") определит, что
 * результат выражения принадлежит к типу данных, являющемуся обобщением типа данных, объявленного
 * для переменной, которой присваивается значение, то данный оператор присваивания считается
 * недопустимым. При этом могут существовать допустимые присваивания с использованием данного оператора, если
 * фактические значения, возвращаемые выражением, соответствуют установленным выше условиям,
 * однако, может быть получен непредсказуемый результат, если фактические значения, возвращаемые
 * выражением, не совместимы с установленными выше условиями.
 *
 * Частичные экземпляры, являющиеся недопустимыми экземплярами сложного объекта (см.
 * приложение B), не могут быть присвоены параметрам или переменным сложного объекта и переданы в качестве
 * фактических параметров функциям или процедурам. Данное требование не ограничивает присваивание
 * допустимых экземпляров сложного объекта.
 *
 * \subsection p11_s13_4 13.4 Оператор CASE
 *
 * Оператор выбора <B>CASE</B> обеспечивает механизм для выборочного исполнения операторов на основе
 * значения некоторого выражения. Оператор исполняется в зависимости от значения переключателя
 * (элемент <B>selector</B>). Оператор выбора состоит из выражения, являющегося переключателем блоков, и списка
 * альтернативных действий, каждому из которых предшествует одно или несколько выражений,
 * являющихся метками блоков. Результирующий тип данных метки блока должен быть совместим с типом данных
 * переключателя блоков. Выбирается первая встретившаяся метка блока, имеющая значение, равное
 * переключателю блоков, и исполняются операторы, связанные с данной меткой. Если результатом сравнения
 * метки и переключателя является \ref express::UNKNOWN "UNKNOWN" или \ref express::FALSE "FALSE",
 * то выбор не проводится. Исполняется не более
 * одного из блоков выбора. Если переключатель блоков имеет неопределённое (<B>?</B>) значение, то исполняется
 * блок, которому предшествует ключевое слово <B>OTHERWISE</B>, при его наличии. Если метка блока имеет
 * неопределённое (<B>?</B>) значение, то результатом сравнения является \ref express::UNKNOWN "UNKNOWN", и оператор не должен
 * исполняться. Если значение ни одной из меток блоков не совпадает со значением переключателя блоков,
 * то возможны следующие альтернативы:
 * - если ключевое слово <B>OTHERWISE</B> присутствует, то исполняется связанный с ним оператор;
 * - если ключевое слово <B>OTHERWISE</B> отсутствует, то ни один из операторов, связанных с оператором
 * выбора, не исполняется.
 *
 \verbatim
   Синтаксис:
    191 case_stmt = CASE selector OF { case_action } [ OTHERWISE ':' stmt ]
                    END_CASE ';' .
    299 selector = expression .
    189 case_action = case_label { ',' case_label } ':' stmt .
    190 case_label = expression .
 \endverbatim
 * Ограничение: тип данных вычисленного значения меток блоков должен быть совместим с типом
 * данных вычисленного значения переключателя блоков.
 *
 * <B><I>Пример --- Простой оператор выбора, использующий целочисленные метки блоков.</I>
 <PRE>
     LOCAL
       а : INTEGER ;
       х : REAL ;
     END_LOCAL ;
     ...
     a := 3 ;
     x := 34.97 ;
     CASE a OF
       1    : x := SIN(x);
       2    : x := ЕХР(х);
       3    : x := SQRT(x); -- этот оператор исполняется!
       4, 5 : x := LOG(x);
     OTHERWISE : х := 0.0;
     END_CASE;
 </PRE> </B>
 *
 * \subsection p11_s13_5 13.5 Составной оператор
 *
 * Составной оператор представляет собой последовательность операторов, ограниченную ключевыми
 * словами <B>BEGIN</B> и <B>END</B>. Составной оператор действует как единый оператор.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Составной оператор не определяет новую область видимости.</SMALL>
 \verbatim
   Синтаксис:
    192 compound_stmt = BEGIN stmt { stmt } END ';' .
 \endverbatim
 * <B><I>Пример --- Простой составной оператор:</I>
 <PRE>
     BEGIN
       а = а+1;
       IF a > 100 THEN
         а := 0 ;
       END_IF;
     END 
 </PRE> </B>
 *
 * \subsection p11_s13_6 13.6 Оператор ESCAPE
 *
 * Оператор <B>ESCAPE</B> вызывает немедленный переход к оператору, следующему непосредственно за
 * оператором <B>REPEAT</B>, в котором встретился данный оператор <B>ESCAPE</B>.
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Применение оператора <B>ESCAPE</B> является единственным способом выхода из
 * оператора <B>REPEAT</B> в случае задания бесконечного цикла.</SMALL>
 \verbatim
   Синтаксис:
    214 escape_stmt = ESCAPE ' ; ' .
 \endverbatim
 * Ограничение: оператор <B>ESCAPE</B> должен присутствовать только в пределах области видимости
 * оператора <B>REPEAT</B>.
 *
 * \subsection p11_s13_7 13.7 Оператор IF...THEN...ELSE
 *
 * Оператор <B>IF...THEN...ELSE</B> обеспечивает условное выполнение операторов на основе значения
 * выражения типа \ref express::LOGICAL "LOGICAL". Если значением <B>logical_expression</B> является
 * \ref express::TRUE "TRUE", то исполняется
 * оператор, следующий за ключевым словом <B>THEN</B>. Если значением <B>logical_expression</B> является
 * \ref express::FALSE "FALSE", \ref express::UNKNOWN "UNKNOWN" или неопределённость (<B>?</B>),
 * то исполняется оператор, следующий за ключевым словом
 * <B>ELSE</B>, если данное ключевое слово присутствует. Если значением <B>logical_expression</B>
 * является \ref express::FALSE "FALSE", \ref express::UNKNOWN "UNKNOWN" или неопределённость (<B>?</B>),
 * а ключевое слово <B>ELSE</B> отсутствует, то управление передается
 * следующему оператору.
 \verbatim
   Синтаксис:
    233 if_stmt = IF logical_expression THEN stmt { stmt } [ ELSE stmt { stmt } ]
                  END_IF ';' .
    254 logical_expression = expression .
 \endverbatim
 * <B><I>Пример --- Простой оператор</I> IF<I>:</I>
 <PRE>
     IF a < 10 THEN
       с := с + 1;
     ELSE
       с := с – 1;
     END_IF;
 </PRE> </B>
 *
 * \subsection p11_s13_8 13.8 Оператор вызова процедуры
 *
 * Оператор вызова процедуры активизирует процедуру. Фактические параметры, передаваемые при
 * вызове процедуры, должны соответствовать по числу, порядку и типу данных с формальными
 * параметрами, установленными для данной процедуры.
 \verbatim
   Синтаксис:
    270 procedure_call_stmt = ( built_in_procedure | procedure_ref)
                              [ actual_parameter_list ] ' ; ' .
    167 actual_parameter_list = ' ( ' parameter { ',' parameter } ' ) ' .
    264 parameter = expression .
 \endverbatim
 * Ограничение: передаваемые фактические параметры должны быть совместимы по присваиванию
 * с формальными параметрами.
 *
 * <B><I>Пример --- Вызов встроенной процедуры</I> INSERT<I>:</I>
 <PRE>
     INSERT (point_list, this_point, here);
 </PRE> </B>
 *
 * \subsection p11_s13_9 13.9 Оператор REPEAT
 *
 * Оператор цикла <B>REPEAT</B> используется для зависящего от условия повторения исполнения
 * последовательности операторов. Начало или продолжение повторения определяется по вычисленному значению
 * управляющего условия (или условий). Управляющими условиями являются:
 * - конечное число итераций (инкрементное управление);
 * - пока условие имеет значение \ref express::TRUE "TRUE" (управляющее условие <B>WHILE</B>);
 * - до тех пор, пока условие имеет значение \ref express::TRUE "TRUE" (управляющее условие <B>UNTIL</B>).
 \verbatim
   Синтаксис:
    286 repeat_stmt = REPEAT repeat_control ';' stmt { stmt } END_REPEAT ';' .
    285 repeat_control = [ increment_control ] [ while_control ] [ until_control ] .
    235 increment_control = variable_id ':= ' bound_1 TO bound_2 [ BY increment ] .
    183 bound_1 = numeric_expression .
    184 bound_2 = numeric_expression .
    234 increment = numeric_expression .
 \endverbatim
 * Для задания условий окончания цикла может использоваться комбинация управляющих условий.
 * Для управления итерациями значения данных условий определяются следующим образом:
 * 
 * a) Если выполняется оператор <B>REPEAT</B> и при этом присутствует инкрементное управляющее
 * условие, то вычисляется выражение, определяющее данное инкрементное условие в соответствии с \ref p11_s13_9_1 "13.9.1".
 * 
 * b) Если присутствует управляющее условие <B>WHILE</B>, то вычисляется значение указанного в нем
 * выражения. Если значением выражения является \ref express::TRUE "TRUE" (либо если управляющее условие <B>WHILE</B>
 * отсутствует), то исполняется тело оператора <B>REPEAT</B>. Если значением выражения является
 * \ref express::FALSE "FALSE", \ref express::UNKNOWN "UNKNOWN" или неопределённость (<B>?</B>),
 * то исполнение оператора <B>REPEAT</B> заканчивается.
 * 
 * c) Когда заканчивается исполнение тела оператора <B>REPEAT</B>, вычисляют значение выражения
 * управляющего условия <B>UNTIL</B>. Если значением выражения является \ref express::TRUE "TRUE", то дальнейшее исполнение
 * итераций прекращается, и исполнение оператора <B>REPEAT</B> завершается. Если значением выражения является
 * \ref express::FALSE "FALSE" или \ref express::UNKNOWN "UNKNOWN",
 * то исполнение оператора <B>REPEAT</B> возвращается к проверке инкрементного
 * управляющего условия. Если управляющее условие <B>UNTIL</B> отсутствует, то исполнение оператора <B>REPEAT</B>
 * возвращается к проверке инкрементного управляющего условия.
 * 
 * d) Если инкрементное управляющее условие присутствует, то значение переменной цикла
 * изменяется на значение, задаваемое элементом <B>increment</B>. Если значение переменной цикла находится в
 * пределах от <B>bound_1</B> до <B>bound_2</B>, включая данные границы, то управление передается на шаг по
 * перечислению b), в противном случае, исполнение оператора <B>REPEAT</B> заканчивается.
 * 
 * <B><I>Пример --- В данном примере показано, как в операторе</I> REPEAT <I>могут использоваться
 * несколько управляющих условий. Повтор исполнения операторов тела цикла осуществляется до
 * тех пор, пока не выполнится одно из двух условий, то есть пока не будет достигнута заданная
 * точность или выполнено сто циклов; то есть итерационный процесс прекращается, если решение
 * не сходится достаточно быстро.</I>
 <PRE>
     REPEAT i := 1 ТО 100 UNTIL epsilon < 1.E–6;
       ...
       epsilon := . . . ;
     END_REPEAT;
 </PRE> </B>
 * 
 *
 * \subsubsection p11_s13_9_1 13.9.1 Инкрементное управление
 *
 * При инкрементном управлении тело оператора цикла исполняется для следующих одно за другим
 * значений из некоторой последовательности. При входе в оператор цикла неявно объявленной переменной
 * числового типа <B>variable_id</B> присваивается значение <B>bound_1</B>. После каждой итерации переменной
 * <B>variable_id</B> присваивается значение <B>variable_id + increment</B>. Если элемент <B>increment</B> не задан, то по
 * умолчанию используется значение равное единице (1). Если значение <B>variable_id</B> находится в пределах
 * между <B>bound_1</B> и <B>bound_2</B> (включая случай, когда <B>variable_id=bound_2</B>), то выполнение оператора цикла
 * продолжается.
 \verbatim
   Синтаксис:
    235 increment_control = variable_id ':= ' bound_1 TO bound_2 [ BY increment ] .
    183 bound_1 = numeric_expression .
    184 bound_2 = numeric_expression .
    234 increment = numeric_expression .
 \endverbatim
 * Правила и ограничения:
 *
 * a) Выражения <B>numeric_expression</B>, представляющие элементы <B>bound_1</B>, <B>bound_2</B> и <B>increment</B>,
 * должны иметь числовые значения.
 *
 * b) Выражения <B>numeric_expression</B>, представляющие границы и приращение, вычисляют один раз
 * при входе в оператор <B>REPEAT</B>.
 *
 * c) Если какое-либо из выражений <B>numeric_expression</B>, представляющих границы или приращение,
 * имеет неопределённое (<B>?</B>) значение, то оператор <B>REPEAT</B> не исполняется.
 *
 * d) Перед первым вычислением оператора инкрементного управления проверяют следующие
 * условия:
 * - если приращение (элемент <B>increment</B>) положительно и <B>bound_1 > bound_2</B>, то оператор <B>REPEAT</B> не
 * исполняется,
 * - если приращение (элемент <B>increment</B>) отрицательно и <B>bound_1 < bound_2</B>, то оператор <B>REPEAT</B> не
 * исполняется,
 * - если приращение (элемент <B>increment</B>) равно нулю (<B>0</B>), то оператор <B>REPEAT</B> не исполняется;
 * - во всех других случаях оператор <B>REPEAT</B> исполняется до тех пор, пока значение переменной
 * <B>variable_id</B> не выйдет за заданные границы или один из других управляющих операторов в теле оператора
 * <B>REPEAT</B> не завершит его исполнение.
 *
 * e) Переменная цикла инициализируется со значением <B>bound_1</B> в начале первого цикла итераций,
 * и изменяется на значение, определяемое элементом <B>increment</B> в начале каждого последующего
 * цикла.
 *
 * f) Значение переменной цикла не должно изменяться в теле оператора <B>REPEAT</B>.
 *
 * g) Оператор <B>REPEAT</B> устанавливает локальную область видимости, в которой переменная цикла
 * <B>variable_id</B> неявно объявляется как числовая переменная. Поэтому любое использование переменной
 * <B>variable_id</B> для внешней области видимости скрыто в операторе <B>REPEAT</B>, и значение переменной цикла
 * недоступно вне оператора <B>REPEAT</B>.
 *
 * \subsubsection p11_s13_9_2 13.9.2 Управляющее условие WHILE
 *
 * Управляющее условие <B>WHILE</B> обеспечивает инициализацию и продолжение исполнения тела
 * оператора <B>REPEAT</B>, пока значением управляющего выражения является \ref express::TRUE "TRUE". Значение управляющего
 * выражения вычисляется перед каждой итерацией.
 *
 * Если управляющее условие присутствует <B>WHILE</B>, и значением управляющего выражения является
 * \ref express::FALSE "FALSE", \ref express::UNKNOWN "UNKNOWN" или неопределённость (<B>?</B>),
 * то тело оператора REPEAT не исполняется.
 \verbatim
   Синтаксис:
    339 while_control = WHILE logical_expression .
    254 logical_expression = expression .
 \endverbatim
 * Правила и ограничения:
 *
 * a) элемент <B>logical_expression</B> должен иметь значение типа \ref express::LOGICAL "LOGICAL";
 *
 * b) элемент <B>logical_expression</B> вычисляют заново в начале каждой итерации.
 *
 * \subsubsection p11_s13_9_3 13.9.3 Управляющее условие UNTIL
 *
 * Управляющее условие <B>UNTIL</B> обеспечивает продолжение выполнения тела оператора <B>REPEAT</B> до тех
 * пор, пока управляющее выражение не примет значение TRUE. Значение выражения должно вычисляться
 * после каждой итерации.
 *
 * Если управляющее условие <B>UNTIL</B> является единственным управляющим условием, то всегда
 * должна быть исполнена, по крайней мере, одна итерация.
 \verbatim
   Синтаксис:
    335 until_control = UNTIL logical_expression .
    254 logical_expression = expression .
 \endverbatim
 * Правила и ограничения:
 *
 * a) элемент <B>logical_expression</B> должен иметь значение типа \ref express::LOGICAL "LOGICAL";
 *
 * b) элемент <B>logical_expression</B> вычисляют заново в конце каждой итерации.
 *
 * \subsection p11_s13_10 13.10 Оператор RETURN
 *
 * Оператор возврата <B>RETURN</B> завершает исполнение функции или процедуры. В функции
 * оператор <B>RETURN</B> должен определять выражение. Значение, полученное при вычислении данного
 * выражения, является результатом функции и возвращается в точку вызова. Выражение должно быть
 * совместимо по присваиванию с объявленным типом данных, возвращаемым функцией. В процедуре
 * оператор <B>RETURN</B> не должен определять выражение.
 \verbatim
   Синтаксис:
    290 return_stmt = RETURN [ '(' expression ')' ] ';' .
 \endverbatim
 * Ограничение: оператор <B>RETURN</B> должен присутствовать только в функциях или процедурах.
 *
 * <B><I>Пример --- Допустимые операторы</I> RETURN<I>.</I>
 <PRE>
     RETURN(50);          (* возврат из функции *)
     RETURN(work_point);  (* возврат из функции *)
     RETURN;              (* возврат из процедуры *)
 </PRE> </B>
 *
 * \subsection p11_s13_11 13.11 Оператор SKIP
 *
 * Оператор <B>SKIP</B> вызывает немедленный переход в конец тела оператора <B>REPEAT</B>, в котором он
 * присутствует. Затем вычисляют значения управляющих условий в соответствии с \ref p11_s13_9 "13.9".
 \verbatim
   Синтаксис:
    308 skip_stmt = SKIP ';' .
 \endverbatim
 * Ограничение: оператор <B>SKIP</B> должен встречаться только в области видимости оператора <B>REPEAT</B>.
 *
 * <B><I>Пример --- Оператор</I> SKIP <I>передает управление оператору</I> END_REPEAT<I>, который инициирует
 * вычисление значения управляющего условия</I> UNTIL<I>.</I>
 <PRE>
     REPEAT UNTIL (a=1);
       ...
       IF (a < 0) THEN
         SKIP;
       END_IF;
       ... -- эти операторы будут пропущены, если а < 0
     END_REPEAT;
 </PRE> </B>
 *
 * \section p11_s14 14 Встроенные константы
 *
 * В языке EXPRESS имеется несколько встроенных констант, которые определены в настоящем
 * разделе.
 * 
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Считается, что встроенные константы имеют точные значения, даже если такое
 * значение не может быть представлено на компьютере.</SMALL>
 *
 * <BR>
 *
 * \copydetails express::CONST_E
 *
 * <BR>
 *
 * \subsection p11_s14_2 14.2 Неопределённость
 *
 * Символ неопределенности (<B>?</B>) обозначает неоднозначное значение. Он совместим со всеми типами
 * данных.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * Наиболее часто неопределённость (<B>?</B>) используется в качестве указателя верхней
 * границы пакета, списка или набора. Это обозначает, что размер агрегированного значения, определённого
 * агрегированным типом данных, является неограниченным.</SMALL>
 *
 * <BR>
 *
 * \copydetails express::FALSE
 *
 * <BR>
 *
 * \copydetails express::PI
 *
 * \subsection p11_s14_5 14.5 SELF
 *
 * Ключевое слово <B>SELF</B> обозначает ссылку на текущий экземпляр объекта или значение типа данных.
 * Ключевое слово <B>SELF</B> может присутствовать в объявлении объекта, объявлении типа данных или
 * конструкторе объекта.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * <B>SELF</B> не является константой, но играет роль константы в любом контексте, в котором
 * она может использоваться.</SMALL>
 *
 * <BR>
 *
 * \copydetails express::TRUE
 *
 * <BR>
 *
 * \copydetails express::UNKNOWN
 *
 * \section p11_s15 15 Встроенные функции
 *
 * Предполагается, что все функции (и математические операции вообще) вычисляются с точными
 * результатами. Все встроенные функции возвращают неопределённый (<B>?</B>) результат, если им был передан
 * параметр с неопределённым (<B>?</B>) значением, за исключением случаев, когда это в явном виде не
 * устанавливается в определении функции.
 *
 * Для каждой встроенной функции установлен прототип с целью демонстрации типов данных
 * формальных параметров и результата.
 *
 * <BR>
 *
 * \copydetails express::ABS()
 *
 * <BR>
 *
 * \copydetails express::ACOS()
 *
 * <BR>
 *
 * \copydetails express::ASIN()
 *
 * <BR>
 *
 * \copydetails express::ATAN()
 *
 * <BR>
 *
 * \copydetails express::BLENGTH()
 *
 * <BR>
 *
 * \copydetails express::COS()
 *
 * <BR>
 *
 * \copydetails express::EXISTS()
 *
 * <BR>
 *
 * \copydetails express::EXP()
 *
 * <BR>
 *
 * \copydetails express::FORMAT()
 *
 * <BR>
 *
 * \subsection p11_s15_9_1 15.9.1 Символьное представление
 *
 * Общая форма символьного формата имеет вид: <B>[sign] width [.decimals] type</B>.
 *
 * a) Элемент <B>sign</B> определяет представление знака числа. Если элемент <B>sign</B> не задан или задан
 * знаком минус (<B>-</B>), то первым возвращаемым символом будет минус для отрицательных чисел и пробел для
 * положительных чисел (включая ноль). Если элемент <B>sign</B> задан знаком плюс (<B>+</B>), то первым
 * возвращаемым символом будет минус для отрицательных чисел, плюс --- для положительных чисел и пробел --- для нуля.
 *
 * b) Элемент <B>width</B> задаёт общее число символов в возвращаемой строке. Он должен быть целым
 * числом больше двух. Если элемент <B>width</B> задан с предшествующим нулем, то возвращаемая строка
 * будет содержать предшествующие нули, в противном случае предшествующие нули опускаются. Если
 * для форматируемого числа требуется больше символов, чем задано элементом <B>width</B>, то возвращается
 * строка с необходимым числом символов.
 *
 * c) Элемент <B>decimals</B> задаёт число цифр в возвращаемой строке справа от десятичной точки. Если
 * данный элемент задан, то он должен быть положительным целым числом. Если элемент <B>decimals</B> не
 * задан, то в возвращаемой строке не будет десятичной точки и следующих за ней цифр.
 *
 * d) Элемент <B>type</B> является буквой, определяющей вид числа, представленного в возвращаемой строке:
 *
 * 1) если в качестве элемента <B>type</B> задана буква <B>I</B>, то результат должен быть представлен в виде
 * целого числа; при этом:
 * - элемент decimals не должен быть задан,
 * - значение элемента width должно быть не менее двух,
 *
 * 2) если в качестве элемента <B>type</B> задана буква <B>F</B>, то результат должен быть представлен в виде
 * действительного числа с фиксированной десятичной точкой; при этом:
 * - значение элемента decimals, если он задан, должно быть не менее единицы,
 * - если элемент decimals не задан, то используется его значение по умолчанию равное двум,
 * - значение элемента width должно быть не менее четырёх,
 *
 * 3) если в качестве элемента <B>type</B> задана буква <B>Е</B>, то результат должен быть представлен в виде
 * действительного числа в экспоненциальной форме, при этом:
 * - элемент <B>decimals</B> должен быть задан обязательно,
 * - значение элемента <B>decimals</B> должно быть не менее единицы,
 * - значение элемента <B>width</B> должно быть не менее семи,
 * - если в элементе <B>width</B> задан предшествующий ноль, то первыми двумя символами мантиссы будут <B>0.</B>,
 * - экспоненциальная часть должна содержать, по меньшей мере, два символа с обязательным знаком,
 * - отображаемый символ <B>'Е'</B> должен быть прописной буквой (символом верхнего регистра).
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * В \ref p11_table20 "таблице 20" показано, как форматирование влияет на вид отображения разных значений</SMALL>
 *
 * <BR>
 *
 * \anchor p11_table20
 * Т&nbsp;а&nbsp;б&nbsp;л&nbsp;и&nbsp;ц&nbsp;а 20 --- Пример влияния символьного форматирования
 *
 * <TABLE border="1" cellspacing="0">
 * <tr><td><CENTER>Число</CENTER></td><td><CENTER>Формат</CENTER></td><td><CENTER>Отображение</CENTER>   </td><td><CENTER>Комментарий</CENTER>        </td></tr>
 * <tr><td></td><td></td><td></td><td></td></tr>
 * <tr><td><B>10</B>             </td><td> <B>+7I</B>            </td><td><B><PRE>   '    +10'</PRE> </B> </td><td> Нули опущены                       </td></tr>
 * <tr><td><B>10</B>             </td><td> <B>+07I</B>           </td><td><B><PRE>   '+000010'</PRE> </B> </td><td> Нули не опущены                    </td></tr>
 * <tr><td><B>10</B>             </td><td> <B>10.3E</B>          </td><td><B><PRE>' 1.000E+01'</PRE> </B> </td><td>                                    </td></tr>
 * <tr><td><B>123.456789</B>     </td><td> <B>8.2F</B>           </td><td><B><PRE>  '  123.46'</PRE> </B> </td><td>                                    </td></tr>
 * <tr><td><B>123.456789</B>     </td><td> <B>8.2E</B>           </td><td><B><PRE>  '1.23E+02'</PRE> </B> </td><td>                                    </td></tr>
 * <tr><td><B>123.456789</B>     </td><td> <B>08.2E</B>          </td><td><B><PRE>  '0.12E+02'</PRE> </B> </td><td> Влияет предшествующий ноль         </td></tr>
 * <tr><td><B>9.876Е123</B>      </td><td> <B>8.2E</B>           </td><td><B><PRE> '9.88Е+123'</PRE> </B> </td><td> Экспоненциальная часть содержит три символа,<BR>
 *                                                                                                                 значение <B>width</B> игнорируется </td></tr>
 * <tr><td><B>32.777</B>         </td><td> <B>6I</B>             </td><td><B><PRE>   '    33'</PRE> </B> </td><td> Округлено                          </td></tr>
 * </TABLE>
 *
 * <BR>
 *
 * \subsection p11_s15_9_2 15.9.2 Представление шаблоном
 *
 * При форматировании посредством шаблона, каждый символ шаблона соответствует символу в
 * возвращаемой строке. Используемые в шаблоне символы представлены в \ref p11_table21 "таблице 21".
 *
 * <BR>
 *
 * \anchor p11_table21
 * Т&nbsp;а&nbsp;б&nbsp;л&nbsp;и&nbsp;ц&nbsp;а 21 --- Символы форматирования шаблоном
 *
 * <TABLE border="1" cellspacing="0">
 * <tr><td><CENTER>Символ</CENTER></td><td><CENTER>Значение</CENTER></td></tr>
 * <tr><td></td><td></td></tr>
 * <tr><td># (решётка)            </td><td> Представляет цифру      </td></tr>
 * <tr><td>, (запятая)            </td><td> Разделитель             </td></tr>
 * <tr><td>. (точка)              </td><td> Разделитель             </td></tr>
 * <tr><td>+ - (плюс и минус)     </td><td> Представляет знак       </td></tr>
 * <tr><td>()(круглые скобки)     </td><td> Представляет отрицание  </td></tr>
 * </TABLE>
 *
 * Разделители '.' и ',' используются следующим образом:
 * - если запятая встречается в строке форматирования до точки, то запятая представляет символ
 * группирования, а точка представляет десятичный символ;
 * - если точка встречается в строке форматирования до запятой, то точка представляет символ
 * группирования, а запятая — десятичный символ;
 * - если в строке форматирования присутствует один разделитель, то он представляет десятичный
 * символ.
 *
 * Все остальные символы отображаются без изменения.
 *
 * <SMALL>П&nbsp;р&nbsp;и&nbsp;м&nbsp;е&nbsp;ч&nbsp;а&nbsp;н&nbsp;и&nbsp;е ---
 * В \ref p11_table22 "таблице 22" показано, как форматирование влияет на вид отображения разных значений.</SMALL>
 *
 * <BR>
 *
 * \anchor p11_table22
 * Т&nbsp;а&nbsp;б&nbsp;л&nbsp;и&nbsp;ц&nbsp;а 22 --- Пример влияния форматирования шаблоном
 *
 * <TABLE border="1" cellspacing="0">
 * <tr><td><CENTER>Число</CENTER></td><td><CENTER>Формат</CENTER></td><td><CENTER>Отображение</CENTER>  </td><td><CENTER>Комментарий</CENTER> </td></tr>
 * <tr><td></td><td></td><td></td><td></td></tr>
 * <tr><td><B>10</B>             </td><td><B>###</B>             </td><td><B><PRE>       ' 10'</PRE></B></td><td>                             </td></tr>
 * <tr><td><B>10</B>             </td><td><B>(###)</B>           </td><td><B><PRE>     '  10 '</PRE></B></td><td> Круглые скобки игнорируются </td></tr>
 * <tr><td><B>-10</B>            </td><td><B>(###)</B>           </td><td><B><PRE>     '( 10)'</PRE></B></td><td>                             </td></tr>
 * <tr><td><B>7123.456</B>       </td><td><B>###,###.##</B>      </td><td><B><PRE>'  7,123.46'</PRE></B></td><td> Нотация США                 </td></tr>
 * <tr><td><B>7123.456</B>       </td><td><B>###.###,##</B>      </td><td><B><PRE>'  7.123,46'</PRE></B></td><td> Европейская нотация         </td></tr>
 * </TABLE>
 *
 * <BR>
 *
 * \subsection p11_s15_9_3 15.9.3 Стандартное представление
 *
 * Стандартным представлением для целых чисел является <B>'7I'</B>. Стандартным представлением для
 * действительных чисел является <B>'10.1E'</B>. Символьные представления форматов чисел определены в \ref p11_s15_9_1 "15.9.1".
 *
 * \copydetails express::HIBOUND()
 *
 * <BR>
 *
 * \copydetails express::HIINDEX()
 *
 * <BR>
 *
 * \copydetails express::LENGTH()
 *
 * <BR>
 *
 * \copydetails express::LOBOUND()
 *
 * <BR>
 *
 * \copydetails express::LOG()
 *
 * <BR>
 *
 * \copydetails express::LOG2()
 *
 * <BR>
 *
 * \copydetails express::LOG10()
 *
 * <BR>
 *
 * \copydetails express::LOINDEX()
 *
 * <BR>
 *
 * \copydetails express::NVL()
 *
 * <BR>
 *
 * \copydetails express::ODD()
 *
 * <BR>
 *
 * \copydetails express::ROLESOF()
 *
 * <BR>
 *
 * \copydetails express::SIN()
 *
 * <BR>
 *
 * \copydetails express::SIZEOF()
 *
 * <BR>
 *
 * \copydetails express::SQRT()
 *
 * <BR>
 *
 * \copydetails express::TAN()
 *
 * <BR>
 *
 * \copydetails express::TYPEOF()
 *
 * <BR>
 *
 * \copydetails express::USEDIN()
 *
 * <BR>
 *
 * \copydetails express::VALUE()
 *
 * <BR>
 *
 * \copydetails express::VALUE_IN()
 *
 * <BR>
 *
 * \copydetails express::VALUE_UNIQUE()
 *
 * \section p11_s16 16 Встроенные процедуры
 *
 * В языке EXPRESS имеется две встроенные процедуры, используемые для управления списками.
 * В данном разделе приведено описание этих процедур. Встроенные процедуры не исполняются, если им
 * передается неопределённый (<B>?</B>) параметр, если только иное не определено в явном виде в описании
 * процедуры.
 *
 * Для каждой процедуры задан заголовок, чтобы показать типы данных формальных параметров.
 *
 * <BR>
 *
 * \copydetails express::INSERT()
 *
 * <BR>
 *
 * \copydetails express::REMOVE()
 *
 */ 
